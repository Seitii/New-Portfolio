"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var SyncLane = /*                        */ 1;\n        var InputContinuousLane = /*            */ 4;\n        var DefaultLane = /*                    */ 16;\n        var IdleLane = /*                       */ 536870912;\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        exports.ConcurrentRoot = ConcurrentRoot;\n        exports.ContinuousEventPriority = ContinuousEventPriority;\n        exports.DefaultEventPriority = DefaultEventPriority;\n        exports.DiscreteEventPriority = DiscreteEventPriority;\n        exports.IdleEventPriority = IdleEventPriority;\n        exports.LegacyRoot = LegacyRoot;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDeEM7UUFDSDtRQUVBLElBQUlDLFdBQ0osMEJBQTBCLEdBQzFCO1FBQ0EsSUFBSUMsc0JBQ0osY0FBYyxHQUNkO1FBQ0EsSUFBSUMsY0FDSixzQkFBc0IsR0FDdEI7UUFDQSxJQUFJQyxXQUNKLHlCQUF5QixHQUN6QjtRQUVBLElBQUlDLHdCQUF3Qko7UUFDNUIsSUFBSUssMEJBQTBCSjtRQUM5QixJQUFJSyx1QkFBdUJKO1FBQzNCLElBQUlLLG9CQUFvQko7UUFFeEIsSUFBSUssYUFBYTtRQUNqQixJQUFJQyxpQkFBaUI7UUFFckJDLHNCQUFzQixHQUFHRDtRQUN6QkMsK0JBQStCLEdBQUdMO1FBQ2xDSyw0QkFBNEIsR0FBR0o7UUFDL0JJLDZCQUE2QixHQUFHTjtRQUNoQ00seUJBQXlCLEdBQUdIO1FBQzVCRyxrQkFBa0IsR0FBR0Y7SUFDbkI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpb25vdm8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanM/YmEwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIElucHV0Q29udGludW91c0xhbmUgPVxuLyogICAgICAgICAgICAqL1xuNDtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIElkbGVMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xuXG52YXIgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gU3luY0xhbmU7XG52YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lO1xudmFyIERlZmF1bHRFdmVudFByaW9yaXR5ID0gRGVmYXVsdExhbmU7XG52YXIgSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlTGFuZTtcblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIENvbmN1cnJlbnRSb290ID0gMTtcblxuZXhwb3J0cy5Db25jdXJyZW50Um9vdCA9IENvbmN1cnJlbnRSb290O1xuZXhwb3J0cy5Db250aW51b3VzRXZlbnRQcmlvcml0eSA9IENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EZWZhdWx0RXZlbnRQcmlvcml0eSA9IERlZmF1bHRFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLklkbGVFdmVudFByaW9yaXR5ID0gSWRsZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLkxlZ2FjeVJvb3QgPSBMZWdhY3lSb290O1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJTeW5jTGFuZSIsIklucHV0Q29udGludW91c0xhbmUiLCJEZWZhdWx0TGFuZSIsIklkbGVMYW5lIiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29udGludW91c0V2ZW50UHJpb3JpdHkiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIklkbGVFdmVudFByaW9yaXR5IiwiTGVnYWN5Um9vdCIsIkNvbmN1cnJlbnRSb290IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    module.exports = function $$$reconciler($$$hostConfig) {\n        var exports = {};\n        \"use strict\";\n        var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n        var Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n            {\n                suppressWarning = newSuppressWarning;\n            }\n        } // In DEV, calls to console.warn and console.error get replaced\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        var assign = Object.assign;\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        // -----------------------------------------------------------------------------\n        var enablePersistentOffscreenHostContainer = false; // -----------------------------------------------------------------------------\n        // the react-reconciler package.\n        var enableNewReconciler = false; // Support legacy Primer support on internal FB www\n        var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        var enableSuspenseAvoidThisFallback = false; // Enables unstable_avoidThisFallback feature in Fizz\n        var warnAboutStringRefs = false; // -----------------------------------------------------------------------------\n        // Debugging and DevTools\n        // -----------------------------------------------------------------------------\n        // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n        // for an experimental timeline tool.\n        var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n        var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var IndeterminateComponent = 2; // Before we know whether it is function or class\n        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_TRACING_MARKER_TYPE = Symbol.for(\"react.tracing_marker\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return outerType.displayName || (functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        } // Keep in sync with shared/getComponentNameFromType\n        function getContextName$1(type) {\n            return type.displayName || \"Context\";\n        }\n        function getComponentNameFromFiber(fiber) {\n            var tag = fiber.tag, type = fiber.type;\n            switch(tag){\n                case CacheComponent:\n                    return \"Cache\";\n                case ContextConsumer:\n                    var context = type;\n                    return getContextName$1(context) + \".Consumer\";\n                case ContextProvider:\n                    var provider = type;\n                    return getContextName$1(provider._context) + \".Provider\";\n                case DehydratedFragment:\n                    return \"DehydratedFragment\";\n                case ForwardRef:\n                    return getWrappedName$1(type, type.render, \"ForwardRef\");\n                case Fragment:\n                    return \"Fragment\";\n                case HostComponent:\n                    // Host component type is the display name (e.g. \"div\", \"View\")\n                    return type;\n                case HostPortal:\n                    return \"Portal\";\n                case HostRoot:\n                    return \"Root\";\n                case HostText:\n                    return \"Text\";\n                case LazyComponent:\n                    // Name comes from the type in this case; we don't have a tag.\n                    return getComponentNameFromType(type);\n                case Mode:\n                    if (type === REACT_STRICT_MODE_TYPE) {\n                        // Don't be less specific than shared/getComponentNameFromType\n                        return \"StrictMode\";\n                    }\n                    return \"Mode\";\n                case OffscreenComponent:\n                    return \"Offscreen\";\n                case Profiler:\n                    return \"Profiler\";\n                case ScopeComponent:\n                    return \"Scope\";\n                case SuspenseComponent:\n                    return \"Suspense\";\n                case SuspenseListComponent:\n                    return \"SuspenseList\";\n                case TracingMarkerComponent:\n                    return \"TracingMarker\";\n                // The display name for this tags come from the user-provided type:\n                case ClassComponent:\n                case FunctionComponent:\n                case IncompleteClassComponent:\n                case IndeterminateComponent:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    if (typeof type === \"function\") {\n                        return type.displayName || type.name || null;\n                    }\n                    if (typeof type === \"string\") {\n                        return type;\n                    }\n                    break;\n            }\n            return null;\n        }\n        // Don't change these two values. They're used by React Dev Tools.\n        var NoFlags = /*                      */ 0;\n        var PerformedWork = /*                */ 1; // You can change the rest (and add more).\n        var Placement = /*                    */ 2;\n        var Update = /*                       */ 4;\n        var PlacementAndUpdate = /*           */ Placement | Update;\n        var ChildDeletion = /*                */ 16;\n        var ContentReset = /*                 */ 32;\n        var Callback = /*                     */ 64;\n        var DidCapture = /*                   */ 128;\n        var ForceClientRender = /*            */ 256;\n        var Ref = /*                          */ 512;\n        var Snapshot = /*                     */ 1024;\n        var Passive = /*                      */ 2048;\n        var Hydrating = /*                    */ 4096;\n        var HydratingAndUpdate = /*           */ Hydrating | Update;\n        var Visibility = /*                   */ 8192;\n        var StoreConsistency = /*             */ 16384;\n        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency; // Union of all commit flags (flags with the lifetime of a particular commit)\n        var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.\n        var Incomplete = /*                   */ 32768;\n        var ShouldCapture = /*                */ 65536;\n        var ForceUpdateForLegacySuspense = /* */ 131072;\n        var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n        // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n        // This enables us to defer more work in the unmount case,\n        // since we can defer traversing the tree during layout to look for Passive effects,\n        // and instead rely on the static flag as a signal that there may be cleanup work.\n        var RefStatic = /*                    */ 2097152;\n        var LayoutStatic = /*                 */ 4194304;\n        var PassiveStatic = /*                */ 8388608; // These flags allow us to traverse to fibers that have effects on mount\n        // without traversing the entire tree after every commit for\n        // double invoking\n        var MountLayoutDev = /*               */ 16777216;\n        var MountPassiveDev = /*              */ 33554432; // Groups of flags that are used in the commit phase to skip over trees that\n        // don't contain effects, by checking subtreeFlags.\n        var BeforeMutationMask = // flag logic (see #20043)\n        Update | Snapshot | 0;\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\n        var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n        var PassiveMask = Passive | ChildDeletion; // Union of tags that don't get reset on clones.\n        // This allows certain concepts to persist without recalculating them,\n        // e.g. whether a subtree contains passive effects or portals.\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        function getNearestMountedFiber(fiber) {\n            var node = fiber;\n            var nearestMounted = fiber;\n            if (!fiber.alternate) {\n                // If there is no alternate, this might be a new tree that isn't inserted\n                // yet. If it is, then it will have a pending insertion effect on it.\n                var nextNode = node;\n                do {\n                    node = nextNode;\n                    if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n                        // This is an insertion or in-progress hydration. The nearest possible\n                        // mounted fiber is the parent but we need to continue to figure out\n                        // if that one is still mounted.\n                        nearestMounted = node.return;\n                    }\n                    nextNode = node.return;\n                }while (nextNode);\n            } else {\n                while(node.return){\n                    node = node.return;\n                }\n            }\n            if (node.tag === HostRoot) {\n                // TODO: Check if this was a nested HostRoot when used with\n                // renderContainerIntoSubtree.\n                return nearestMounted;\n            } // If we didn't hit the root, that means that we're in an disconnected tree\n            // that has been unmounted.\n            return null;\n        }\n        function isFiberMounted(fiber) {\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function isMounted(component) {\n            {\n                var owner = ReactCurrentOwner.current;\n                if (owner !== null && owner.tag === ClassComponent) {\n                    var ownerFiber = owner;\n                    var instance = ownerFiber.stateNode;\n                    if (!instance._warnedAboutRefsInRender) {\n                        error(\"%s is accessing isMounted inside its render() function. \" + \"render() should be a pure function of props and state. It should \" + \"never access something that requires stale data from the previous \" + \"render, such as refs. Move this logic to componentDidMount and \" + \"componentDidUpdate instead.\", getComponentNameFromFiber(ownerFiber) || \"A component\");\n                    }\n                    instance._warnedAboutRefsInRender = true;\n                }\n            }\n            var fiber = get(component);\n            if (!fiber) {\n                return false;\n            }\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n            if (getNearestMountedFiber(fiber) !== fiber) {\n                throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n            var alternate = fiber.alternate;\n            if (!alternate) {\n                // If there is no alternate, then we only need to check if it is mounted.\n                var nearestMounted = getNearestMountedFiber(fiber);\n                if (nearestMounted === null) {\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                }\n                if (nearestMounted !== fiber) {\n                    return null;\n                }\n                return fiber;\n            } // If we have two possible branches, we'll walk backwards up to the root\n            // to see what path the root points to. On the way we may hit one of the\n            // special cases and we'll deal with them.\n            var a = fiber;\n            var b = alternate;\n            while(true){\n                var parentA = a.return;\n                if (parentA === null) {\n                    break;\n                }\n                var parentB = parentA.alternate;\n                if (parentB === null) {\n                    // There is no alternate. This is an unusual case. Currently, it only\n                    // happens when a Suspense component is hidden. An extra fragment fiber\n                    // is inserted in between the Suspense fiber and its children. Skip\n                    // over this extra fragment fiber and proceed to the next parent.\n                    var nextParent = parentA.return;\n                    if (nextParent !== null) {\n                        a = b = nextParent;\n                        continue;\n                    } // If there's no parent, we're at the root.\n                    break;\n                } // If both copies of the parent fiber point to the same child, we can\n                // assume that the child is current. This happens when we bailout on low\n                // priority: the bailed out fiber's child reuses the current child.\n                if (parentA.child === parentB.child) {\n                    var child = parentA.child;\n                    while(child){\n                        if (child === a) {\n                            // We've determined that A is the current branch.\n                            assertIsMounted(parentA);\n                            return fiber;\n                        }\n                        if (child === b) {\n                            // We've determined that B is the current branch.\n                            assertIsMounted(parentA);\n                            return alternate;\n                        }\n                        child = child.sibling;\n                    } // We should never have an alternate for any mounting node. So the only\n                    // way this could possibly happen is if this was unmounted, if at all.\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                }\n                if (a.return !== b.return) {\n                    // The return pointer of A and the return pointer of B point to different\n                    // fibers. We assume that return pointers never criss-cross, so A must\n                    // belong to the child set of A.return, and B must belong to the child\n                    // set of B.return.\n                    a = parentA;\n                    b = parentB;\n                } else {\n                    // The return pointers point to the same fiber. We'll have to use the\n                    // default, slow path: scan the child sets of each parent alternate to see\n                    // which child belongs to which set.\n                    //\n                    // Search parent A's child set\n                    var didFindChild = false;\n                    var _child = parentA.child;\n                    while(_child){\n                        if (_child === a) {\n                            didFindChild = true;\n                            a = parentA;\n                            b = parentB;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = true;\n                            b = parentA;\n                            a = parentB;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) {\n                        // Search parent B's child set\n                        _child = parentB.child;\n                        while(_child){\n                            if (_child === a) {\n                                didFindChild = true;\n                                a = parentB;\n                                b = parentA;\n                                break;\n                            }\n                            if (_child === b) {\n                                didFindChild = true;\n                                b = parentB;\n                                a = parentA;\n                                break;\n                            }\n                            _child = _child.sibling;\n                        }\n                        if (!didFindChild) {\n                            throw new Error(\"Child was not found in either parent set. This indicates a bug \" + \"in React related to the return pointer. Please file an issue.\");\n                        }\n                    }\n                }\n                if (a.alternate !== b) {\n                    throw new Error(\"Return fibers should always be each others' alternates. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n            } // If the root is not a host container, we're in a disconnected tree. I.e.\n            // unmounted.\n            if (a.tag !== HostRoot) {\n                throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.stateNode.current === a) {\n                // We've determined that A is the current branch.\n                return fiber;\n            } // Otherwise B has to be current branch.\n            return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            if (node.tag === HostComponent || node.tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                var match = findCurrentHostFiberImpl(child);\n                if (match !== null) {\n                    return match;\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            if (node.tag === HostComponent || node.tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                if (child.tag !== HostPortal) {\n                    var match = findCurrentHostFiberWithNoPortalsImpl(child);\n                    if (match !== null) {\n                        return match;\n                    }\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // This is a host config that's used for the `react-reconciler` package on npm.\n        // It is only used by third-party renderers.\n        //\n        // Its API lets you pass the host config as an argument.\n        // However, inside the `react-reconciler` we treat host config as a module.\n        // This file is a shim between two worlds.\n        //\n        // It works because the `react-reconciler` bundle is wrapped in something like:\n        //\n        // module.exports = function ($$$config) {\n        //   /* reconciler code */\n        // }\n        //\n        // So `$$$config` looks like a global variable, but it's\n        // really an argument to a top-level wrapping function.\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        var getPublicInstance = $$$hostConfig.getPublicInstance;\n        var getRootHostContext = $$$hostConfig.getRootHostContext;\n        var getChildHostContext = $$$hostConfig.getChildHostContext;\n        var prepareForCommit = $$$hostConfig.prepareForCommit;\n        var resetAfterCommit = $$$hostConfig.resetAfterCommit;\n        var createInstance = $$$hostConfig.createInstance;\n        var appendInitialChild = $$$hostConfig.appendInitialChild;\n        var finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;\n        var prepareUpdate = $$$hostConfig.prepareUpdate;\n        var shouldSetTextContent = $$$hostConfig.shouldSetTextContent;\n        var createTextInstance = $$$hostConfig.createTextInstance;\n        var scheduleTimeout = $$$hostConfig.scheduleTimeout;\n        var cancelTimeout = $$$hostConfig.cancelTimeout;\n        var noTimeout = $$$hostConfig.noTimeout;\n        var now = $$$hostConfig.now;\n        var isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;\n        var warnsIfNotActing = $$$hostConfig.warnsIfNotActing;\n        var supportsMutation = $$$hostConfig.supportsMutation;\n        var supportsPersistence = $$$hostConfig.supportsPersistence;\n        var supportsHydration = $$$hostConfig.supportsHydration;\n        var getInstanceFromNode = $$$hostConfig.getInstanceFromNode;\n        var beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur;\n        var afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur;\n        var preparePortalMount = $$$hostConfig.preparePortalMount;\n        var prepareScopeUpdate = $$$hostConfig.preparePortalMount;\n        var getInstanceFromScope = $$$hostConfig.getInstanceFromScope;\n        var getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;\n        var detachDeletedInstance = $$$hostConfig.detachDeletedInstance; // -------------------\n        //      Microtasks\n        //     (optional)\n        // -------------------\n        var supportsMicrotasks = $$$hostConfig.supportsMicrotasks;\n        var scheduleMicrotask = $$$hostConfig.scheduleMicrotask; // -------------------\n        //      Test selectors\n        //     (optional)\n        // -------------------\n        var supportsTestSelectors = $$$hostConfig.supportsTestSelectors;\n        var findFiberRoot = $$$hostConfig.findFiberRoot;\n        var getBoundingRect = $$$hostConfig.getBoundingRect;\n        var getTextContent = $$$hostConfig.getTextContent;\n        var isHiddenSubtree = $$$hostConfig.isHiddenSubtree;\n        var matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;\n        var setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;\n        var setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver; // -------------------\n        //      Mutation\n        //     (optional)\n        // -------------------\n        var appendChild = $$$hostConfig.appendChild;\n        var appendChildToContainer = $$$hostConfig.appendChildToContainer;\n        var commitTextUpdate = $$$hostConfig.commitTextUpdate;\n        var commitMount = $$$hostConfig.commitMount;\n        var commitUpdate = $$$hostConfig.commitUpdate;\n        var insertBefore = $$$hostConfig.insertBefore;\n        var insertInContainerBefore = $$$hostConfig.insertInContainerBefore;\n        var removeChild = $$$hostConfig.removeChild;\n        var removeChildFromContainer = $$$hostConfig.removeChildFromContainer;\n        var resetTextContent = $$$hostConfig.resetTextContent;\n        var hideInstance = $$$hostConfig.hideInstance;\n        var hideTextInstance = $$$hostConfig.hideTextInstance;\n        var unhideInstance = $$$hostConfig.unhideInstance;\n        var unhideTextInstance = $$$hostConfig.unhideTextInstance;\n        var clearContainer = $$$hostConfig.clearContainer; // -------------------\n        //     Persistence\n        //     (optional)\n        // -------------------\n        var cloneInstance = $$$hostConfig.cloneInstance;\n        var createContainerChildSet = $$$hostConfig.createContainerChildSet;\n        var appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;\n        var finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;\n        var replaceContainerChildren = $$$hostConfig.replaceContainerChildren;\n        var getOffscreenContainerType = $$$hostConfig.getOffscreenContainerType;\n        var getOffscreenContainerProps = $$$hostConfig.getOffscreenContainerProps;\n        var cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;\n        var cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance; // -------------------\n        //     Hydration\n        //     (optional)\n        // -------------------\n        var canHydrateInstance = $$$hostConfig.canHydrateInstance;\n        var canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;\n        var canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;\n        var isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;\n        var isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;\n        var registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;\n        var getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;\n        var getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;\n        var getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;\n        var getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;\n        var hydrateInstance = $$$hostConfig.hydrateInstance;\n        var hydrateTextInstance = $$$hostConfig.hydrateTextInstance;\n        var hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;\n        var getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;\n        var commitHydratedContainer = $$$hostConfig.commitHydratedContainer;\n        var commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;\n        var clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;\n        var clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;\n        var shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;\n        var didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;\n        var didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;\n        var didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;\n        var didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;\n        var didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;\n        var didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;\n        var didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;\n        var didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;\n        var didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;\n        var didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;\n        var didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;\n        var didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;\n        var didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;\n        var didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;\n        var errorHydratingContainer = $$$hostConfig.errorHydratingContainer;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        }\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    }\n                    fn();\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var valueStack = [];\n        var fiberStack;\n        {\n            fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n            return {\n                current: defaultValue\n            };\n        }\n        function pop(cursor, fiber) {\n            if (index < 0) {\n                {\n                    error(\"Unexpected pop.\");\n                }\n                return;\n            }\n            {\n                if (fiber !== fiberStack[index]) {\n                    error(\"Unexpected Fiber popped.\");\n                }\n            }\n            cursor.current = valueStack[index];\n            valueStack[index] = null;\n            {\n                fiberStack[index] = null;\n            }\n            index--;\n        }\n        function push(cursor, value, fiber) {\n            index++;\n            valueStack[index] = cursor.current;\n            {\n                fiberStack[index] = fiber;\n            }\n            cursor.current = value;\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n        var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n        // We use this to get access to the parent context after we have already\n        // pushed the next context provider, and now need to merge their contexts.\n        var previousContext = emptyContextObject;\n        function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n            {\n                if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n                    // If the fiber is a context provider itself, when we read its context\n                    // we may have already pushed its own child context on the stack. A context\n                    // provider should not \"see\" its own child context. Therefore we read the\n                    // previous (parent) context instead for a context provider.\n                    return previousContext;\n                }\n                return contextStackCursor.current;\n            }\n        }\n        function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n            {\n                var instance = workInProgress.stateNode;\n                instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n                instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n            }\n        }\n        function getMaskedContext(workInProgress, unmaskedContext) {\n            {\n                var type = workInProgress.type;\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                } // Avoid recreating masked context unless unmasked context has changed.\n                // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n                // This may trigger infinite loops if componentWillReceiveProps calls setState.\n                var instance = workInProgress.stateNode;\n                if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n                    return instance.__reactInternalMemoizedMaskedChildContext;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                // Context is created before the class component is instantiated so check for instance.\n                if (instance) {\n                    cacheContext(workInProgress, unmaskedContext, context);\n                }\n                return context;\n            }\n        }\n        function hasContextChanged() {\n            {\n                return didPerformWorkStackCursor.current;\n            }\n        }\n        function isContextProvider(type) {\n            {\n                var childContextTypes = type.childContextTypes;\n                return childContextTypes !== null && childContextTypes !== undefined;\n            }\n        }\n        function popContext(fiber) {\n            {\n                pop(didPerformWorkStackCursor, fiber);\n                pop(contextStackCursor, fiber);\n            }\n        }\n        function popTopLevelContextObject(fiber) {\n            {\n                pop(didPerformWorkStackCursor, fiber);\n                pop(contextStackCursor, fiber);\n            }\n        }\n        function pushTopLevelContextObject(fiber, context, didChange) {\n            {\n                if (contextStackCursor.current !== emptyContextObject) {\n                    throw new Error(\"Unexpected context found on stack. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                push(contextStackCursor, context, fiber);\n                push(didPerformWorkStackCursor, didChange, fiber);\n            }\n        }\n        function processChildContext(fiber, type, parentContext) {\n            {\n                var instance = fiber.stateNode;\n                var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromFiber(fiber) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromFiber(fiber) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        function pushContextProvider(workInProgress) {\n            {\n                var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n                // If the instance does not exist yet, we will push null at first,\n                // and replace it on the stack later when invalidating the context.\n                var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n                // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n                previousContext = contextStackCursor.current;\n                push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n                push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n                return true;\n            }\n        }\n        function invalidateContextProvider(workInProgress, type, didChange) {\n            {\n                var instance = workInProgress.stateNode;\n                if (!instance) {\n                    throw new Error(\"Expected to have an instance by this point. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                if (didChange) {\n                    // Merge parent and own context.\n                    // Skip this if we're not updating due to sCU.\n                    // This avoids unnecessarily recomputing memoized values.\n                    var mergedContext = processChildContext(workInProgress, type, previousContext);\n                    instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n                    // It is important to unwind the context in the reverse order.\n                    pop(didPerformWorkStackCursor, workInProgress);\n                    pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n                    push(contextStackCursor, mergedContext, workInProgress);\n                    push(didPerformWorkStackCursor, didChange, workInProgress);\n                } else {\n                    pop(didPerformWorkStackCursor, workInProgress);\n                    push(didPerformWorkStackCursor, didChange, workInProgress);\n                }\n            }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n            {\n                // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n                // makes sense elsewhere\n                if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n                    throw new Error(\"Expected subtree parent to be a mounted class component. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                var node = fiber;\n                do {\n                    switch(node.tag){\n                        case HostRoot:\n                            return node.stateNode.context;\n                        case ClassComponent:\n                            {\n                                var Component = node.type;\n                                if (isContextProvider(Component)) {\n                                    return node.stateNode.__reactInternalMemoizedMergedChildContext;\n                                }\n                                break;\n                            }\n                    }\n                    node = node.return;\n                }while (node !== null);\n                throw new Error(\"Found unexpected detached subtree parent. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n        var ConcurrentMode = /*                 */ 1;\n        var ProfileMode = /*                    */ 2;\n        var StrictLegacyMode = /*               */ 8;\n        var StrictEffectsMode = /*              */ 16;\n        // TODO: This is pretty well supported by browsers. Maybe we can drop it.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // If those values are changed that package should be rebuilt and redeployed.\n        var TotalLanes = 31;\n        var NoLanes = /*                        */ 0;\n        var NoLane = /*                          */ 0;\n        var SyncLane = /*                        */ 1;\n        var InputContinuousHydrationLane = /*    */ 2;\n        var InputContinuousLane = /*            */ 4;\n        var DefaultHydrationLane = /*            */ 8;\n        var DefaultLane = /*                    */ 16;\n        var TransitionHydrationLane = /*                */ 32;\n        var TransitionLanes = /*                       */ 4194240;\n        var TransitionLane1 = /*                        */ 64;\n        var TransitionLane2 = /*                        */ 128;\n        var TransitionLane3 = /*                        */ 256;\n        var TransitionLane4 = /*                        */ 512;\n        var TransitionLane5 = /*                        */ 1024;\n        var TransitionLane6 = /*                        */ 2048;\n        var TransitionLane7 = /*                        */ 4096;\n        var TransitionLane8 = /*                        */ 8192;\n        var TransitionLane9 = /*                        */ 16384;\n        var TransitionLane10 = /*                       */ 32768;\n        var TransitionLane11 = /*                       */ 65536;\n        var TransitionLane12 = /*                       */ 131072;\n        var TransitionLane13 = /*                       */ 262144;\n        var TransitionLane14 = /*                       */ 524288;\n        var TransitionLane15 = /*                       */ 1048576;\n        var TransitionLane16 = /*                       */ 2097152;\n        var RetryLanes = /*                            */ 130023424;\n        var RetryLane1 = /*                             */ 4194304;\n        var RetryLane2 = /*                             */ 8388608;\n        var RetryLane3 = /*                             */ 16777216;\n        var RetryLane4 = /*                             */ 33554432;\n        var RetryLane5 = /*                             */ 67108864;\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = /*          */ 134217728;\n        var NonIdleLanes = /*                                 */ 268435455;\n        var IdleHydrationLane = /*               */ 268435456;\n        var IdleLane = /*                       */ 536870912;\n        var OffscreenLane = /*                   */ 1073741824; // This function is used for the experimental timeline (react-devtools-timeline)\n        // It should be kept in sync with the Lanes values above.\n        function getLabelForLane(lane) {\n            {\n                if (lane & SyncLane) {\n                    return \"Sync\";\n                }\n                if (lane & InputContinuousHydrationLane) {\n                    return \"InputContinuousHydration\";\n                }\n                if (lane & InputContinuousLane) {\n                    return \"InputContinuous\";\n                }\n                if (lane & DefaultHydrationLane) {\n                    return \"DefaultHydration\";\n                }\n                if (lane & DefaultLane) {\n                    return \"Default\";\n                }\n                if (lane & TransitionHydrationLane) {\n                    return \"TransitionHydration\";\n                }\n                if (lane & TransitionLanes) {\n                    return \"Transition\";\n                }\n                if (lane & RetryLanes) {\n                    return \"Retry\";\n                }\n                if (lane & SelectiveHydrationLane) {\n                    return \"SelectiveHydration\";\n                }\n                if (lane & IdleHydrationLane) {\n                    return \"IdleHydration\";\n                }\n                if (lane & IdleLane) {\n                    return \"Idle\";\n                }\n                if (lane & OffscreenLane) {\n                    return \"Offscreen\";\n                }\n            }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n            switch(getHighestPriorityLane(lanes)){\n                case SyncLane:\n                    return SyncLane;\n                case InputContinuousHydrationLane:\n                    return InputContinuousHydrationLane;\n                case InputContinuousLane:\n                    return InputContinuousLane;\n                case DefaultHydrationLane:\n                    return DefaultHydrationLane;\n                case DefaultLane:\n                    return DefaultLane;\n                case TransitionHydrationLane:\n                    return TransitionHydrationLane;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                    return lanes & TransitionLanes;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    return lanes & RetryLanes;\n                case SelectiveHydrationLane:\n                    return SelectiveHydrationLane;\n                case IdleHydrationLane:\n                    return IdleHydrationLane;\n                case IdleLane:\n                    return IdleLane;\n                case OffscreenLane:\n                    return OffscreenLane;\n                default:\n                    {\n                        error(\"Should have found matching lanes. This is a bug in React.\");\n                    }\n                    return lanes;\n            }\n        }\n        function getNextLanes(root, wipLanes) {\n            // Early bailout if there's no pending work left.\n            var pendingLanes = root.pendingLanes;\n            if (pendingLanes === NoLanes) {\n                return NoLanes;\n            }\n            var nextLanes = NoLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n            // even if the work is suspended.\n            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n            if (nonIdlePendingLanes !== NoLanes) {\n                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n                if (nonIdleUnblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n                } else {\n                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n                    if (nonIdlePingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n                    }\n                }\n            } else {\n                // The only remaining work is Idle.\n                var unblockedLanes = pendingLanes & ~suspendedLanes;\n                if (unblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(unblockedLanes);\n                } else {\n                    if (pingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(pingedLanes);\n                    }\n                }\n            }\n            if (nextLanes === NoLanes) {\n                // This should only be reachable if we're suspended\n                // TODO: Consider warning in this path if a fallback timer is not scheduled.\n                return NoLanes;\n            } // If we're already in the middle of a render, switching lanes will interrupt\n            // it and we'll lose our progress. We should only do this if the new lanes are\n            // higher priority.\n            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n            // bother waiting until the root is complete.\n            (wipLanes & suspendedLanes) === NoLanes) {\n                var nextLane = getHighestPriorityLane(nextLanes);\n                var wipLane = getHighestPriorityLane(wipLanes);\n                if (// one. This works because the bits decrease in priority as you go left.\n                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n                // only difference between default updates and transition updates is that\n                // default updates do not support refresh transitions.\n                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n                    // Keep working on the existing in-progress tree. Do not interrupt.\n                    return wipLanes;\n                }\n            }\n            if ((nextLanes & InputContinuousLane) !== NoLanes) {\n                // When updates are sync by default, we entangle continuous priority updates\n                // and default updates, so they render in the same batch. The only reason\n                // they use separate lanes is because continuous updates should interrupt\n                // transitions, but default updates should not.\n                nextLanes |= pendingLanes & DefaultLane;\n            } // Check for entangled lanes and add them to the batch.\n            //\n            // A lane is said to be entangled with another when it's not allowed to render\n            // in a batch that does not also include the other lane. Typically we do this\n            // when multiple updates have the same source, and we only want to respond to\n            // the most recent event from that source.\n            //\n            // Note that we apply entanglements *after* checking for partial work above.\n            // This means that if a lane is entangled during an interleaved event while\n            // it's already rendering, we won't interrupt it. This is intentional, since\n            // entanglement is usually \"best effort\": we'll try our best to render the\n            // lanes in the same batch, but it's not worth throwing out partially\n            // completed work in order to do it.\n            // TODO: Reconsider this. The counter-argument is that the partial work\n            // represents an intermediate state, which we don't want to show to the user.\n            // And by spending extra time finishing it, we're increasing the amount of\n            // time it takes to show the final state, which is what they are actually\n            // waiting for.\n            //\n            // For those exceptions where entanglement is semantically important, like\n            // useMutableSource, we should ensure that there is no partial work at the\n            // time we apply the entanglement.\n            var entangledLanes = root.entangledLanes;\n            if (entangledLanes !== NoLanes) {\n                var entanglements = root.entanglements;\n                var lanes = nextLanes & entangledLanes;\n                while(lanes > 0){\n                    var index = pickArbitraryLaneIndex(lanes);\n                    var lane = 1 << index;\n                    nextLanes |= entanglements[index];\n                    lanes &= ~lane;\n                }\n            }\n            return nextLanes;\n        }\n        function getMostRecentEventTime(root, lanes) {\n            var eventTimes = root.eventTimes;\n            var mostRecentEventTime = NoTimestamp;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var eventTime = eventTimes[index];\n                if (eventTime > mostRecentEventTime) {\n                    mostRecentEventTime = eventTime;\n                }\n                lanes &= ~lane;\n            }\n            return mostRecentEventTime;\n        }\n        function computeExpirationTime(lane, currentTime) {\n            switch(lane){\n                case SyncLane:\n                case InputContinuousHydrationLane:\n                case InputContinuousLane:\n                    // User interactions should expire slightly more quickly.\n                    //\n                    // NOTE: This is set to the corresponding constant as in Scheduler.js.\n                    // When we made it larger, a product metric in www regressed, suggesting\n                    // there's a user interaction that's being starved by a series of\n                    // synchronous updates. If that theory is correct, the proper solution is\n                    // to fix the starvation. However, this scenario supports the idea that\n                    // expiration times are an important safeguard when starvation\n                    // does happen.\n                    return currentTime + 250;\n                case DefaultHydrationLane:\n                case DefaultLane:\n                case TransitionHydrationLane:\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                    return currentTime + 5000;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    // TODO: Retries should be allowed to expire if they are CPU bound for\n                    // too long, but when I made this change it caused a spike in browser\n                    // crashes. There must be some other underlying bug; not super urgent but\n                    // ideally should figure out why and fix it. Unfortunately we don't have\n                    // a repro for the crashes, only detected via production metrics.\n                    return NoTimestamp;\n                case SelectiveHydrationLane:\n                case IdleHydrationLane:\n                case IdleLane:\n                case OffscreenLane:\n                    // Anything idle priority or lower should never expire.\n                    return NoTimestamp;\n                default:\n                    {\n                        error(\"Should have found matching lanes. This is a bug in React.\");\n                    }\n                    return NoTimestamp;\n            }\n        }\n        function markStarvedLanesAsExpired(root, currentTime) {\n            // TODO: This gets called every time we yield. We can optimize by storing\n            // the earliest expiration time on the root. Then use that to quickly bail out\n            // of this function.\n            var pendingLanes = root.pendingLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes;\n            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n            // expiration time. If so, we'll assume the update is being starved and mark\n            // it as expired to force it to finish.\n            var lanes = pendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var expirationTime = expirationTimes[index];\n                if (expirationTime === NoTimestamp) {\n                    // Found a pending lane with no expiration time. If it's not suspended, or\n                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n                    // using the current time.\n                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                        // Assumes timestamps are monotonically increasing.\n                        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n                    }\n                } else if (expirationTime <= currentTime) {\n                    // This lane expired\n                    root.expiredLanes |= lane;\n                }\n                lanes &= ~lane;\n            }\n        } // This returns the highest priority pending lanes regardless of whether they\n        // are suspended.\n        function getHighestPriorityPendingLanes(root) {\n            return getHighestPriorityLanes(root.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root) {\n            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n            if (everythingButOffscreen !== NoLanes) {\n                return everythingButOffscreen;\n            }\n            if (everythingButOffscreen & OffscreenLane) {\n                return OffscreenLane;\n            }\n            return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n            return (lanes & SyncLane) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n            return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n            return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyTransitions(lanes) {\n            return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root, lanes) {\n            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n            return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root, lanes) {\n            // This is a separate check from includesBlockingLane because a lane can\n            // expire after a render has already started.\n            return (lanes & root.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n            return (lane & TransitionLanes) !== 0;\n        }\n        function claimNextTransitionLane() {\n            // Cycle through the lanes, assigning each new transition to the next lane.\n            // In most cases, this means every transition gets its own lane, until we\n            // run out of lanes and cycle back to the beginning.\n            var lane = nextTransitionLane;\n            nextTransitionLane <<= 1;\n            if ((nextTransitionLane & TransitionLanes) === 0) {\n                nextTransitionLane = TransitionLane1;\n            }\n            return lane;\n        }\n        function claimNextRetryLane() {\n            var lane = nextRetryLane;\n            nextRetryLane <<= 1;\n            if ((nextRetryLane & RetryLanes) === 0) {\n                nextRetryLane = RetryLane1;\n            }\n            return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n            return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n            // This wrapper function gets inlined. Only exists so to communicate that it\n            // doesn't matter which bit is selected; you can pick any bit without\n            // affecting the algorithms where its used. Here I'm using\n            // getHighestPriorityLane because it requires the fewest operations.\n            return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n            return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n            return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n            return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set, subset) {\n            return (set & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n            return a | b;\n        }\n        function removeLanes(set, subset) {\n            return set & ~subset;\n        }\n        function intersectLanes(a, b) {\n            return a & b;\n        } // Seems redundant, but it changes the type from a single lane (used for\n        // updates) to a group of lanes (used for flushing work).\n        function laneToLanes(lane) {\n            return lane;\n        }\n        function higherPriorityLane(a, b) {\n            // This works because the bit ranges decrease in priority as you go left.\n            return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n            // Intentionally pushing one by one.\n            // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n            var laneMap = [];\n            for(var i = 0; i < TotalLanes; i++){\n                laneMap.push(initial);\n            }\n            return laneMap;\n        }\n        function markRootUpdated(root, updateLane, eventTime) {\n            root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n            // could unblock them. Clear the suspended lanes so that we can try rendering\n            // them again.\n            //\n            // TODO: We really only need to unsuspend only lanes that are in the\n            // `subtreeLanes` of the updated fiber, or the update lanes of the return\n            // path. This would exclude suspended updates in an unrelated sibling tree,\n            // since there's no way for this update to unblock it.\n            //\n            // We don't do this if the incoming update is idle, because we never process\n            // idle updates until after all the regular updates have finished; there's no\n            // way it could unblock a transition.\n            if (updateLane !== IdleLane) {\n                root.suspendedLanes = NoLanes;\n                root.pingedLanes = NoLanes;\n            }\n            var eventTimes = root.eventTimes;\n            var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n            // recent event, and we assume time is monotonically increasing.\n            eventTimes[index] = eventTime;\n        }\n        function markRootSuspended(root, suspendedLanes) {\n            root.suspendedLanes |= suspendedLanes;\n            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n            var expirationTimes = root.expirationTimes;\n            var lanes = suspendedLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n        }\n        function markRootPinged(root, pingedLanes, eventTime) {\n            root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root, remainingLanes) {\n            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n            root.pendingLanes = remainingLanes; // Let's try everything again\n            root.suspendedLanes = 0;\n            root.pingedLanes = 0;\n            root.expiredLanes &= remainingLanes;\n            root.mutableReadLanes &= remainingLanes;\n            root.entangledLanes &= remainingLanes;\n            var entanglements = root.entanglements;\n            var eventTimes = root.eventTimes;\n            var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n            var lanes = noLongerPendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                entanglements[index] = NoLanes;\n                eventTimes[index] = NoTimestamp;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n        }\n        function markRootEntangled(root, entangledLanes) {\n            // In addition to entangling each of the given lanes with each other, we also\n            // have to consider _transitive_ entanglements. For each lane that is already\n            // entangled with *any* of the given lanes, that lane is now transitively\n            // entangled with *all* the given lanes.\n            //\n            // Translated: If C is entangled with A, then entangling A with B also\n            // entangles C with B.\n            //\n            // If this is hard to grasp, it might help to intentionally break this\n            // function and look at the tests that fail in ReactTransition-test.js. Try\n            // commenting out one of the conditions below.\n            var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n            var entanglements = root.entanglements;\n            var lanes = rootEntangledLanes;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n                entanglements[index] & entangledLanes) {\n                    entanglements[index] |= entangledLanes;\n                }\n                lanes &= ~lane;\n            }\n        }\n        function getBumpedLaneForHydration(root, renderLanes) {\n            var renderLane = getHighestPriorityLane(renderLanes);\n            var lane;\n            switch(renderLane){\n                case InputContinuousLane:\n                    lane = InputContinuousHydrationLane;\n                    break;\n                case DefaultLane:\n                    lane = DefaultHydrationLane;\n                    break;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    lane = TransitionHydrationLane;\n                    break;\n                case IdleLane:\n                    lane = IdleHydrationLane;\n                    break;\n                default:\n                    // Everything else is already either a hydration lane, or shouldn't\n                    // be retried at a hydration lane.\n                    lane = NoLane;\n                    break;\n            } // Check if the lane we chose is suspended. If so, that indicates that we\n            // already attempted and failed to hydrate at that level. Also check if we're\n            // already rendering that lane, which is rare but could happen.\n            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n                // Give up trying to hydrate and fall back to client render.\n                return NoLane;\n            }\n            return lane;\n        }\n        function addFiberToLanesMap(root, fiber, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                updaters.add(fiber);\n                lanes &= ~lane;\n            }\n        }\n        function movePendingFibersToMemoized(root, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            var memoizedUpdaters = root.memoizedUpdaters;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                if (updaters.size > 0) {\n                    updaters.forEach(function(fiber) {\n                        var alternate = fiber.alternate;\n                        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                            memoizedUpdaters.add(fiber);\n                        }\n                    });\n                    updaters.clear();\n                }\n                lanes &= ~lane;\n            }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        var currentUpdatePriority = NoLane;\n        function getCurrentUpdatePriority() {\n            return currentUpdatePriority;\n        }\n        function setCurrentUpdatePriority(newPriority) {\n            currentUpdatePriority = newPriority;\n        }\n        function runWithPriority(priority, fn) {\n            var previousPriority = currentUpdatePriority;\n            try {\n                currentUpdatePriority = priority;\n                return fn();\n            } finally{\n                currentUpdatePriority = previousPriority;\n            }\n        }\n        function higherEventPriority(a, b) {\n            return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n            return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n            return a !== 0 && a < b;\n        }\n        function lanesToEventPriority(lanes) {\n            var lane = getHighestPriorityLane(lanes);\n            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n                return DiscreteEventPriority;\n            }\n            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n                return ContinuousEventPriority;\n            }\n            if (includesNonIdleWork(lane)) {\n                return DefaultEventPriority;\n            }\n            return IdleEventPriority;\n        }\n        // This module only exists as an ESM wrapper around the external CommonJS\n        var scheduleCallback = Scheduler.unstable_scheduleCallback;\n        var cancelCallback = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now$1 = Scheduler.unstable_now;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority = Scheduler.unstable_NormalPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority;\n        // this doesn't actually exist on the scheduler, but it *does*\n        // on scheduler/unstable_mock, which we'll need for internal testing\n        var unstable_yieldValue = Scheduler.unstable_yieldValue;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n        function injectInternals(internals) {\n            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n                // No DevTools\n                return false;\n            }\n            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n            if (hook.isDisabled) {\n                // This isn't a real property on the hook, but it can be set to opt out\n                // of DevTools integration and associated warnings and logs.\n                // https://github.com/facebook/react/issues/3877\n                return true;\n            }\n            if (!hook.supportsFiber) {\n                {\n                    error(\"The installed version of React DevTools is too old and will not work \" + \"with the current version of React. Please update React DevTools. \" + \"https://reactjs.org/link/react-devtools\");\n                }\n                return true;\n            }\n            try {\n                if (enableSchedulingProfiler) {\n                    // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n                    // This gives DevTools a way to feature detect that isn't tied to version number\n                    // (since profiling and timeline are controlled by different feature flags).\n                    internals = assign({}, internals, {\n                        getLaneLabelMap: getLaneLabelMap,\n                        injectProfilingHooks: injectProfilingHooks\n                    });\n                }\n                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n                injectedHook = hook;\n            } catch (err) {\n                // Catch all errors because it is unsafe to throw during initialization.\n                {\n                    error(\"React instrumentation encountered an error: %s.\", err);\n                }\n            }\n            if (hook.checkDCE) {\n                // This is the real DevTools.\n                return true;\n            } else {\n                // This is likely a hook installed by Fast Refresh runtime.\n                return false;\n            }\n        }\n        function onScheduleRoot(root, children) {\n            {\n                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === \"function\") {\n                    try {\n                        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n                    } catch (err) {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitRoot(root, eventPriority) {\n            if (injectedHook && typeof injectedHook.onCommitFiberRoot === \"function\") {\n                try {\n                    var didError = (root.current.flags & DidCapture) === DidCapture;\n                    if (enableProfilerTimer) {\n                        var schedulerPriority;\n                        switch(eventPriority){\n                            case DiscreteEventPriority:\n                                schedulerPriority = ImmediatePriority;\n                                break;\n                            case ContinuousEventPriority:\n                                schedulerPriority = UserBlockingPriority;\n                                break;\n                            case DefaultEventPriority:\n                                schedulerPriority = NormalPriority;\n                                break;\n                            case IdleEventPriority:\n                                schedulerPriority = IdlePriority;\n                                break;\n                            default:\n                                schedulerPriority = NormalPriority;\n                                break;\n                        }\n                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n                    } else {\n                        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);\n                    }\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onPostCommitRoot(root) {\n            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === \"function\") {\n                try {\n                    injectedHook.onPostCommitFiberRoot(rendererID, root);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitUnmount(fiber) {\n            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === \"function\") {\n                try {\n                    injectedHook.onCommitFiberUnmount(rendererID, fiber);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n            {\n                if (typeof unstable_yieldValue === \"function\") {\n                    // We're in a test because Scheduler.unstable_yieldValue only exists\n                    // in SchedulerMock. To reduce the noise in strict mode tests,\n                    // suppress warnings and disable scheduler yielding during the double render\n                    unstable_setDisableYieldValue(newIsStrictMode);\n                    setSuppressWarning(newIsStrictMode);\n                }\n                if (injectedHook && typeof injectedHook.setStrictMode === \"function\") {\n                    try {\n                        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n                    } catch (err) {\n                        {\n                            if (!hasLoggedError) {\n                                hasLoggedError = true;\n                                error(\"React instrumentation encountered an error: %s\", err);\n                            }\n                        }\n                    }\n                }\n            }\n        } // Profiler API hooks\n        function injectProfilingHooks(profilingHooks) {\n            injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n            {\n                var map = new Map();\n                var lane = 1;\n                for(var index = 0; index < TotalLanes; index++){\n                    var label = getLabelForLane(lane);\n                    map.set(lane, label);\n                    lane *= 2;\n                }\n                return map;\n            }\n        }\n        function markCommitStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === \"function\") {\n                    injectedProfilingHooks.markCommitStarted(lanes);\n                }\n            }\n        }\n        function markCommitStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === \"function\") {\n                    injectedProfilingHooks.markCommitStopped();\n                }\n            }\n        }\n        function markComponentRenderStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === \"function\") {\n                    injectedProfilingHooks.markComponentRenderStarted(fiber);\n                }\n            }\n        }\n        function markComponentRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === \"function\") {\n                    injectedProfilingHooks.markComponentRenderStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === \"function\") {\n                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n                }\n            }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === \"function\") {\n                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === \"function\") {\n                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === \"function\") {\n                    injectedProfilingHooks.markLayoutEffectsStopped();\n                }\n            }\n        }\n        function markPassiveEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === \"function\") {\n                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                }\n            }\n        }\n        function markPassiveEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === \"function\") {\n                    injectedProfilingHooks.markPassiveEffectsStopped();\n                }\n            }\n        }\n        function markRenderStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === \"function\") {\n                    injectedProfilingHooks.markRenderStarted(lanes);\n                }\n            }\n        }\n        function markRenderYielded() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === \"function\") {\n                    injectedProfilingHooks.markRenderYielded();\n                }\n            }\n        }\n        function markRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === \"function\") {\n                    injectedProfilingHooks.markRenderStopped();\n                }\n            }\n        }\n        function markRenderScheduled(lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === \"function\") {\n                    injectedProfilingHooks.markRenderScheduled(lane);\n                }\n            }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === \"function\") {\n                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === \"function\") {\n                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var syncQueue = null;\n        var includesLegacySyncCallbacks = false;\n        var isFlushingSyncQueue = false;\n        function scheduleSyncCallback(callback) {\n            // Push this callback into an internal queue. We'll flush these either in\n            // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n            if (syncQueue === null) {\n                syncQueue = [\n                    callback\n                ];\n            } else {\n                // Push onto existing queue. Don't need to schedule a callback because\n                // we already scheduled one when we created the queue.\n                syncQueue.push(callback);\n            }\n        }\n        function scheduleLegacySyncCallback(callback) {\n            includesLegacySyncCallbacks = true;\n            scheduleSyncCallback(callback);\n        }\n        function flushSyncCallbacksOnlyInLegacyMode() {\n            // Only flushes the queue if there's a legacy sync callback scheduled.\n            // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n            // it might make more sense for the queue to be a list of roots instead of a\n            // list of generic callbacks. Then we can have two: one for legacy roots, one\n            // for concurrent roots. And this method would only flush the legacy ones.\n            if (includesLegacySyncCallbacks) {\n                flushSyncCallbacks();\n            }\n        }\n        function flushSyncCallbacks() {\n            if (!isFlushingSyncQueue && syncQueue !== null) {\n                // Prevent re-entrance.\n                isFlushingSyncQueue = true;\n                var i = 0;\n                var previousUpdatePriority = getCurrentUpdatePriority();\n                try {\n                    var isSync = true;\n                    var queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n                    // queue is in the render or commit phases.\n                    setCurrentUpdatePriority(DiscreteEventPriority);\n                    for(; i < queue.length; i++){\n                        var callback = queue[i];\n                        do {\n                            callback = callback(isSync);\n                        }while (callback !== null);\n                    }\n                    syncQueue = null;\n                    includesLegacySyncCallbacks = false;\n                } catch (error) {\n                    // If something throws, leave the remaining callbacks on the queue.\n                    if (syncQueue !== null) {\n                        syncQueue = syncQueue.slice(i + 1);\n                    } // Resume flushing in the next tick\n                    scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n                    throw error;\n                } finally{\n                    setCurrentUpdatePriority(previousUpdatePriority);\n                    isFlushingSyncQueue = false;\n                }\n            }\n            return null;\n        }\n        // This is imported by the event replaying implementation in React DOM. It's\n        // in a separate file to break a circular dependency between the renderer and\n        // the reconciler.\n        function isRootDehydrated(root) {\n            var currentState = root.current.memoizedState;\n            return currentState.isDehydrated;\n        }\n        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\n        var NoTransition = null;\n        function requestCurrentTransition() {\n            return ReactCurrentBatchConfig.transition;\n        }\n        /**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */ function shallowEqual(objA, objB) {\n            if (objectIs(objA, objB)) {\n                return true;\n            }\n            if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n                return false;\n            }\n            var keysA = Object.keys(objA);\n            var keysB = Object.keys(objB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            } // Test for A's keys different from B.\n            for(var i = 0; i < keysA.length; i++){\n                var currentKey = keysA[i];\n                if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function describeFiber(fiber) {\n            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;\n            var source = fiber._debugSource;\n            switch(fiber.tag){\n                case HostComponent:\n                    return describeBuiltInComponentFrame(fiber.type);\n                case LazyComponent:\n                    return describeBuiltInComponentFrame(\"Lazy\");\n                case SuspenseComponent:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case SuspenseListComponent:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n                case FunctionComponent:\n                case IndeterminateComponent:\n                case SimpleMemoComponent:\n                    return describeFunctionComponentFrame(fiber.type);\n                case ForwardRef:\n                    return describeFunctionComponentFrame(fiber.type.render);\n                case ClassComponent:\n                    return describeClassComponentFrame(fiber.type);\n                default:\n                    return \"\";\n            }\n        }\n        function getStackByFiberInDevAndProd(workInProgress) {\n            try {\n                var info = \"\";\n                var node = workInProgress;\n                do {\n                    info += describeFiber(node);\n                    node = node.return;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberOwnerNameInDevOrNull() {\n            {\n                if (current === null) {\n                    return null;\n                }\n                var owner = current._debugOwner;\n                if (owner !== null && typeof owner !== \"undefined\") {\n                    return getComponentNameFromFiber(owner);\n                }\n            }\n            return null;\n        }\n        function getCurrentFiberStackInDev() {\n            {\n                if (current === null) {\n                    return \"\";\n                } // Safe because if current fiber exists, we are reconciling,\n                // and it is guaranteed to be the work-in-progress version.\n                return getStackByFiberInDevAndProd(current);\n            }\n        }\n        function resetCurrentFiber() {\n            {\n                ReactDebugCurrentFrame$1.getCurrentStack = null;\n                current = null;\n                isRendering = false;\n            }\n        }\n        function setCurrentFiber(fiber) {\n            {\n                ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;\n                current = fiber;\n                isRendering = false;\n            }\n        }\n        function setIsRendering(rendering) {\n            {\n                isRendering = rendering;\n            }\n        }\n        var ReactStrictModeWarnings = {\n            recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n            flushPendingUnsafeLifecycleWarnings: function() {},\n            recordLegacyContextWarning: function(fiber, instance) {},\n            flushLegacyContextWarning: function() {},\n            discardPendingWarnings: function() {}\n        };\n        {\n            var findStrictRoot = function(fiber) {\n                var maybeStrictRoot = null;\n                var node = fiber;\n                while(node !== null){\n                    if (node.mode & StrictLegacyMode) {\n                        maybeStrictRoot = node;\n                    }\n                    node = node.return;\n                }\n                return maybeStrictRoot;\n            };\n            var setToSortedString = function(set) {\n                var array = [];\n                set.forEach(function(value) {\n                    array.push(value);\n                });\n                return array.sort().join(\", \");\n            };\n            var pendingComponentWillMountWarnings = [];\n            var pendingUNSAFE_ComponentWillMountWarnings = [];\n            var pendingComponentWillReceivePropsWarnings = [];\n            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            var pendingComponentWillUpdateWarnings = [];\n            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n            var didWarnAboutUnsafeLifecycles = new Set();\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n                // Dedupe strategy: Warn once per component.\n                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n                    return;\n                }\n                if (typeof instance.componentWillMount === \"function\" && // Don't warn about react-lifecycles-compat polyfilled components.\n                instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillMountWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === \"function\") {\n                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillUpdateWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n                // We do an initial pass to gather component names\n                var componentWillMountUniqueNames = new Set();\n                if (pendingComponentWillMountWarnings.length > 0) {\n                    pendingComponentWillMountWarnings.forEach(function(fiber) {\n                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillMountWarnings = [];\n                }\n                var UNSAFE_componentWillMountUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillMountWarnings = [];\n                }\n                var componentWillReceivePropsUniqueNames = new Set();\n                if (pendingComponentWillReceivePropsWarnings.length > 0) {\n                    pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillReceivePropsWarnings = [];\n                }\n                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                }\n                var componentWillUpdateUniqueNames = new Set();\n                if (pendingComponentWillUpdateWarnings.length > 0) {\n                    pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillUpdateWarnings = [];\n                }\n                var UNSAFE_componentWillUpdateUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                } // Finally, we flush all the warnings\n                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n                if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n                    error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\" + \"\\nPlease update the following components: %s\", sortedNames);\n                }\n                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n                    error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended \" + \"and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* If you're updating state whenever props change, \" + \"refactor your code to use memoization techniques or move it to \" + \"static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n\" + \"\\nPlease update the following components: %s\", _sortedNames);\n                }\n                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n                    error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended \" + \"and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames2);\n                }\n                if (componentWillMountUniqueNames.size > 0) {\n                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n                    warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\" + \"* Rename componentWillMount to UNSAFE_componentWillMount to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames3);\n                }\n                if (componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n                    warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* If you're updating state whenever props change, refactor your \" + \"code to use memoization techniques or move it to \" + \"static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n\" + \"* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames4);\n                }\n                if (componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n                    warn(\"componentWillUpdate has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames5);\n                }\n            };\n            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n            var didWarnAboutLegacyContext = new Set();\n            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n                var strictRoot = findStrictRoot(fiber);\n                if (strictRoot === null) {\n                    error(\"Expected to find a StrictMode component in a strict mode tree. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                    return;\n                } // Dedup strategy: Warn once per component.\n                if (didWarnAboutLegacyContext.has(fiber.type)) {\n                    return;\n                }\n                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === \"function\") {\n                    if (warningsForRoot === undefined) {\n                        warningsForRoot = [];\n                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n                    }\n                    warningsForRoot.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n                pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n                    if (fiberArray.length === 0) {\n                        return;\n                    }\n                    var firstFiber = fiberArray[0];\n                    var uniqueNames = new Set();\n                    fiberArray.forEach(function(fiber) {\n                        uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutLegacyContext.add(fiber.type);\n                    });\n                    var sortedNames = setToSortedString(uniqueNames);\n                    try {\n                        setCurrentFiber(firstFiber);\n                        error(\"Legacy context API has been detected within a strict-mode tree.\" + \"\\n\\nThe old API will be supported in all 16.x releases, but applications \" + \"using it should migrate to the new version.\" + \"\\n\\nPlease update the following components: %s\" + \"\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context\", sortedNames);\n                    } finally{\n                        resetCurrentFiber();\n                    }\n                });\n            };\n            ReactStrictModeWarnings.discardPendingWarnings = function() {\n                pendingComponentWillMountWarnings = [];\n                pendingUNSAFE_ComponentWillMountWarnings = [];\n                pendingComponentWillReceivePropsWarnings = [];\n                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                pendingComponentWillUpdateWarnings = [];\n                pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                pendingLegacyContextWarning = new Map();\n            };\n        }\n        /*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                return type;\n            }\n        } // $FlowFixMe only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkPropStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` prop is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        var valueCursor = createCursor(null);\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n            // This is called right before React yields execution, to ensure `readContext`\n            // cannot be called outside the render phase.\n            currentlyRenderingFiber = null;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function enterDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = true;\n            }\n        }\n        function exitDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n            if (isPrimaryRenderer) {\n                push(valueCursor, context._currentValue, providerFiber);\n                context._currentValue = nextValue;\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            } else {\n                push(valueCursor, context._currentValue2, providerFiber);\n                context._currentValue2 = nextValue;\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n        }\n        function popProvider(context, providerFiber) {\n            var currentValue = valueCursor.current;\n            pop(valueCursor, providerFiber);\n            if (isPrimaryRenderer) {\n                {\n                    context._currentValue = currentValue;\n                }\n            } else {\n                {\n                    context._currentValue2 = currentValue;\n                }\n            }\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n            // Update the child lanes of all the ancestors, including the alternates.\n            var node = parent;\n            while(node !== null){\n                var alternate = node.alternate;\n                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n                    node.childLanes = mergeLanes(node.childLanes, renderLanes);\n                    if (alternate !== null) {\n                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                    }\n                } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                }\n                if (node === propagationRoot) {\n                    break;\n                }\n                node = node.return;\n            }\n            {\n                if (node !== propagationRoot) {\n                    error(\"Expected to find the propagation root when scheduling context work. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        function propagateContextChange(workInProgress, context, renderLanes) {\n            {\n                propagateContextChange_eager(workInProgress, context, renderLanes);\n            }\n        }\n        function propagateContextChange_eager(workInProgress, context, renderLanes) {\n            var fiber = workInProgress.child;\n            if (fiber !== null) {\n                // Set the return pointer of the child to the work-in-progress fiber.\n                fiber.return = workInProgress;\n            }\n            while(fiber !== null){\n                var nextFiber = void 0; // Visit this fiber.\n                var list = fiber.dependencies;\n                if (list !== null) {\n                    nextFiber = fiber.child;\n                    var dependency = list.firstContext;\n                    while(dependency !== null){\n                        // Check if the context matches.\n                        if (dependency.context === context) {\n                            // Match! Schedule an update on this fiber.\n                            if (fiber.tag === ClassComponent) {\n                                // Schedule a force update on the work-in-progress.\n                                var lane = pickArbitraryLane(renderLanes);\n                                var update = createUpdate(NoTimestamp, lane);\n                                update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n                                // update to the current fiber, too, which means it will persist even if\n                                // this render is thrown away. Since it's a race condition, not sure it's\n                                // worth fixing.\n                                // Inlined `enqueueUpdate` to remove interleaved update check\n                                var updateQueue = fiber.updateQueue;\n                                if (updateQueue === null) ;\n                                else {\n                                    var sharedQueue = updateQueue.shared;\n                                    var pending = sharedQueue.pending;\n                                    if (pending === null) {\n                                        // This is the first update. Create a circular list.\n                                        update.next = update;\n                                    } else {\n                                        update.next = pending.next;\n                                        pending.next = update;\n                                    }\n                                    sharedQueue.pending = update;\n                                }\n                            }\n                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n                            var alternate = fiber.alternate;\n                            if (alternate !== null) {\n                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n                            }\n                            scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n                            list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n                            break;\n                        }\n                        dependency = dependency.next;\n                    }\n                } else if (fiber.tag === ContextProvider) {\n                    // Don't scan deeper if this is a matching provider\n                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n                } else if (fiber.tag === DehydratedFragment) {\n                    // If a dehydrated suspense boundary is in this subtree, we don't know\n                    // if it will have any context consumers in it. The best we can do is\n                    // mark it as having updates.\n                    var parentSuspense = fiber.return;\n                    if (parentSuspense === null) {\n                        throw new Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                    }\n                    parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n                    var _alternate = parentSuspense.alternate;\n                    if (_alternate !== null) {\n                        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n                    } // This is intentionally passing this fiber as the parent\n                    // because we want to schedule this fiber as having work\n                    // on its children. We'll use the childLanes on\n                    // this fiber to indicate that a context has changed.\n                    scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n                    nextFiber = fiber.sibling;\n                } else {\n                    // Traverse down.\n                    nextFiber = fiber.child;\n                }\n                if (nextFiber !== null) {\n                    // Set the return pointer of the child to the work-in-progress fiber.\n                    nextFiber.return = fiber;\n                } else {\n                    // No child. Traverse to next sibling.\n                    nextFiber = fiber;\n                    while(nextFiber !== null){\n                        if (nextFiber === workInProgress) {\n                            // We're back to the root of this subtree. Exit.\n                            nextFiber = null;\n                            break;\n                        }\n                        var sibling = nextFiber.sibling;\n                        if (sibling !== null) {\n                            // Set the return pointer of the sibling to the work-in-progress fiber.\n                            sibling.return = nextFiber.return;\n                            nextFiber = sibling;\n                            break;\n                        } // No more siblings. Traverse up.\n                        nextFiber = nextFiber.return;\n                    }\n                }\n                fiber = nextFiber;\n            }\n        }\n        function prepareToReadContext(workInProgress, renderLanes) {\n            currentlyRenderingFiber = workInProgress;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            var dependencies = workInProgress.dependencies;\n            if (dependencies !== null) {\n                {\n                    var firstContext = dependencies.firstContext;\n                    if (firstContext !== null) {\n                        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n                            // Context list has a pending update. Mark that this fiber performed work.\n                            markWorkInProgressReceivedUpdate();\n                        } // Reset the work-in-progress list\n                        dependencies.firstContext = null;\n                    }\n                }\n            }\n        }\n        function readContext(context) {\n            {\n                // This warning would fire if you read context inside a Hook like useMemo.\n                // Unlike the class check below, it's not enforced in production for perf.\n                if (isDisallowedContextReadInDEV) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n            if (lastFullyObservedContext === context) ;\n            else {\n                var contextItem = {\n                    context: context,\n                    memoizedValue: value,\n                    next: null\n                };\n                if (lastContextDependency === null) {\n                    if (currentlyRenderingFiber === null) {\n                        throw new Error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                    } // This is the first dependency for this component. Create a new list.\n                    lastContextDependency = contextItem;\n                    currentlyRenderingFiber.dependencies = {\n                        lanes: NoLanes,\n                        firstContext: contextItem\n                    };\n                } else {\n                    // Append a new context item.\n                    lastContextDependency = lastContextDependency.next = contextItem;\n                }\n            }\n            return value;\n        }\n        // An array of all update queues that received updates during the current\n        // render. When this render exits, either because it finishes or because it is\n        // interrupted, the interleaved updates will be transferred onto the main part\n        // of the queue.\n        var interleavedQueues = null;\n        function pushInterleavedQueue(queue) {\n            if (interleavedQueues === null) {\n                interleavedQueues = [\n                    queue\n                ];\n            } else {\n                interleavedQueues.push(queue);\n            }\n        }\n        function enqueueInterleavedUpdates() {\n            // Transfer the interleaved updates onto the main queue. Each queue has a\n            // `pending` field and an `interleaved` field. When they are not null, they\n            // point to the last node in a circular linked list. We need to append the\n            // interleaved list to the end of the pending list by joining them into a\n            // single, circular list.\n            if (interleavedQueues !== null) {\n                for(var i = 0; i < interleavedQueues.length; i++){\n                    var queue = interleavedQueues[i];\n                    var lastInterleavedUpdate = queue.interleaved;\n                    if (lastInterleavedUpdate !== null) {\n                        queue.interleaved = null;\n                        var firstInterleavedUpdate = lastInterleavedUpdate.next;\n                        var lastPendingUpdate = queue.pending;\n                        if (lastPendingUpdate !== null) {\n                            var firstPendingUpdate = lastPendingUpdate.next;\n                            lastPendingUpdate.next = firstInterleavedUpdate;\n                            lastInterleavedUpdate.next = firstPendingUpdate;\n                        }\n                        queue.pending = lastInterleavedUpdate;\n                    }\n                }\n                interleavedQueues = null;\n            }\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n        // It should only be read right after calling `processUpdateQueue`, via\n        // `checkHasForceUpdateAfterProcessing`.\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n            didWarnUpdateInsideUpdate = false;\n            currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n            var queue = {\n                baseState: fiber.memoizedState,\n                firstBaseUpdate: null,\n                lastBaseUpdate: null,\n                shared: {\n                    pending: null,\n                    interleaved: null,\n                    lanes: NoLanes\n                },\n                effects: null\n            };\n            fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current, workInProgress) {\n            // Clone the update queue from current. Unless it's already a clone.\n            var queue = workInProgress.updateQueue;\n            var currentQueue = current.updateQueue;\n            if (queue === currentQueue) {\n                var clone = {\n                    baseState: currentQueue.baseState,\n                    firstBaseUpdate: currentQueue.firstBaseUpdate,\n                    lastBaseUpdate: currentQueue.lastBaseUpdate,\n                    shared: currentQueue.shared,\n                    effects: currentQueue.effects\n                };\n                workInProgress.updateQueue = clone;\n            }\n        }\n        function createUpdate(eventTime, lane) {\n            var update = {\n                eventTime: eventTime,\n                lane: lane,\n                tag: UpdateState,\n                payload: null,\n                callback: null,\n                next: null\n            };\n            return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isInterleavedUpdate(fiber)) {\n                var interleaved = sharedQueue.interleaved;\n                if (interleaved === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update; // At the end of the current render, this queue's interleaved updates will\n                    // be transferred to the pending queue.\n                    pushInterleavedQueue(sharedQueue);\n                } else {\n                    update.next = interleaved.next;\n                    interleaved.next = update;\n                }\n                sharedQueue.interleaved = update;\n            } else {\n                var pending = sharedQueue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                sharedQueue.pending = update;\n            }\n            {\n                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n                    error(\"An update (setState, replaceState, or forceUpdate) was scheduled \" + \"from inside an update function. Update functions should be pure, \" + \"with zero side-effects. Consider using componentDidUpdate or a \" + \"callback.\");\n                    didWarnUpdateInsideUpdate = true;\n                }\n            }\n        }\n        function entangleTransitions(root, fiber, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isTransitionLane(lane)) {\n                var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n                // have finished. We can remove them from the shared queue, which represents\n                // a superset of the actually pending lanes. In some cases we may entangle\n                // more than we need to, but that's OK. In fact it's worse if we *don't*\n                // entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n            // Captured updates are updates that are thrown by a child during the render\n            // phase. They should be discarded if the render is aborted. Therefore,\n            // we should only put them on the work-in-progress queue, not the current one.\n            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n            var current = workInProgress.alternate;\n            if (current !== null) {\n                var currentQueue = current.updateQueue;\n                if (queue === currentQueue) {\n                    // The work-in-progress queue is the same as current. This happens when\n                    // we bail out on a parent fiber that then captures an error thrown by\n                    // a child. Since we want to append the update only to the work-in\n                    // -progress queue, we need to clone the updates. We usually clone during\n                    // processUpdateQueue, but that didn't happen in this case because we\n                    // skipped over the parent when we bailed out.\n                    var newFirst = null;\n                    var newLast = null;\n                    var firstBaseUpdate = queue.firstBaseUpdate;\n                    if (firstBaseUpdate !== null) {\n                        // Loop through the updates and clone them.\n                        var update = firstBaseUpdate;\n                        do {\n                            var clone = {\n                                eventTime: update.eventTime,\n                                lane: update.lane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                callback: update.callback,\n                                next: null\n                            };\n                            if (newLast === null) {\n                                newFirst = newLast = clone;\n                            } else {\n                                newLast.next = clone;\n                                newLast = clone;\n                            }\n                            update = update.next;\n                        }while (update !== null); // Append the captured update the end of the cloned list.\n                        if (newLast === null) {\n                            newFirst = newLast = capturedUpdate;\n                        } else {\n                            newLast.next = capturedUpdate;\n                            newLast = capturedUpdate;\n                        }\n                    } else {\n                        // There are no base updates.\n                        newFirst = newLast = capturedUpdate;\n                    }\n                    queue = {\n                        baseState: currentQueue.baseState,\n                        firstBaseUpdate: newFirst,\n                        lastBaseUpdate: newLast,\n                        shared: currentQueue.shared,\n                        effects: currentQueue.effects\n                    };\n                    workInProgress.updateQueue = queue;\n                    return;\n                }\n            } // Append the update to the end of the list.\n            var lastBaseUpdate = queue.lastBaseUpdate;\n            if (lastBaseUpdate === null) {\n                queue.firstBaseUpdate = capturedUpdate;\n            } else {\n                lastBaseUpdate.next = capturedUpdate;\n            }\n            queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n            switch(update.tag){\n                case ReplaceState:\n                    {\n                        var payload = update.payload;\n                        if (typeof payload === \"function\") {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            var nextState = payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                            return nextState;\n                        } // State object\n                        return payload;\n                    }\n                case CaptureUpdate:\n                    {\n                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n                    }\n                // Intentional fallthrough\n                case UpdateState:\n                    {\n                        var _payload = update.payload;\n                        var partialState;\n                        if (typeof _payload === \"function\") {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            partialState = _payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        _payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                        } else {\n                            // Partial state object\n                            partialState = _payload;\n                        }\n                        if (partialState === null || partialState === undefined) {\n                            // Null and undefined are treated as no-ops.\n                            return prevState;\n                        } // Merge the partial state and the previous state.\n                        return assign({}, prevState, partialState);\n                    }\n                case ForceUpdate:\n                    {\n                        hasForceUpdate = true;\n                        return prevState;\n                    }\n            }\n            return prevState;\n        }\n        function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n            // This is always non-null on a ClassComponent or HostRoot\n            var queue = workInProgress.updateQueue;\n            hasForceUpdate = false;\n            {\n                currentlyProcessingQueue = queue.shared;\n            }\n            var firstBaseUpdate = queue.firstBaseUpdate;\n            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n            var pendingQueue = queue.shared.pending;\n            if (pendingQueue !== null) {\n                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n                // and last so that it's non-circular.\n                var lastPendingUpdate = pendingQueue;\n                var firstPendingUpdate = lastPendingUpdate.next;\n                lastPendingUpdate.next = null; // Append pending updates to base queue\n                if (lastBaseUpdate === null) {\n                    firstBaseUpdate = firstPendingUpdate;\n                } else {\n                    lastBaseUpdate.next = firstPendingUpdate;\n                }\n                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n                // we need to transfer the updates to that queue, too. Because the base\n                // queue is a singly-linked list with no cycles, we can append to both\n                // lists and take advantage of structural sharing.\n                // TODO: Pass `current` as argument\n                var current = workInProgress.alternate;\n                if (current !== null) {\n                    // This is always non-null on a ClassComponent or HostRoot\n                    var currentQueue = current.updateQueue;\n                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n                    if (currentLastBaseUpdate !== lastBaseUpdate) {\n                        if (currentLastBaseUpdate === null) {\n                            currentQueue.firstBaseUpdate = firstPendingUpdate;\n                        } else {\n                            currentLastBaseUpdate.next = firstPendingUpdate;\n                        }\n                        currentQueue.lastBaseUpdate = lastPendingUpdate;\n                    }\n                }\n            } // These values may change as we process the queue.\n            if (firstBaseUpdate !== null) {\n                // Iterate through the list of updates to compute the result.\n                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n                // from the original lanes.\n                var newLanes = NoLanes;\n                var newBaseState = null;\n                var newFirstBaseUpdate = null;\n                var newLastBaseUpdate = null;\n                var update = firstBaseUpdate;\n                do {\n                    var updateLane = update.lane;\n                    var updateEventTime = update.eventTime;\n                    if (!isSubsetOfLanes(renderLanes, updateLane)) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            eventTime: updateEventTime,\n                            lane: updateLane,\n                            tag: update.tag,\n                            payload: update.payload,\n                            callback: update.callback,\n                            next: null\n                        };\n                        if (newLastBaseUpdate === null) {\n                            newFirstBaseUpdate = newLastBaseUpdate = clone;\n                            newBaseState = newState;\n                        } else {\n                            newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                        } // Update the remaining priority in the queue.\n                        newLanes = mergeLanes(newLanes, updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        if (newLastBaseUpdate !== null) {\n                            var _clone = {\n                                eventTime: updateEventTime,\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                callback: update.callback,\n                                next: null\n                            };\n                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                        } // Process this update.\n                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n                        var callback = update.callback;\n                        if (callback !== null && // If the update was already committed, we should not queue its\n                        // callback again.\n                        update.lane !== NoLane) {\n                            workInProgress.flags |= Callback;\n                            var effects = queue.effects;\n                            if (effects === null) {\n                                queue.effects = [\n                                    update\n                                ];\n                            } else {\n                                effects.push(update);\n                            }\n                        }\n                    }\n                    update = update.next;\n                    if (update === null) {\n                        pendingQueue = queue.shared.pending;\n                        if (pendingQueue === null) {\n                            break;\n                        } else {\n                            // An update was scheduled from inside a reducer. Add the new\n                            // pending updates to the end of the list and keep processing.\n                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n                            // unravel them when transferring them to the base queue.\n                            var _firstPendingUpdate = _lastPendingUpdate.next;\n                            _lastPendingUpdate.next = null;\n                            update = _firstPendingUpdate;\n                            queue.lastBaseUpdate = _lastPendingUpdate;\n                            queue.shared.pending = null;\n                        }\n                    }\n                }while (true);\n                if (newLastBaseUpdate === null) {\n                    newBaseState = newState;\n                }\n                queue.baseState = newBaseState;\n                queue.firstBaseUpdate = newFirstBaseUpdate;\n                queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n                // process them during this render, but we do need to track which lanes\n                // are remaining.\n                var lastInterleaved = queue.shared.interleaved;\n                if (lastInterleaved !== null) {\n                    var interleaved = lastInterleaved;\n                    do {\n                        newLanes = mergeLanes(newLanes, interleaved.lane);\n                        interleaved = interleaved.next;\n                    }while (interleaved !== lastInterleaved);\n                } else if (firstBaseUpdate === null) {\n                    // `queue.lanes` is used for entangling transitions. We can set it back to\n                    // zero once the queue is empty.\n                    queue.shared.lanes = NoLanes;\n                } // Set the remaining expiration time to be whatever is remaining in the queue.\n                // This should be fine because the only two other things that contribute to\n                // expiration time are props and context. We're already in the middle of the\n                // begin phase by the time we start processing the queue, so we've already\n                // dealt with the props. Context in components that specify\n                // shouldComponentUpdate is tricky; but we'll have to account for\n                // that regardless.\n                markSkippedUpdateLanes(newLanes);\n                workInProgress.lanes = newLanes;\n                workInProgress.memoizedState = newState;\n            }\n            {\n                currentlyProcessingQueue = null;\n            }\n        }\n        function callCallback(callback, context) {\n            if (typeof callback !== \"function\") {\n                throw new Error(\"Invalid argument passed as callback. Expected a function. Instead \" + (\"received: \" + callback));\n            }\n            callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n            hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n            return hasForceUpdate;\n        }\n        function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n            // Commit the effects\n            var effects = finishedQueue.effects;\n            finishedQueue.effects = null;\n            if (effects !== null) {\n                for(var i = 0; i < effects.length; i++){\n                    var effect = effects[i];\n                    var callback = effect.callback;\n                    if (callback !== null) {\n                        effect.callback = null;\n                        callCallback(callback, instance);\n                    }\n                }\n            }\n        }\n        var fakeInternalInstance = {}; // React.Component uses a shared frozen object by default.\n        // We'll use it to determine whether we need to initialize legacy refs.\n        var emptyRefsObject = new React.Component().refs;\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var warnOnUndefinedDerivedState;\n        var warnOnInvalidCallback;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        {\n            didWarnAboutStateAssignmentForComponent = new Set();\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            var didWarnOnInvalidCallback = new Set();\n            warnOnInvalidCallback = function(callback, callerName) {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            };\n            warnOnUndefinedDerivedState = function(type, partialState) {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }; // This is so gross but it's at least non-critical and can be removed if\n            // it causes problems. This is meant to give a nicer error message for\n            // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n            // ...)) which otherwise throws a \"_processChildContext is not a function\"\n            // exception.\n            Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n                enumerable: false,\n                value: function() {\n                    throw new Error(\"_processChildContext is not available in React 16+. This likely \" + \"means you have multiple copies of React and are attempting to nest \" + \"a React 15 tree inside a React 16 tree using \" + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + \"to make sure you have only one copy of React (and ideally, switch \" + \"to ReactDOM.createPortal).\");\n                }\n            });\n            Object.freeze(fakeInternalInstance);\n        }\n        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n            var prevState = workInProgress.memoizedState;\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        // Invoke the function an extra time to help detect side-effects.\n                        partialState = getDerivedStateFromProps(nextProps, prevState);\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n            // base state.\n            if (workInProgress.lanes === NoLanes) {\n                // Queue is always non-null for classes\n                var updateQueue = workInProgress.updateQueue;\n                updateQueue.baseState = memoizedState;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: isMounted,\n            enqueueSetState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.tag = ReplaceState;\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"replaceState\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueForceUpdate: function(inst, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.tag = ForceUpdate;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"forceUpdate\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        };\n        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n            var instance = workInProgress.stateNode;\n            if (typeof instance.shouldComponentUpdate === \"function\") {\n                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            // Invoke the function an extra time to help detect side-effects.\n                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    if (shouldUpdate === undefined) {\n                        error(\"%s.shouldComponentUpdate(): Returned undefined instead of a \" + \"boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n                    }\n                }\n                return shouldUpdate;\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n            }\n            return true;\n        }\n        function checkClassInstance(workInProgress, ctor, newProps) {\n            var instance = workInProgress.stateNode;\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var _state = instance.state;\n                if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function adoptClassInstance(workInProgress, instance) {\n            instance.updater = classComponentUpdater;\n            workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n            set(instance, workInProgress);\n            {\n                instance._reactInternalInstance = fakeInternalInstance;\n            }\n        }\n        function constructClassInstance(workInProgress, ctor, props) {\n            var isLegacyContextConsumer = false;\n            var unmaskedContext = emptyContextObject;\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext(contextType);\n            } else {\n                unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                var contextTypes = ctor.contextTypes;\n                isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n                context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n            }\n            var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        instance = new ctor(props, context); // eslint-disable-line no-new\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n            }\n            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n            adoptClassInstance(workInProgress, instance);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            // ReactFiberContext usually updates this cache but can't for newly-created instances.\n            if (isLegacyContextConsumer) {\n                cacheContext(workInProgress, unmaskedContext, context);\n            }\n            return instance;\n        }\n        function callComponentWillMount(workInProgress, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillReceiveProps === \"function\") {\n                instance.componentWillReceiveProps(newProps, nextContext);\n            }\n            if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n            }\n            if (instance.state !== oldState) {\n                {\n                    var componentName = getComponentNameFromFiber(workInProgress) || \"Component\";\n                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                        didWarnAboutStateAssignmentForComponent.add(componentName);\n                        error(\"%s.componentWillReceiveProps(): Assigning directly to \" + \"this.state is deprecated (except inside a component's \" + \"constructor). Use setState instead.\", componentName);\n                    }\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            {\n                checkClassInstance(workInProgress, ctor, newProps);\n            }\n            var instance = workInProgress.stateNode;\n            instance.props = newProps;\n            instance.state = workInProgress.memoizedState;\n            instance.refs = emptyRefsObject;\n            initializeUpdateQueue(workInProgress);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                instance.context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n                }\n                {\n                    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n                }\n            }\n            instance.state = workInProgress.memoizedState;\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                instance.state = workInProgress.memoizedState;\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n                instance.state = workInProgress.memoizedState;\n            }\n            if (typeof instance.componentDidMount === \"function\") {\n                var fiberFlags = Update;\n                {\n                    fiberFlags |= LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    fiberFlags |= MountLayoutDev;\n                }\n                workInProgress.flags |= fiberFlags;\n            }\n        }\n        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            var oldProps = workInProgress.memoizedProps;\n            instance.props = oldProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                nextContext = readContext(contextType);\n            } else {\n                var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\"; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n                if (oldProps !== newProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            newState = workInProgress.memoizedState;\n            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === \"function\") {\n                    var fiberFlags = Update;\n                    {\n                        fiberFlags |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        fiberFlags |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= fiberFlags;\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                    if (typeof instance.componentWillMount === \"function\") {\n                        instance.componentWillMount();\n                    }\n                    if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        instance.UNSAFE_componentWillMount();\n                    }\n                }\n                if (typeof instance.componentDidMount === \"function\") {\n                    var _fiberFlags = Update;\n                    {\n                        _fiberFlags |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        _fiberFlags |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= _fiberFlags;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === \"function\") {\n                    var _fiberFlags2 = Update;\n                    {\n                        _fiberFlags2 |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        _fiberFlags2 |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= _fiberFlags2;\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        } // Invokes the update life-cycles and returns false if it shouldn't rerender.\n        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n            instance.props = oldProps;\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                nextContext = readContext(contextType);\n            } else {\n                var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\"; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            newState = workInProgress.memoizedState;\n            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n            // both before and after `shouldComponentUpdate` has been called. Not ideal,\n            // but I'm loath to refactor this function. This only happens for memoized\n            // components so it's not that common.\n            enableLazyContextPropagation;\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === \"function\" || typeof instance.componentWillUpdate === \"function\")) {\n                    if (typeof instance.componentWillUpdate === \"function\") {\n                        instance.componentWillUpdate(newProps, newState, nextContext);\n                    }\n                    if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n                    }\n                }\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    workInProgress.flags |= Update;\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    workInProgress.flags |= Snapshot;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized props/state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        }\n        // TODO: Use the unified fiber stack module instead of this local one?\n        // Intentionally not using it yet to derisk the initial implementation, because\n        // the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n        // rather the ids be wrong than crash the whole reconciler.\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = \"\";\n        function isForkedChild(workInProgress) {\n            warnIfNotHydrating();\n            return (workInProgress.flags & Forked) !== NoFlags;\n        }\n        function getForksAtLevel(workInProgress) {\n            warnIfNotHydrating();\n            return treeForkCount;\n        }\n        function getTreeId() {\n            var overflow = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress, totalChildren) {\n            // This is called right after we reconcile an array (or iterator) of child\n            // fibers, because that's the only place where we know how many children in\n            // the whole set without doing extra work later, or storing addtional\n            // information on the fiber.\n            //\n            // That's why this function is separate from pushTreeId — it's called during\n            // the render phase of the fork parent, not the child, which is where we push\n            // the other context values.\n            //\n            // In the Fizz implementation this is much simpler because the child is\n            // rendered in the same callstack as the parent.\n            //\n            // It might be better to just add a `forks` field to the Fiber type. It would\n            // make this module simpler.\n            warnIfNotHydrating();\n            forkStack[forkStackIndex++] = treeForkCount;\n            forkStack[forkStackIndex++] = treeForkProvider;\n            treeForkProvider = workInProgress;\n            treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress, totalChildren, index) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextProvider = workInProgress;\n            var baseIdWithLeadingBit = treeContextId;\n            var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                treeContextId = 1 << restOfLength | id;\n                treeContextOverflow = overflow;\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                treeContextId = 1 << length | _id;\n                treeContextOverflow = _overflow;\n            }\n        }\n        function pushMaterializedTreeId(workInProgress) {\n            warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n            // in its children.\n            var returnFiber = workInProgress.return;\n            if (returnFiber !== null) {\n                var numberOfForks = 1;\n                var slotIndex = 0;\n                pushTreeFork(workInProgress, numberOfForks);\n                pushTreeId(workInProgress, numberOfForks, slotIndex);\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress) {\n            // Restore the previous values.\n            // This is a bit more complicated than other context-like modules in Fiber\n            // because the same Fiber may appear on the stack multiple times and for\n            // different reasons. We have to keep popping until the work-in-progress is\n            // no longer at the top of the stack.\n            while(workInProgress === treeForkProvider){\n                treeForkProvider = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n                treeForkCount = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n            }\n            while(workInProgress === treeContextProvider){\n                treeContextProvider = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextOverflow = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextId = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n            }\n        }\n        function getSuspendedTreeContext() {\n            warnIfNotHydrating();\n            if (treeContextProvider !== null) {\n                return {\n                    id: treeContextId,\n                    overflow: treeContextOverflow\n                };\n            } else {\n                return null;\n            }\n        }\n        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextId = suspendedContext.id;\n            treeContextOverflow = suspendedContext.overflow;\n            treeContextProvider = workInProgress;\n        }\n        function warnIfNotHydrating() {\n            {\n                if (!getIsHydrating()) {\n                    error(\"Expected to be hydrating. This is a bug in React. Please file \" + \"an issue.\");\n                }\n            }\n        }\n        // This may have been an insertion or a hydration.\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false;\n        var didSuspend = false; // Hydration errors that were thrown inside this boundary\n        var hydrationErrors = null;\n        function warnIfHydrating() {\n            {\n                if (isHydrating) {\n                    error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\");\n                }\n            }\n        }\n        function markDidSuspendWhileHydratingDEV() {\n            {\n                didSuspend = true;\n            }\n        }\n        function enterHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            var parentInstance = fiber.stateNode.containerInfo;\n            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspend = false;\n            return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n            if (!supportsHydration) {\n                return false;\n            }\n            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspend = false;\n            if (treeContext !== null) {\n                restoreSuspendedTreeContext(fiber, treeContext);\n            }\n            return true;\n        }\n        function warnUnhydratedInstance(returnFiber, instance) {\n            {\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n                        break;\n                    case HostComponent:\n                        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n                        break;\n                    case SuspenseComponent:\n                        var suspenseState = returnFiber.memoizedState;\n                        if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n                        break;\n                }\n            }\n        }\n        function deleteHydratableInstance(returnFiber, instance) {\n            warnUnhydratedInstance(returnFiber, instance);\n            var childToDelete = createFiberFromHostInstanceForDeletion();\n            childToDelete.stateNode = instance;\n            childToDelete.return = returnFiber;\n            var deletions = returnFiber.deletions;\n            if (deletions === null) {\n                returnFiber.deletions = [\n                    childToDelete\n                ];\n                returnFiber.flags |= ChildDeletion;\n            } else {\n                deletions.push(childToDelete);\n            }\n        }\n        function warnNonhydratedInstance(returnFiber, fiber) {\n            {\n                if (didSuspend) {\n                    // Inside a boundary that already suspended. We're currently rendering the\n                    // siblings of a suspended node. The mismatch may be due to the missing\n                    // data, so it's probably a false positive.\n                    return;\n                }\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        {\n                            var parentContainer = returnFiber.stateNode.containerInfo;\n                            switch(fiber.tag){\n                                case HostComponent:\n                                    var type = fiber.type;\n                                    var props = fiber.pendingProps;\n                                    didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n                                    break;\n                                case HostText:\n                                    var text = fiber.pendingProps;\n                                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n                                    break;\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            var parentType = returnFiber.type;\n                            var parentProps = returnFiber.memoizedProps;\n                            var parentInstance = returnFiber.stateNode;\n                            switch(fiber.tag){\n                                case HostComponent:\n                                    var _type = fiber.type;\n                                    var _props = fiber.pendingProps;\n                                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                                    break;\n                                case HostText:\n                                    var _text = fiber.pendingProps;\n                                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n                                    break;\n                            }\n                            break;\n                        }\n                    case SuspenseComponent:\n                        {\n                            var suspenseState = returnFiber.memoizedState;\n                            var _parentInstance = suspenseState.dehydrated;\n                            if (_parentInstance !== null) switch(fiber.tag){\n                                case HostComponent:\n                                    var _type2 = fiber.type;\n                                    var _props2 = fiber.pendingProps;\n                                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);\n                                    break;\n                                case HostText:\n                                    var _text2 = fiber.pendingProps;\n                                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);\n                                    break;\n                            }\n                            break;\n                        }\n                    default:\n                        return;\n                }\n            }\n        }\n        function insertNonHydratedInstance(returnFiber, fiber) {\n            fiber.flags = fiber.flags & ~Hydrating | Placement;\n            warnNonhydratedInstance(returnFiber, fiber);\n        }\n        function tryHydrate(fiber, nextInstance) {\n            switch(fiber.tag){\n                case HostComponent:\n                    {\n                        var type = fiber.type;\n                        var props = fiber.pendingProps;\n                        var instance = canHydrateInstance(nextInstance, type, props);\n                        if (instance !== null) {\n                            fiber.stateNode = instance;\n                            hydrationParentFiber = fiber;\n                            nextHydratableInstance = getFirstHydratableChild(instance);\n                            return true;\n                        }\n                        return false;\n                    }\n                case HostText:\n                    {\n                        var text = fiber.pendingProps;\n                        var textInstance = canHydrateTextInstance(nextInstance, text);\n                        if (textInstance !== null) {\n                            fiber.stateNode = textInstance;\n                            hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n                            nextHydratableInstance = null;\n                            return true;\n                        }\n                        return false;\n                    }\n                case SuspenseComponent:\n                    {\n                        {\n                            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n                            if (suspenseInstance !== null) {\n                                var suspenseState = {\n                                    dehydrated: suspenseInstance,\n                                    treeContext: getSuspendedTreeContext(),\n                                    retryLane: OffscreenLane\n                                };\n                                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n                                // This simplifies the code for getHostSibling and deleting nodes,\n                                // since it doesn't have to consider all Suspense boundaries and\n                                // check if they're dehydrated ones or not.\n                                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                                dehydratedFragment.return = fiber;\n                                fiber.child = dehydratedFragment;\n                                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n                                // it during the first pass. Instead, we'll reenter it later.\n                                nextHydratableInstance = null;\n                                return true;\n                            }\n                        }\n                        return false;\n                    }\n                default:\n                    return false;\n            }\n        }\n        function shouldClientRenderOnMismatch(fiber) {\n            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n        }\n        function throwOnHydrationMismatch(fiber) {\n            throw new Error(\"Hydration failed because the initial UI does not match what was \" + \"rendered on the server.\");\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance) {\n                if (shouldClientRenderOnMismatch(fiber)) {\n                    warnNonhydratedInstance(hydrationParentFiber, fiber);\n                    throwOnHydrationMismatch();\n                } // Nothing to hydrate. Make it an insertion.\n                insertNonHydratedInstance(hydrationParentFiber, fiber);\n                isHydrating = false;\n                hydrationParentFiber = fiber;\n                return;\n            }\n            var firstAttemptedInstance = nextInstance;\n            if (!tryHydrate(fiber, nextInstance)) {\n                if (shouldClientRenderOnMismatch(fiber)) {\n                    warnNonhydratedInstance(hydrationParentFiber, fiber);\n                    throwOnHydrationMismatch();\n                } // If we can't hydrate this instance let's try the next one.\n                // We use this as a heuristic. It's based on intuition and not data so it\n                // might be flawed or unnecessary.\n                nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n                var prevHydrationParentFiber = hydrationParentFiber;\n                if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n                    // Nothing to hydrate. Make it an insertion.\n                    insertNonHydratedInstance(hydrationParentFiber, fiber);\n                    isHydrating = false;\n                    hydrationParentFiber = fiber;\n                    return;\n                } // We matched the next one, we'll now assume that the first one was\n                // superfluous and we'll delete it. Since we can't eagerly delete it\n                // we'll have to schedule a deletion. To do that, this node needs a dummy\n                // fiber associated with it.\n                deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n            }\n        }\n        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var instance = fiber.stateNode;\n            var shouldWarnIfMismatchDev = !didSuspend;\n            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n            fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n            // is a new ref we mark this as an update.\n            if (updatePayload !== null) {\n                return true;\n            }\n            return false;\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostTextInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var textInstance = fiber.stateNode;\n            var textContent = fiber.memoizedProps;\n            var shouldWarnIfMismatchDev = !didSuspend;\n            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n            if (shouldUpdate) {\n                // We assume that prepareToHydrateHostTextInstance is called in a context where the\n                // hydration parent is the parent host component of this host text.\n                var returnFiber = hydrationParentFiber;\n                if (returnFiber !== null) {\n                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                    switch(returnFiber.tag){\n                        case HostRoot:\n                            {\n                                var parentContainer = returnFiber.stateNode.containerInfo;\n                                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode);\n                                break;\n                            }\n                        case HostComponent:\n                            {\n                                var parentType = returnFiber.type;\n                                var parentProps = returnFiber.memoizedProps;\n                                var parentInstance = returnFiber.stateNode;\n                                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, isConcurrentMode);\n                                break;\n                            }\n                    }\n                }\n            }\n            return shouldUpdate;\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error(\"Expected to have a hydrated suspense instance. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error(\"Expected to have a hydrated suspense instance. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n            var parent = fiber.return;\n            while(parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent){\n                parent = parent.return;\n            }\n            hydrationParentFiber = parent;\n        }\n        function popHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            if (fiber !== hydrationParentFiber) {\n                // We're deeper than the current hydration context, inside an inserted\n                // tree.\n                return false;\n            }\n            if (!isHydrating) {\n                // If we're not currently hydrating but we're in a hydration context, then\n                // we were an insertion and now need to pop up reenter hydration of our\n                // siblings.\n                popToNextHostParent(fiber);\n                isHydrating = true;\n                return false;\n            } // If we have any remaining hydratable nodes, we need to delete them now.\n            // We only do this deeper than head and body since they tend to have random\n            // other nodes in them. We also ignore components with pure text content in\n            // side of them. We also don't delete anything inside the root container.\n            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n                var nextInstance = nextHydratableInstance;\n                if (nextInstance) {\n                    if (shouldClientRenderOnMismatch(fiber)) {\n                        warnIfUnhydratedTailNodes(fiber);\n                        throwOnHydrationMismatch();\n                    } else {\n                        while(nextInstance){\n                            deleteHydratableInstance(fiber, nextInstance);\n                            nextInstance = getNextHydratableSibling(nextInstance);\n                        }\n                    }\n                }\n            }\n            popToNextHostParent(fiber);\n            if (fiber.tag === SuspenseComponent) {\n                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n            } else {\n                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n            }\n            return true;\n        }\n        function hasUnhydratedTailNodes() {\n            return isHydrating && nextHydratableInstance !== null;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n            var nextInstance = nextHydratableInstance;\n            while(nextInstance){\n                warnUnhydratedInstance(fiber, nextInstance);\n                nextInstance = getNextHydratableSibling(nextInstance);\n            }\n        }\n        function resetHydrationState() {\n            if (!supportsHydration) {\n                return;\n            }\n            hydrationParentFiber = null;\n            nextHydratableInstance = null;\n            isHydrating = false;\n            didSuspend = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n            if (hydrationErrors !== null) {\n                // Successfully completed a forced client render. The errors that occurred\n                // during the hydration attempt are now recovered. We will log them in\n                // commit phase, once the entire tree has finished.\n                queueRecoverableErrors(hydrationErrors);\n                hydrationErrors = null;\n            }\n        }\n        function getIsHydrating() {\n            return isHydrating;\n        }\n        function queueHydrationError(error) {\n            if (hydrationErrors === null) {\n                hydrationErrors = [\n                    error\n                ];\n            } else {\n                hydrationErrors.push(error);\n            }\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var didWarnAboutStringRefs;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {};\n        {\n            didWarnAboutMaps = false;\n            didWarnAboutGenerators = false;\n            didWarnAboutStringRefs = {};\n            /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ ownerHasKeyUseWarning = {};\n            ownerHasFunctionTypeWarning = {};\n            warnForMissingKey = function(child, returnFiber) {\n                if (child === null || typeof child !== \"object\") {\n                    return;\n                }\n                if (!child._store || child._store.validated || child.key != null) {\n                    return;\n                }\n                if (typeof child._store !== \"object\") {\n                    throw new Error(\"React Component in warnForMissingKey should have a _store. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                child._store.validated = true;\n                var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                if (ownerHasKeyUseWarning[componentName]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[componentName] = true;\n                error(\"Each child in a list should have a unique \" + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + \"more information.\");\n            };\n        }\n        function coerceRef(returnFiber, current, element) {\n            var mixedRef = element.ref;\n            if (mixedRef !== null && typeof mixedRef !== \"function\" && typeof mixedRef !== \"object\") {\n                {\n                    // TODO: Clean this up once we turn on the string ref warning for\n                    // everyone, because the strict mode case will no longer be relevant\n                    if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n                    // because these cannot be automatically converted to an arrow function\n                    // using a codemod. Therefore, we don't have to warn about string refs again.\n                    !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n                        var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                        if (!didWarnAboutStringRefs[componentName]) {\n                            {\n                                error('A string ref, \"%s\", has been found within a strict mode tree. ' + \"String refs are a source of potential bugs and should be avoided. \" + \"We recommend using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", mixedRef);\n                            }\n                            didWarnAboutStringRefs[componentName] = true;\n                        }\n                    }\n                }\n                if (element._owner) {\n                    var owner = element._owner;\n                    var inst;\n                    if (owner) {\n                        var ownerFiber = owner;\n                        if (ownerFiber.tag !== ClassComponent) {\n                            throw new Error(\"Function components cannot have string refs. \" + \"We recommend using useRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\");\n                        }\n                        inst = ownerFiber.stateNode;\n                    }\n                    if (!inst) {\n                        throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n                    } // Assigning this to a const so Flow knows it won't change in the closure\n                    var resolvedInst = inst;\n                    {\n                        checkPropStringCoercion(mixedRef, \"ref\");\n                    }\n                    var stringRef = \"\" + mixedRef; // Check if previous string ref matches new string ref\n                    if (current !== null && current.ref !== null && typeof current.ref === \"function\" && current.ref._stringRef === stringRef) {\n                        return current.ref;\n                    }\n                    var ref = function(value) {\n                        var refs = resolvedInst.refs;\n                        if (refs === emptyRefsObject) {\n                            // This is a lazy pooled frozen object, so we need to initialize.\n                            refs = resolvedInst.refs = {};\n                        }\n                        if (value === null) {\n                            delete refs[stringRef];\n                        } else {\n                            refs[stringRef] = value;\n                        }\n                    };\n                    ref._stringRef = stringRef;\n                    return ref;\n                } else {\n                    if (typeof mixedRef !== \"string\") {\n                        throw new Error(\"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\");\n                    }\n                    if (!element._owner) {\n                        throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of\" + \" the following reasons:\\n\" + \"1. You may be adding a ref to a function component\\n\" + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + \"3. You have multiple copies of React loaded\\n\" + \"See https://reactjs.org/link/refs-must-have-owner for more information.\");\n                    }\n                }\n            }\n            return mixedRef;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n            var childString = Object.prototype.toString.call(newChild);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n        }\n        function warnOnFunctionType(returnFiber) {\n            {\n                var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                if (ownerHasFunctionTypeWarning[componentName]) {\n                    return;\n                }\n                ownerHasFunctionTypeWarning[componentName] = true;\n                error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n            }\n        }\n        function resolveLazy(lazyType) {\n            var payload = lazyType._payload;\n            var init = lazyType._init;\n            return init(payload);\n        } // This wrapper function exists because I expect to clone the code in each path\n        // to be able to optimize each path individually by branching early. This needs\n        // a compiler or we can do it manually. Helpers that don't need this branching\n        // live outside of this function.\n        function ChildReconciler(shouldTrackSideEffects) {\n            function deleteChild(returnFiber, childToDelete) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return;\n                }\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        childToDelete\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(childToDelete);\n                }\n            }\n            function deleteRemainingChildren(returnFiber, currentFirstChild) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return null;\n                } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n                // assuming that after the first child we've already added everything.\n                var childToDelete = currentFirstChild;\n                while(childToDelete !== null){\n                    deleteChild(returnFiber, childToDelete);\n                    childToDelete = childToDelete.sibling;\n                }\n                return null;\n            }\n            function mapRemainingChildren(returnFiber, currentFirstChild) {\n                // Add the remaining children to a temporary map so that we can find them by\n                // keys quickly. Implicit (null) keys get added to this set with their index\n                // instead.\n                var existingChildren = new Map();\n                var existingChild = currentFirstChild;\n                while(existingChild !== null){\n                    if (existingChild.key !== null) {\n                        existingChildren.set(existingChild.key, existingChild);\n                    } else {\n                        existingChildren.set(existingChild.index, existingChild);\n                    }\n                    existingChild = existingChild.sibling;\n                }\n                return existingChildren;\n            }\n            function useFiber(fiber, pendingProps) {\n                // We currently set sibling to null and index to 0 here because it is easy\n                // to forget to do before returning it. E.g. for the single child case.\n                var clone = createWorkInProgress(fiber, pendingProps);\n                clone.index = 0;\n                clone.sibling = null;\n                return clone;\n            }\n            function placeChild(newFiber, lastPlacedIndex, newIndex) {\n                newFiber.index = newIndex;\n                if (!shouldTrackSideEffects) {\n                    // During hydration, the useId algorithm needs to know which fibers are\n                    // part of a list of children (arrays, iterators).\n                    newFiber.flags |= Forked;\n                    return lastPlacedIndex;\n                }\n                var current = newFiber.alternate;\n                if (current !== null) {\n                    var oldIndex = current.index;\n                    if (oldIndex < lastPlacedIndex) {\n                        // This is a move.\n                        newFiber.flags |= Placement;\n                        return lastPlacedIndex;\n                    } else {\n                        // This item can stay in place.\n                        return oldIndex;\n                    }\n                } else {\n                    // This is an insertion.\n                    newFiber.flags |= Placement;\n                    return lastPlacedIndex;\n                }\n            }\n            function placeSingleChild(newFiber) {\n                // This is simpler for the single child case. We only need to do a\n                // placement for inserting new children.\n                if (shouldTrackSideEffects && newFiber.alternate === null) {\n                    newFiber.flags |= Placement;\n                }\n                return newFiber;\n            }\n            function updateTextNode(returnFiber, current, textContent, lanes) {\n                if (current === null || current.tag !== HostText) {\n                    // Insert\n                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function updateElement(returnFiber, current, element, lanes) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                    return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n                }\n                if (current !== null) {\n                    if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.\n                    // We need to do this after the Hot Reloading check above,\n                    // because hot reloading has different semantics than prod because\n                    // it doesn't resuspend. So we can't let the call below suspend.\n                    typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n                        // Move based on index\n                        var existing = useFiber(current, element.props);\n                        existing.ref = coerceRef(returnFiber, current, element);\n                        existing.return = returnFiber;\n                        {\n                            existing._debugSource = element._source;\n                            existing._debugOwner = element._owner;\n                        }\n                        return existing;\n                    }\n                } // Insert\n                var created = createFiberFromElement(element, returnFiber.mode, lanes);\n                created.ref = coerceRef(returnFiber, current, element);\n                created.return = returnFiber;\n                return created;\n            }\n            function updatePortal(returnFiber, current, portal, lanes) {\n                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n                    // Insert\n                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, portal.children || []);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function updateFragment(returnFiber, current, fragment, lanes, key) {\n                if (current === null || current.tag !== Fragment) {\n                    // Insert\n                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, fragment);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function createChild(returnFiber, newChild, lanes) {\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    var created = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                                _created.ref = coerceRef(returnFiber, null, newChild);\n                                _created.return = returnFiber;\n                                return _created;\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                                _created2.return = returnFiber;\n                                return _created2;\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                {\n                                    var payload = newChild._payload;\n                                    var init = newChild._init;\n                                    return createChild(returnFiber, init(payload), lanes);\n                                }\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                        _created3.return = returnFiber;\n                        return _created3;\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n                // Update the fiber if the keys match, otherwise return null.\n                var key = oldFiber !== null ? oldFiber.key : null;\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    if (key !== null) {\n                        return null;\n                    }\n                    return updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updateElement(returnFiber, oldFiber, newChild, lanes);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updatePortal(returnFiber, oldFiber, newChild, lanes);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                {\n                                    var payload = newChild._payload;\n                                    var init = newChild._init;\n                                    return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n                                }\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        if (key !== null) {\n                            return null;\n                        }\n                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys, so we neither have to check the old nor\n                    // new node for the key. If both are text nodes, they match.\n                    var matchedFiber = existingChildren.get(newIdx) || null;\n                    return updateTextNode(returnFiber, matchedFiber, \"\" + newChild, lanes);\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            /**\n   * Warns if there is a duplicate or missing key\n   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {\n                {\n                    if (typeof child !== \"object\" || child === null) {\n                        return knownKeys;\n                    }\n                    switch(child.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                        case REACT_PORTAL_TYPE:\n                            warnForMissingKey(child, returnFiber);\n                            var key = child.key;\n                            if (typeof key !== \"string\") {\n                                break;\n                            }\n                            if (knownKeys === null) {\n                                knownKeys = new Set();\n                                knownKeys.add(key);\n                                break;\n                            }\n                            if (!knownKeys.has(key)) {\n                                knownKeys.add(key);\n                                break;\n                            }\n                            error(\"Encountered two children with the same key, `%s`. \" + \"Keys should be unique so that components maintain their identity \" + \"across updates. Non-unique keys may cause children to be \" + \"duplicated and/or omitted — the behavior is unsupported and \" + \"could change in a future version.\", key);\n                            break;\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = child._payload;\n                                var init = child._init;\n                                warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                                break;\n                            }\n                    }\n                }\n                return knownKeys;\n            }\n            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n                // This algorithm can't optimize by searching from both ends since we\n                // don't have backpointers on fibers. I'm trying to see how far we can get\n                // with that model. If it ends up not being worth the tradeoffs, we can\n                // add it later.\n                // Even with a two ended optimization, we'd want to optimize for the case\n                // where there are few changes and brute force the comparison instead of\n                // going for the Map. It'd like to explore hitting that path first in\n                // forward-only mode and only go for the Map once we notice that we need\n                // lots of look ahead. This doesn't handle reversal as well as two ended\n                // search but that's unusual. Besides, for the two ended optimization to\n                // work on Iterables, we'd need to copy the whole set.\n                // In this first iteration, we'll just live with hitting the bad case\n                // (adding everything to a Map) in for every insert/move.\n                // If you change this code, also update reconcileChildrenIterator() which\n                // uses the same algorithm.\n                {\n                    // First, validate keys.\n                    var knownKeys = null;\n                    for(var i = 0; i < newChildren.length; i++){\n                        var child = newChildren[i];\n                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                    }\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (newIdx === newChildren.length) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; newIdx < newChildren.length; newIdx++){\n                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n                        if (_newFiber === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber;\n                        } else {\n                            previousNewFiber.sibling = _newFiber;\n                        }\n                        previousNewFiber = _newFiber;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; newIdx < newChildren.length; newIdx++){\n                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n                    if (_newFiber2 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber2.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber2;\n                        } else {\n                            previousNewFiber.sibling = _newFiber2;\n                        }\n                        previousNewFiber = _newFiber2;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks2 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks2);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n                // This is the same implementation as reconcileChildrenArray(),\n                // but using the iterator instead.\n                var iteratorFn = getIteratorFn(newChildrenIterable);\n                if (typeof iteratorFn !== \"function\") {\n                    throw new Error(\"An object is not an iterable. This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n                }\n                {\n                    // We don't support rendering Generators because it's a mutation.\n                    // See https://github.com/facebook/react/issues/12995\n                    if (typeof Symbol === \"function\" && // $FlowFixMe Flow doesn't know about toStringTag\n                    newChildrenIterable[Symbol.toStringTag] === \"Generator\") {\n                        if (!didWarnAboutGenerators) {\n                            error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                        }\n                        didWarnAboutGenerators = true;\n                    } // Warn about using Maps as children\n                    if (newChildrenIterable.entries === iteratorFn) {\n                        if (!didWarnAboutMaps) {\n                            error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                        }\n                        didWarnAboutMaps = true;\n                    } // First, validate keys.\n                    // We'll get a different iterator later for the main pass.\n                    var _newChildren = iteratorFn.call(newChildrenIterable);\n                    if (_newChildren) {\n                        var knownKeys = null;\n                        var _step = _newChildren.next();\n                        for(; !_step.done; _step = _newChildren.next()){\n                            var child = _step.value;\n                            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                        }\n                    }\n                }\n                var newChildren = iteratorFn.call(newChildrenIterable);\n                if (newChildren == null) {\n                    throw new Error(\"An iterable object provided no iterator.\");\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                var step = newChildren.next();\n                for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (step.done) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; !step.done; newIdx++, step = newChildren.next()){\n                        var _newFiber3 = createChild(returnFiber, step.value, lanes);\n                        if (_newFiber3 === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber3;\n                        } else {\n                            previousNewFiber.sibling = _newFiber3;\n                        }\n                        previousNewFiber = _newFiber3;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks3 = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks3);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; !step.done; newIdx++, step = newChildren.next()){\n                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n                    if (_newFiber4 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber4.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber4;\n                        } else {\n                            previousNewFiber.sibling = _newFiber4;\n                        }\n                        previousNewFiber = _newFiber4;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks4 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks4);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n                // There's no need to check for keys on text nodes since we don't have a\n                // way to define them.\n                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n                    // We already have an existing node so let's just update it and delete\n                    // the rest.\n                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                    var existing = useFiber(currentFirstChild, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                } // The existing first child is not a text node so we need to create one\n                // and delete the existing ones.\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            }\n            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n                var key = element.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        var elementType = element.type;\n                        if (elementType === REACT_FRAGMENT_TYPE) {\n                            if (child.tag === Fragment) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var existing = useFiber(child, element.props.children);\n                                existing.return = returnFiber;\n                                {\n                                    existing._debugSource = element._source;\n                                    existing._debugOwner = element._owner;\n                                }\n                                return existing;\n                            }\n                        } else {\n                            if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                            // We need to do this after the Hot Reloading check above,\n                            // because hot reloading has different semantics than prod because\n                            // it doesn't resuspend. So we can't let the call below suspend.\n                            typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var _existing = useFiber(child, element.props);\n                                _existing.ref = coerceRef(returnFiber, child, element);\n                                _existing.return = returnFiber;\n                                {\n                                    _existing._debugSource = element._source;\n                                    _existing._debugOwner = element._owner;\n                                }\n                                return _existing;\n                            }\n                        } // Didn't match.\n                        deleteRemainingChildren(returnFiber, child);\n                        break;\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                if (element.type === REACT_FRAGMENT_TYPE) {\n                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n                    _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n                    _created4.return = returnFiber;\n                    return _created4;\n                }\n            }\n            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n                var key = portal.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                            deleteRemainingChildren(returnFiber, child.sibling);\n                            var existing = useFiber(child, portal.children || []);\n                            existing.return = returnFiber;\n                            return existing;\n                        } else {\n                            deleteRemainingChildren(returnFiber, child);\n                            break;\n                        }\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            } // This API will tag the children with the side-effect of the reconciliation\n            // itself. They will be added to the side-effect list as we pass through the\n            // children and the parent.\n            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n                // This function is not recursive.\n                // If the top level item is an array, we treat it as a set of children,\n                // not as a fragment. Nested arrays on the other hand will be treated as\n                // fragment nodes. Recursion happens at the normal flow.\n                // Handle top level unkeyed fragments as if they were arrays.\n                // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n                // We treat the ambiguous cases above the same.\n                var isUnkeyedTopLevelFragment = typeof newChild === \"object\" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n                if (isUnkeyedTopLevelFragment) {\n                    newChild = newChild.props.children;\n                } // Handle object types\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_PORTAL_TYPE:\n                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n                                return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n                            }\n                    }\n                    if (isArray(newChild)) {\n                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n                    }\n                    if (getIteratorFn(newChild)) {\n                        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, \"\" + newChild, lanes));\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return deleteRemainingChildren(returnFiber, currentFirstChild);\n            }\n            return reconcileChildFibers;\n        }\n        var reconcileChildFibers = ChildReconciler(true);\n        var mountChildFibers = ChildReconciler(false);\n        function cloneChildFibers(current, workInProgress) {\n            if (current !== null && workInProgress.child !== current.child) {\n                throw new Error(\"Resuming work not yet implemented.\");\n            }\n            if (workInProgress.child === null) {\n                return;\n            }\n            var currentChild = workInProgress.child;\n            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n            workInProgress.child = newChild;\n            newChild.return = workInProgress;\n            while(currentChild.sibling !== null){\n                currentChild = currentChild.sibling;\n                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n                newChild.return = workInProgress;\n            }\n            newChild.sibling = null;\n        } // Reset a workInProgress child set to prepare it for a second pass.\n        function resetChildFibers(workInProgress, lanes) {\n            var child = workInProgress.child;\n            while(child !== null){\n                resetWorkInProgress(child, lanes);\n                child = child.sibling;\n            }\n        }\n        var NO_CONTEXT = {};\n        var contextStackCursor$1 = createCursor(NO_CONTEXT);\n        var contextFiberStackCursor = createCursor(NO_CONTEXT);\n        var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n        function requiredContext(c) {\n            if (c === NO_CONTEXT) {\n                throw new Error(\"Expected host context to exist. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n            }\n            return c;\n        }\n        function getRootHostContainer() {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n            // Push current root instance onto the stack;\n            // This allows us to reset root when portals are popped.\n            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n            // However, we can't just call getRootHostContext() and push it because\n            // we'd have a different number of entries on the stack depending on\n            // whether getRootHostContext() throws somewhere in renderer code or not.\n            // So we push an empty value first. This lets us safely unwind on errors.\n            push(contextStackCursor$1, NO_CONTEXT, fiber);\n            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n            pop(contextStackCursor$1, fiber);\n            push(contextStackCursor$1, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n            pop(contextStackCursor$1, fiber);\n            pop(contextFiberStackCursor, fiber);\n            pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n            var context = requiredContext(contextStackCursor$1.current);\n            return context;\n        }\n        function pushHostContext(fiber) {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            var context = requiredContext(contextStackCursor$1.current);\n            var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n            if (context === nextContext) {\n                return;\n            } // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber);\n            push(contextStackCursor$1, nextContext, fiber);\n        }\n        function popHostContext(fiber) {\n            // Do not pop unless this Fiber provided the current context.\n            // pushHostContext() only pushes Fibers that provide unique contexts.\n            if (contextFiberStackCursor.current !== fiber) {\n                return;\n            }\n            pop(contextStackCursor$1, fiber);\n            pop(contextFiberStackCursor, fiber);\n        }\n        var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is\n        // inherited deeply down the subtree. The upper bits only affect\n        // this immediate suspense boundary and gets reset each new\n        // boundary or suspense list.\n        var SubtreeSuspenseContextMask = 1; // Subtree Flags:\n        // InvisibleParentSuspenseContext indicates that one of our parent Suspense\n        // boundaries is not currently showing visible main content.\n        // Either because it is already showing a fallback or is not mounted at all.\n        // We can use this to determine if it is desirable to trigger a fallback at\n        // the parent. If not, then we might need to trigger undesirable boundaries\n        // and/or suspend the commit to avoid hiding the parent content.\n        var InvisibleParentSuspenseContext = 1; // Shallow Flags:\n        // ForceSuspenseFallback can be used by SuspenseList to force newly added\n        // items into their fallback state during one of the render passes.\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseContext(parentContext, flag) {\n            return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseContext(parentContext) {\n            return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseContext(parentContext, shallowContext) {\n            return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function addSubtreeSuspenseContext(parentContext, subtreeContext) {\n            return parentContext | subtreeContext;\n        }\n        function pushSuspenseContext(fiber, newContext) {\n            push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseContext(fiber) {\n            pop(suspenseStackCursor, fiber);\n        }\n        function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n            // If it was the primary children that just suspended, capture and render the\n            // fallback. Otherwise, don't capture and bubble to the next boundary.\n            var nextState = workInProgress.memoizedState;\n            if (nextState !== null) {\n                if (nextState.dehydrated !== null) {\n                    // A dehydrated boundary always captures.\n                    return true;\n                }\n                return false;\n            }\n            var props = workInProgress.memoizedProps; // Regular boundaries always capture.\n            {\n                return true;\n            }\n        }\n        function findFirstSuspended(row) {\n            var node = row;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        var dehydrated = state.dehydrated;\n                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                            return node;\n                        }\n                    }\n                } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n                // keep track of whether it suspended or not.\n                node.memoizedProps.revealOrder !== undefined) {\n                    var didSuspend = (node.flags & DidCapture) !== NoFlags;\n                    if (didSuspend) {\n                        return node;\n                    }\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === row) {\n                    return null;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === row) {\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n            return null;\n        }\n        var NoFlags$1 = /*   */ 0; // Represents whether effect should fire.\n        var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.\n        var Insertion = /*  */ 2;\n        var Layout = /*    */ 4;\n        var Passive$1 = /*   */ 8;\n        // and should be reset before starting a new render.\n        // This tracks which mutable sources need to be reset after a render.\n        var workInProgressSources = [];\n        function resetWorkInProgressVersions() {\n            for(var i = 0; i < workInProgressSources.length; i++){\n                var mutableSource = workInProgressSources[i];\n                if (isPrimaryRenderer) {\n                    mutableSource._workInProgressVersionPrimary = null;\n                } else {\n                    mutableSource._workInProgressVersionSecondary = null;\n                }\n            }\n            workInProgressSources.length = 0;\n        }\n        // This ensures that the version used for server rendering matches the one\n        // that is eventually read during hydration.\n        // If they don't match there's a potential tear and a full deopt render is required.\n        function registerMutableSourceForHydration(root, mutableSource) {\n            var getVersion = mutableSource._getVersion;\n            var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.\n            // Retaining it forever may interfere with GC.\n            if (root.mutableSourceEagerHydrationData == null) {\n                root.mutableSourceEagerHydrationData = [\n                    mutableSource,\n                    version\n                ];\n            } else {\n                root.mutableSourceEagerHydrationData.push(mutableSource, version);\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        {\n            didWarnAboutMismatchedHooksForComponent = new Set();\n        }\n        // These are set right before calling the component.\n        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n        // the work-in-progress hook.\n        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n        // current hook list is the list that belongs to the current fiber. The\n        // work-in-progress hook list is a new list that will be added to the\n        // work-in-progress fiber.\n        var currentHook = null;\n        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n        // does not get reset if we do another render pass; only when we're completely\n        // finished evaluating this component. This is an optimization so we know\n        // whether we need to clear render phase updates after a throw.\n        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n        // gets reset after each attempt.\n        // TODO: Maybe there's some way to consolidate this with\n        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n        var didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n        var localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n        // hydration). This counter is global, so client ids are not stable across\n        // render attempts.\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n        // The list stores the order of hooks used during the initial render (mount).\n        // Subsequent renders (updates) reference this list.\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n        // When true, such Hooks will always be \"remounted\". Only used during hot reload.\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev === null) {\n                    hookTypesDev = [\n                        hookName\n                    ];\n                } else {\n                    hookTypesDev.push(hookName);\n                }\n            }\n        }\n        function updateHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev !== null) {\n                    hookTypesUpdateIndexDev++;\n                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                        warnOnHookMismatchInDev(hookName);\n                    }\n                }\n            }\n        }\n        function checkDepsAreArrayDev(deps) {\n            {\n                if (deps !== undefined && deps !== null && !isArray(deps)) {\n                    // Verify deps, but only on mount to avoid extra checks.\n                    // It's unlikely their type would change as usually you define them inline.\n                    error(\"%s received a final argument that is not an array (instead, received `%s`). When \" + \"specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n                }\n            }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n                    didWarnAboutMismatchedHooksForComponent.add(componentName);\n                    if (hookTypesDev !== null) {\n                        var table = \"\";\n                        var secondColumnStart = 30;\n                        for(var i = 0; i <= hookTypesUpdateIndexDev; i++){\n                            var oldHookName = hookTypesDev[i];\n                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                            var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n                            // lol @ IE not supporting String#repeat\n                            while(row.length < secondColumnStart){\n                                row += \" \";\n                            }\n                            row += newHookName + \"\\n\";\n                            table += row;\n                        }\n                        error(\"React has detected a change in the order of Hooks called by %s. \" + \"This will lead to bugs and errors if not fixed. \" + \"For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n\" + \"   Previous render            Next render\\n\" + \"   ------------------------------------------------------\\n\" + \"%s\" + \"   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n                    }\n                }\n            }\n        }\n        function throwInvalidHookError() {\n            throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            {\n                if (ignorePreviousDependencies) {\n                    // Only true when this component is being hot reloaded.\n                    return false;\n                }\n            }\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n            renderLanes = nextRenderLanes;\n            currentlyRenderingFiber$1 = workInProgress;\n            {\n                hookTypesDev = current !== null ? current._debugHookTypes : null;\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n            }\n            workInProgress.memoizedState = null;\n            workInProgress.updateQueue = null;\n            workInProgress.lanes = NoLanes; // The following should have already been reset\n            // currentHook = null;\n            // workInProgressHook = null;\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // TODO Warn if no hooks are used at all during mount, then some are used during update.\n            // Currently we will identify the update render as a mount because memoizedState === null.\n            // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n            // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n            // so memoizedState would be null during updates and mounts.\n            {\n                if (current !== null && current.memoizedState !== null) {\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n                } else if (hookTypesDev !== null) {\n                    // This dispatcher handles an edge case where a component is updating,\n                    // but no stateful hooks have been used.\n                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n                    // This dispatcher does that.\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n                } else {\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n                }\n            }\n            var children = Component(props, secondArg); // Check if there was a render phase update\n            if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                // Keep rendering in a loop for as long as render phase updates continue to\n                // be scheduled. Use a counter to prevent infinite loops.\n                var numberOfReRenders = 0;\n                do {\n                    didScheduleRenderPhaseUpdateDuringThisPass = false;\n                    localIdCounter = 0;\n                    if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                        throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n                    }\n                    numberOfReRenders += 1;\n                    {\n                        // Even when hot reloading, allow dependencies to stabilize\n                        // after first render to prevent infinite render phase updates.\n                        ignorePreviousDependencies = false;\n                    }\n                    currentHook = null;\n                    workInProgressHook = null;\n                    workInProgress.updateQueue = null;\n                    {\n                        // Also validate hook order for cascading updates.\n                        hookTypesUpdateIndexDev = -1;\n                    }\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;\n                    children = Component(props, secondArg);\n                }while (didScheduleRenderPhaseUpdateDuringThisPass);\n            } // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n            {\n                workInProgress._debugHookTypes = hookTypesDev;\n            }\n            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                currentHookNameInDev = null;\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n                // render. If this fires, it suggests that we incorrectly reset the static\n                // flags in some other part of the codebase. This has happened before, for\n                // example, in the SuspenseList implementation.\n                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n                // and creates false positives. To make this work in legacy mode, we'd\n                // need to mark fibers that commit in an incomplete state, somehow. For\n                // now I'll disable the warning that most of the bugs that would trigger\n                // it are either exclusive to concurrent mode or exist in both.\n                (current.mode & ConcurrentMode) !== NoMode) {\n                    error(\"Internal React error: Expected static flag was missing. Please \" + \"notify the React team.\");\n                }\n            }\n            didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n            // localIdCounter = 0;\n            if (didRenderTooFewHooks) {\n                throw new Error(\"Rendered fewer hooks than expected. This may be caused by an accidental \" + \"early return statement.\");\n            }\n            return children;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every renderWithHooks call.\n            // Conceptually, it's part of the return value of renderWithHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            localIdCounter = 0;\n            return didRenderIdHook;\n        }\n        function bailoutHooks(current, workInProgress, lanes) {\n            workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n            // complete phase (bubbleProperties).\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n            } else {\n                workInProgress.flags &= ~(Passive | Update);\n            }\n            current.lanes = removeLanes(current.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n            // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n            if (didScheduleRenderPhaseUpdate) {\n                // There were render phase updates. These are only valid for this render\n                // phase, which we are now aborting. Remove the updates from the queues so\n                // they do not persist to the next render. Do not remove updates from hooks\n                // that weren't processed.\n                //\n                // Only reset the updates from the queue if it has a clone. If it does\n                // not have a clone, that means it wasn't processed, and the updates were\n                // scheduled before we entered the render phase.\n                var hook = currentlyRenderingFiber$1.memoizedState;\n                while(hook !== null){\n                    var queue = hook.queue;\n                    if (queue !== null) {\n                        queue.pending = null;\n                    }\n                    hook = hook.next;\n                }\n                didScheduleRenderPhaseUpdate = false;\n            }\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1;\n                currentHookNameInDev = null;\n                isUpdatingOpaqueValueInRenderPhase = false;\n            }\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\n            localIdCounter = 0;\n        }\n        function mountWorkInProgressHook() {\n            var hook = {\n                memoizedState: null,\n                baseState: null,\n                baseQueue: null,\n                queue: null,\n                next: null\n            };\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n            } else {\n                // Append to the end of the list\n                workInProgressHook = workInProgressHook.next = hook;\n            }\n            return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n            // This function is used both for updates and for re-renders triggered by a\n            // render phase update. It assumes there is either a current hook we can\n            // clone, or a work-in-progress hook from a previous render pass that we can\n            // use as a base. When we reach the end of the base list, we must switch to\n            // the dispatcher used for mounts.\n            var nextCurrentHook;\n            if (currentHook === null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    nextCurrentHook = current.memoizedState;\n                } else {\n                    nextCurrentHook = null;\n                }\n            } else {\n                nextCurrentHook = currentHook.next;\n            }\n            var nextWorkInProgressHook;\n            if (workInProgressHook === null) {\n                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n            } else {\n                nextWorkInProgressHook = workInProgressHook.next;\n            }\n            if (nextWorkInProgressHook !== null) {\n                // There's already a work-in-progress. Reuse it.\n                workInProgressHook = nextWorkInProgressHook;\n                nextWorkInProgressHook = workInProgressHook.next;\n                currentHook = nextCurrentHook;\n            } else {\n                // Clone from the current hook.\n                if (nextCurrentHook === null) {\n                    throw new Error(\"Rendered more hooks than during the previous render.\");\n                }\n                currentHook = nextCurrentHook;\n                var newHook = {\n                    memoizedState: currentHook.memoizedState,\n                    baseState: currentHook.baseState,\n                    baseQueue: currentHook.baseQueue,\n                    queue: currentHook.queue,\n                    next: null\n                };\n                if (workInProgressHook === null) {\n                    // This is the first hook in the list.\n                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n                } else {\n                    // Append to the end of the list.\n                    workInProgressHook = workInProgressHook.next = newHook;\n                }\n            }\n            return workInProgressHook;\n        }\n        function createFunctionComponentUpdateQueue() {\n            return {\n                lastEffect: null,\n                stores: null\n            };\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n            var hook = mountWorkInProgressHook();\n            var initialState;\n            if (init !== undefined) {\n                initialState = init(initialArg);\n            } else {\n                initialState = initialArg;\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                interleaved: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: reducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n            }\n            queue.lastRenderedReducer = reducer;\n            var current = currentHook; // The last rebase update that is NOT part of the base state.\n            var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n            var pendingQueue = queue.pending;\n            if (pendingQueue !== null) {\n                // We have new updates that haven't been processed yet.\n                // We'll add them to the base queue.\n                if (baseQueue !== null) {\n                    // Merge the pending queue and the base queue.\n                    var baseFirst = baseQueue.next;\n                    var pendingFirst = pendingQueue.next;\n                    baseQueue.next = pendingFirst;\n                    pendingQueue.next = baseFirst;\n                }\n                {\n                    if (current.baseQueue !== baseQueue) {\n                        // Internal invariant that should never happen, but feasibly could in\n                        // the future if we implement resuming, or some form of that.\n                        error(\"Internal error: Expected work-in-progress queue to be a clone. \" + \"This is a bug in React.\");\n                    }\n                }\n                current.baseQueue = baseQueue = pendingQueue;\n                queue.pending = null;\n            }\n            if (baseQueue !== null) {\n                // We have a queue to process.\n                var first = baseQueue.next;\n                var newState = current.baseState;\n                var newBaseState = null;\n                var newBaseQueueFirst = null;\n                var newBaseQueueLast = null;\n                var update = first;\n                do {\n                    var updateLane = update.lane;\n                    if (!isSubsetOfLanes(renderLanes, updateLane)) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            action: update.action,\n                            hasEagerState: update.hasEagerState,\n                            eagerState: update.eagerState,\n                            next: null\n                        };\n                        if (newBaseQueueLast === null) {\n                            newBaseQueueFirst = newBaseQueueLast = clone;\n                            newBaseState = newState;\n                        } else {\n                            newBaseQueueLast = newBaseQueueLast.next = clone;\n                        } // Update the remaining priority in the queue.\n                        // TODO: Don't need to accumulate this. Instead, we can remove\n                        // renderLanes from the original lanes.\n                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                        markSkippedUpdateLanes(updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        if (newBaseQueueLast !== null) {\n                            var _clone = {\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                action: update.action,\n                                hasEagerState: update.hasEagerState,\n                                eagerState: update.eagerState,\n                                next: null\n                            };\n                            newBaseQueueLast = newBaseQueueLast.next = _clone;\n                        } // Process this update.\n                        if (update.hasEagerState) {\n                            // If this update is a state update (not a reducer) and was processed eagerly,\n                            // we can use the eagerly computed state\n                            newState = update.eagerState;\n                        } else {\n                            var action = update.action;\n                            newState = reducer(newState, action);\n                        }\n                    }\n                    update = update.next;\n                }while (update !== null && update !== first);\n                if (newBaseQueueLast === null) {\n                    newBaseState = newState;\n                } else {\n                    newBaseQueueLast.next = newBaseQueueFirst;\n                } // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState;\n                hook.baseState = newBaseState;\n                hook.baseQueue = newBaseQueueLast;\n                queue.lastRenderedState = newState;\n            } // Interleaved updates are stored on a separate queue. We aren't going to\n            // process them during this render, but we do need to track which lanes\n            // are remaining.\n            var lastInterleaved = queue.interleaved;\n            if (lastInterleaved !== null) {\n                var interleaved = lastInterleaved;\n                do {\n                    var interleavedLane = interleaved.lane;\n                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n                    markSkippedUpdateLanes(interleavedLane);\n                    interleaved = interleaved.next;\n                }while (interleaved !== lastInterleaved);\n            } else if (baseQueue === null) {\n                // `queue.lanes` is used for entangling transitions. We can set it back to\n                // zero once the queue is empty.\n                queue.lanes = NoLanes;\n            }\n            var dispatch = queue.dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n            }\n            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n            // work-in-progress hook.\n            var dispatch = queue.dispatch;\n            var lastRenderPhaseUpdate = queue.pending;\n            var newState = hook.memoizedState;\n            if (lastRenderPhaseUpdate !== null) {\n                // The queue doesn't persist past this render pass.\n                queue.pending = null;\n                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                var update = firstRenderPhaseUpdate;\n                do {\n                    // Process this render phase update. We don't have to check the\n                    // priority because it will always be the same as the current\n                    // render's.\n                    var action = update.action;\n                    newState = reducer(newState, action);\n                    update = update.next;\n                }while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n                // the base state unless the queue is empty.\n                // TODO: Not sure if this is the desired semantics, but it's what we\n                // do for gDSFP. I can't remember why.\n                if (hook.baseQueue === null) {\n                    hook.baseState = newState;\n                }\n                queue.lastRenderedState = newState;\n            }\n            return [\n                newState,\n                dispatch\n            ];\n        }\n        function mountMutableSource(source, getSnapshot, subscribe) {\n            {\n                return undefined;\n            }\n        }\n        function updateMutableSource(source, getSnapshot, subscribe) {\n            {\n                return undefined;\n            }\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = mountWorkInProgressHook();\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                if (getServerSnapshot === undefined) {\n                    throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n                }\n                nextSnapshot = getServerSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        if (nextSnapshot !== getServerSnapshot()) {\n                            error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\");\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                //\n                // We won't do this if we're hydrating server-rendered content, because if\n                // the content is stale, it's already visible anyway. Instead we'll patch\n                // it up in a passive effect.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                }\n                if (!includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            } // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            hook.memoizedState = nextSnapshot;\n            var inst = {\n                value: nextSnapshot,\n                getSnapshot: getSnapshot\n            };\n            hook.queue = inst; // Schedule an effect to subscribe to the store.\n            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Schedule an effect to update the mutable instance fields. We will update\n            // this whenever subscribe, getSnapshot, or value changes. Because there's no\n            // clean-up function, and we track the deps correctly, we can call pushEffect\n            // directly, without storing any additional state. For the same reason, we\n            // don't need to set a static flag, either.\n            // TODO: We can move this to the passive phase once we add a pre-commit\n            // consistency check. See the next comment.\n            fiber.flags |= Passive;\n            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n            return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            var nextSnapshot = getSnapshot();\n            {\n                if (!didWarnUncachedGetSnapshot) {\n                    var cachedSnapshot = getSnapshot();\n                    if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                        error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                        didWarnUncachedGetSnapshot = true;\n                    }\n                }\n            }\n            var prevSnapshot = hook.memoizedState;\n            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n            if (snapshotChanged) {\n                hook.memoizedState = nextSnapshot;\n                markWorkInProgressReceivedUpdate();\n            }\n            var inst = hook.queue;\n            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Whenever getSnapshot or subscribe changes, we need to check in the\n            // commit phase if there was an interleaved mutation. In concurrent mode\n            // this can happen all the time, but even in synchronous mode, an earlier\n            // effect may have mutated the store.\n            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n            // checking whether we scheduled a subscription effect above.\n            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n                fiber.flags |= Passive;\n                pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                }\n                if (!includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            }\n            return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n            fiber.flags |= StoreConsistency;\n            var check = {\n                getSnapshot: getSnapshot,\n                value: renderedSnapshot\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.stores = [\n                    check\n                ];\n            } else {\n                var stores = componentUpdateQueue.stores;\n                if (stores === null) {\n                    componentUpdateQueue.stores = [\n                        check\n                    ];\n                } else {\n                    stores.push(check);\n                }\n            }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n            // These are updated in the passive phase\n            inst.value = nextSnapshot;\n            inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n            // have been in an event that fired before the passive effects, or it could\n            // have been in a layout effect. In that case, we would have used the old\n            // snapsho and getSnapshot values to bail out. We need to check one more time.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceStoreRerender(fiber);\n            }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n            var handleStoreChange = function() {\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceStoreRerender(fiber);\n                }\n            }; // Subscribe to the store and return a clean-up function.\n            return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function forceStoreRerender(fiber) {\n            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n        }\n        function mountState(initialState) {\n            var hook = mountWorkInProgressHook();\n            if (typeof initialState === \"function\") {\n                // $FlowFixMe: Flow doesn't like mixed types\n                initialState = initialState();\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                interleaved: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateState(initialState) {\n            return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n            return rerenderReducer(basicStateReducer);\n        }\n        function pushEffect(tag, create, destroy, deps) {\n            var effect = {\n                tag: tag,\n                create: create,\n                destroy: destroy,\n                deps: deps,\n                // Circular\n                next: null\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n                var lastEffect = componentUpdateQueue.lastEffect;\n                if (lastEffect === null) {\n                    componentUpdateQueue.lastEffect = effect.next = effect;\n                } else {\n                    var firstEffect = lastEffect.next;\n                    lastEffect.next = effect;\n                    effect.next = firstEffect;\n                    componentUpdateQueue.lastEffect = effect;\n                }\n            }\n            return effect;\n        }\n        function mountRef(initialValue) {\n            var hook = mountWorkInProgressHook();\n            {\n                var _ref2 = {\n                    current: initialValue\n                };\n                hook.memoizedState = _ref2;\n                return _ref2;\n            }\n        }\n        function updateRef(initialValue) {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var destroy = undefined;\n            if (currentHook !== null) {\n                var prevEffect = currentHook.memoizedState;\n                destroy = prevEffect.destroy;\n                if (nextDeps !== null) {\n                    var prevDeps = prevEffect.deps;\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n                        return;\n                    }\n                }\n            }\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n        }\n        function mountEffect(create, deps) {\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n            } else {\n                return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n            }\n        }\n        function updateEffect(create, deps) {\n            return updateEffectImpl(Passive, Passive$1, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n            return mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n            return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n            var fiberFlags = Update;\n            {\n                fiberFlags |= LayoutStatic;\n            }\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n            return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n            if (typeof ref === \"function\") {\n                var refCallback = ref;\n                var _inst = create();\n                refCallback(_inst);\n                return function() {\n                    refCallback(null);\n                };\n            } else if (ref !== null && ref !== undefined) {\n                var refObject = ref;\n                {\n                    if (!refObject.hasOwnProperty(\"current\")) {\n                        error(\"Expected useImperativeHandle() first argument to either be a \" + \"ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(refObject).join(\", \") + \"}\");\n                    }\n                }\n                var _inst2 = create();\n                refObject.current = _inst2;\n                return function() {\n                    refObject.current = null;\n                };\n            }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== \"function\") {\n                    error(\"Expected useImperativeHandle() second argument to be a function \" + \"that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            var fiberFlags = Update;\n            {\n                fiberFlags |= LayoutStatic;\n            }\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== \"function\") {\n                    error(\"Expected useImperativeHandle() second argument to be a function \" + \"that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        // The react-debug-hooks package injects its own implementation\n        // so that e.g. DevTools can display custom hook values.\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function updateCallback(callback, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (prevState !== null) {\n                if (nextDeps !== null) {\n                    var prevDeps = prevState[1];\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        return prevState[0];\n                    }\n                }\n            }\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var nextValue = nextCreate();\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (prevState !== null) {\n                // Assume these are defined. If they're not, areHookInputsEqual will warn.\n                if (nextDeps !== null) {\n                    var prevDeps = prevState[1];\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        return prevState[0];\n                    }\n                }\n            }\n            var nextValue = nextCreate();\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function mountDeferredValue(value) {\n            var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];\n            mountEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function updateDeferredValue(value) {\n            var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];\n            updateEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function rerenderDeferredValue(value) {\n            var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];\n            updateEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function startTransition(setPending, callback, options) {\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n            setPending(true);\n            var prevTransition = ReactCurrentBatchConfig$1.transition;\n            ReactCurrentBatchConfig$1.transition = {};\n            var currentTransition = ReactCurrentBatchConfig$1.transition;\n            {\n                ReactCurrentBatchConfig$1.transition._updatedFibers = new Set();\n            }\n            try {\n                setPending(false);\n                callback();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$1.transition = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        if (updatedFibersCount > 10) {\n                            warn(\"Detected a large number of updates inside startTransition. \" + \"If this is due to a subscription please re-write it to use React provided hooks. \" + \"Otherwise concurrent mode guarantees are off the table.\");\n                        }\n                        currentTransition._updatedFibers.clear();\n                    }\n                }\n            }\n        }\n        function mountTransition() {\n            var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1]; // The `start` method never changes.\n            var start = startTransition.bind(null, setPending);\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = start;\n            return [\n                isPending,\n                start\n            ];\n        }\n        function updateTransition() {\n            var _updateState2 = updateState(), isPending = _updateState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            return [\n                isPending,\n                start\n            ];\n        }\n        function rerenderTransition() {\n            var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            return [\n                isPending,\n                start\n            ];\n        }\n        var isUpdatingOpaqueValueInRenderPhase = false;\n        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n            {\n                return isUpdatingOpaqueValueInRenderPhase;\n            }\n        }\n        function mountId() {\n            var hook = mountWorkInProgressHook();\n            var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n            // should do this in Fiber, too? Deferring this decision for now because\n            // there's no other place to store the prefix except for an internal field on\n            // the public createRoot object, which the fiber tree does not currently have\n            // a reference to.\n            var identifierPrefix = root.identifierPrefix;\n            var id;\n            if (getIsHydrating()) {\n                var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n                id = \":\" + identifierPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n                // that represents the position of this useId hook among all the useId\n                // hooks for this fiber.\n                var localId = localIdCounter++;\n                if (localId > 0) {\n                    id += \"H\" + localId.toString(32);\n                }\n                id += \":\";\n            } else {\n                // Use a lowercase r prefix for client-generated ids.\n                var globalClientId = globalClientIdCounter++;\n                id = \":\" + identifierPrefix + \"r\" + globalClientId.toString(32) + \":\";\n            }\n            hook.memoizedState = id;\n            return id;\n        }\n        function updateId() {\n            var hook = updateWorkInProgressHook();\n            var id = hook.memoizedState;\n            return id;\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === \"function\") {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + \"second callback argument. To execute a side effect after \" + \"rendering, declare it in the component body with useEffect().\");\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                enqueueUpdate$1(fiber, queue, update);\n                var eventTime = requestEventTime();\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === \"function\") {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + \"second callback argument. To execute a side effect after \" + \"rendering, declare it in the component body with useEffect().\");\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                enqueueUpdate$1(fiber, queue, update);\n                var alternate = fiber.alternate;\n                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    var lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        var prevDispatcher;\n                        {\n                            prevDispatcher = ReactCurrentDispatcher$1.current;\n                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                        }\n                        try {\n                            var currentState = queue.lastRenderedState;\n                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.hasEagerState = true;\n                            update.eagerState = eagerState;\n                            if (objectIs(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                return;\n                            }\n                        } catch (error) {} finally{\n                            {\n                                ReactCurrentDispatcher$1.current = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n                var eventTime = requestEventTime();\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n            var alternate = fiber.alternate;\n            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n            var pending = queue.pending;\n            if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n            } else {\n                update.next = pending.next;\n                pending.next = update;\n            }\n            queue.pending = update;\n        }\n        function enqueueUpdate$1(fiber, queue, update, lane) {\n            if (isInterleavedUpdate(fiber)) {\n                var interleaved = queue.interleaved;\n                if (interleaved === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update; // At the end of the current render, this queue's interleaved updates will\n                    // be transferred to the pending queue.\n                    pushInterleavedQueue(queue);\n                } else {\n                    update.next = interleaved.next;\n                    interleaved.next = update;\n                }\n                queue.interleaved = update;\n            } else {\n                var pending = queue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                queue.pending = update;\n            }\n        }\n        function entangleTransitionUpdate(root, queue, lane) {\n            if (isTransitionLane(lane)) {\n                var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n                // must have finished. We can remove them from the shared queue, which\n                // represents a superset of the actually pending lanes. In some cases we\n                // may entangle more than we need to, but that's OK. In fact it's worse if\n                // we *don't* entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n            {\n                markStateUpdateScheduled(fiber, lane);\n            }\n        }\n        var ContextOnlyDispatcher = {\n            readContext: readContext,\n            useCallback: throwInvalidHookError,\n            useContext: throwInvalidHookError,\n            useEffect: throwInvalidHookError,\n            useImperativeHandle: throwInvalidHookError,\n            useInsertionEffect: throwInvalidHookError,\n            useLayoutEffect: throwInvalidHookError,\n            useMemo: throwInvalidHookError,\n            useReducer: throwInvalidHookError,\n            useRef: throwInvalidHookError,\n            useState: throwInvalidHookError,\n            useDebugValue: throwInvalidHookError,\n            useDeferredValue: throwInvalidHookError,\n            useTransition: throwInvalidHookError,\n            useMutableSource: throwInvalidHookError,\n            useSyncExternalStore: throwInvalidHookError,\n            useId: throwInvalidHookError,\n            unstable_isNewReconciler: enableNewReconciler\n        };\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n            var warnInvalidContextAccess = function() {\n                error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n            };\n            var warnInvalidHookAccess = function() {\n                error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n            };\n            HooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    mountHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    mountHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    mountHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnMountWithHookTypesInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return updateDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n        }\n        var now$2 = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        /**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */ var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n            return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n            {\n                nestedUpdateScheduled = true;\n            }\n        }\n        function resetNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = false;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function syncNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = nestedUpdateScheduled;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function getCommitTime() {\n            return commitTime;\n        }\n        function recordCommitTime() {\n            commitTime = now$2();\n        }\n        function startProfilerTimer(fiber) {\n            profilerStartTime = now$2();\n            if (fiber.actualStartTime < 0) {\n                fiber.actualStartTime = now$2();\n            }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n            profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n            if (profilerStartTime >= 0) {\n                var elapsedTime = now$2() - profilerStartTime;\n                fiber.actualDuration += elapsedTime;\n                if (overrideBaseTime) {\n                    fiber.selfBaseDuration = elapsedTime;\n                }\n                profilerStartTime = -1;\n            }\n        }\n        function recordLayoutEffectDuration(fiber) {\n            if (layoutEffectStartTime >= 0) {\n                var elapsedTime = now$2() - layoutEffectStartTime;\n                layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            root.effectDuration += elapsedTime;\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            parentStateNode.effectDuration += elapsedTime;\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function recordPassiveEffectDuration(fiber) {\n            if (passiveEffectStartTime >= 0) {\n                var elapsedTime = now$2() - passiveEffectStartTime;\n                passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            if (root !== null) {\n                                root.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            if (parentStateNode !== null) {\n                                // Detached fibers have their state node cleared out.\n                                // In this case, the return pointer is also cleared out,\n                                // so we won't be able to report the time spent in this Profiler's subtree.\n                                parentStateNode.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function startLayoutEffectTimer() {\n            layoutEffectStartTime = now$2();\n        }\n        function startPassiveEffectTimer() {\n            passiveEffectStartTime = now$2();\n        }\n        function transferActualDuration(fiber) {\n            // Transfer time spent rendering these children so we don't lose it\n            // after we rerender. This is used as a helper in special cases\n            // where we should count the work of multiple passes.\n            var child = fiber.child;\n            while(child){\n                fiber.actualDuration += child.actualDuration;\n                child = child.sibling;\n            }\n        }\n        function createCapturedValue(value, source) {\n            // If the value is an error, call this function immediately after it is thrown\n            // so the stack is accurate.\n            return {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n        }\n        // This module is forked in different environments.\n        // By default, return `true` to log errors to the console.\n        // Forks can return `false` if this isn't desirable.\n        function showErrorDialog(boundary, errorInfo) {\n            return true;\n        }\n        function logCapturedError(boundary, errorInfo) {\n            try {\n                var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.\n                // This enables renderers like ReactNative to better manage redbox behavior.\n                if (logError === false) {\n                    return;\n                }\n                var error = errorInfo.value;\n                if (true) {\n                    var source = errorInfo.source;\n                    var stack = errorInfo.stack;\n                    var componentStack = stack !== null ? stack : \"\"; // Browsers support silencing uncaught errors by calling\n                    // `preventDefault()` in window `error` handler.\n                    // We record this information as an expando on the error.\n                    if (error != null && error._suppressLogging) {\n                        if (boundary.tag === ClassComponent) {\n                            // The error is recoverable and was silenced.\n                            // Ignore it and don't print the stack addendum.\n                            // This is handy for testing error boundaries without noise.\n                            return;\n                        } // The error is fatal. Since the silencing might have\n                        // been accidental, we'll surface it anyway.\n                        // However, the browser would have silenced the original error\n                        // so we'll print it first, and then print the stack addendum.\n                        console[\"error\"](error); // Don't transform to our wrapper\n                    // For a more detailed description of this block, see:\n                    // https://github.com/facebook/react/pull/13384\n                    }\n                    var componentName = source ? getComponentNameFromFiber(source) : null;\n                    var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : \"The above error occurred in one of your React components:\";\n                    var errorBoundaryMessage;\n                    if (boundary.tag === HostRoot) {\n                        errorBoundaryMessage = \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" + \"Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.\";\n                    } else {\n                        var errorBoundaryName = getComponentNameFromFiber(boundary) || \"Anonymous\";\n                        errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n                    }\n                    var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n                    // We don't include the original error message and JS stack because the browser\n                    // has already printed it. Even if the application swallows the error, it is still\n                    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n                    console[\"error\"](combinedMessage); // Don't transform to our wrapper\n                } else {}\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        var PossiblyWeakMap$1 = typeof WeakMap === \"function\" ? WeakMap : Map;\n        function createRootErrorUpdate(fiber, errorInfo, lane) {\n            var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n            update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: null\n            };\n            var error = errorInfo.value;\n            update.callback = function() {\n                onUncaughtError(error);\n                logCapturedError(fiber, errorInfo);\n            };\n            return update;\n        }\n        function createClassErrorUpdate(fiber, errorInfo, lane) {\n            var update = createUpdate(NoTimestamp, lane);\n            update.tag = CaptureUpdate;\n            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n            if (typeof getDerivedStateFromError === \"function\") {\n                var error$1 = errorInfo.value;\n                update.payload = function() {\n                    return getDerivedStateFromError(error$1);\n                };\n                update.callback = function() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    logCapturedError(fiber, errorInfo);\n                };\n            }\n            var inst = fiber.stateNode;\n            if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n                update.callback = function callback() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    logCapturedError(fiber, errorInfo);\n                    if (typeof getDerivedStateFromError !== \"function\") {\n                        // To preserve the preexisting retry behavior of error boundaries,\n                        // we keep track of which ones already failed during this batch.\n                        // This gets reset before we yield back to the browser.\n                        // TODO: Warn in strict mode if getDerivedStateFromError is\n                        // not defined.\n                        markLegacyErrorBoundaryAsFailed(this);\n                    }\n                    var error$1 = errorInfo.value;\n                    var stack = errorInfo.stack;\n                    this.componentDidCatch(error$1, {\n                        componentStack: stack !== null ? stack : \"\"\n                    });\n                    {\n                        if (typeof getDerivedStateFromError !== \"function\") {\n                            // If componentDidCatch is the only error boundary method defined,\n                            // then it needs to call setState to recover from errors.\n                            // If no state update is scheduled then the boundary will swallow the error.\n                            if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                                error(\"%s: Error boundaries should implement getDerivedStateFromError(). \" + \"In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n                            }\n                        }\n                    }\n                };\n            }\n            return update;\n        }\n        function attachPingListener(root, wakeable, lanes) {\n            // Attach a ping listener\n            //\n            // The data might resolve before we have a chance to commit the fallback. Or,\n            // in the case of a refresh, we'll never commit a fallback. So we need to\n            // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n            // try rendering the tree again.\n            //\n            // Only attach a listener if one does not already exist for the lanes\n            // we're currently rendering (which acts like a \"thread ID\" here).\n            //\n            // We only need to do this in concurrent mode. Legacy Suspense always\n            // commits fallbacks synchronously, so there are no pings.\n            var pingCache = root.pingCache;\n            var threadIDs;\n            if (pingCache === null) {\n                pingCache = root.pingCache = new PossiblyWeakMap$1();\n                threadIDs = new Set();\n                pingCache.set(wakeable, threadIDs);\n            } else {\n                threadIDs = pingCache.get(wakeable);\n                if (threadIDs === undefined) {\n                    threadIDs = new Set();\n                    pingCache.set(wakeable, threadIDs);\n                }\n            }\n            if (!threadIDs.has(lanes)) {\n                // Memoize using the thread ID to prevent redundant listeners.\n                threadIDs.add(lanes);\n                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n                {\n                    if (isDevToolsPresent) {\n                        // If we have pending work still, restore the original updaters\n                        restorePendingUpdaters(root, lanes);\n                    }\n                }\n                wakeable.then(ping, ping);\n            }\n        }\n        function attachRetryListener(suspenseBoundary, root, wakeable, lanes) {\n            // Retry listener\n            //\n            // If the fallback does commit, we need to attach a different type of\n            // listener. This one schedules an update on the Suspense boundary to turn\n            // the fallback state off.\n            //\n            // Stash the wakeable on the boundary fiber so we can access it in the\n            // commit phase.\n            //\n            // When the wakeable resolves, we'll attempt to render the boundary\n            // again (\"retry\").\n            var wakeables = suspenseBoundary.updateQueue;\n            if (wakeables === null) {\n                var updateQueue = new Set();\n                updateQueue.add(wakeable);\n                suspenseBoundary.updateQueue = updateQueue;\n            } else {\n                wakeables.add(wakeable);\n            }\n        }\n        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n            // A legacy mode Suspense quirk, only relevant to hook components.\n            var tag = sourceFiber.tag;\n            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n                var currentSource = sourceFiber.alternate;\n                if (currentSource) {\n                    sourceFiber.updateQueue = currentSource.updateQueue;\n                    sourceFiber.memoizedState = currentSource.memoizedState;\n                    sourceFiber.lanes = currentSource.lanes;\n                } else {\n                    sourceFiber.updateQueue = null;\n                    sourceFiber.memoizedState = null;\n                }\n            }\n        }\n        function getNearestSuspenseBoundaryToCapture(returnFiber) {\n            var node = returnFiber;\n            do {\n                if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n                    return node;\n                } // This boundary already captured during this render. Continue to the next\n                // boundary.\n                node = node.return;\n            }while (node !== null);\n            return null;\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n            // This marks a Suspense boundary so that when we're unwinding the stack,\n            // it captures the suspended \"exception\" and does a second (fallback) pass.\n            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n                // Legacy Mode Suspense\n                //\n                // If the boundary is in legacy mode, we should *not*\n                // suspend the commit. Pretend as if the suspended component rendered\n                // null and keep rendering. When the Suspense boundary completes,\n                // we'll do a second pass to render the fallback.\n                if (suspenseBoundary === returnFiber) {\n                    // Special case where we suspended while reconciling the children of\n                    // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n                    // when a React.lazy component is a direct child of a\n                    // Suspense boundary.\n                    //\n                    // Suspense boundaries are implemented as multiple fibers, but they\n                    // are a single conceptual unit. The legacy mode behavior where we\n                    // pretend the suspended fiber committed as `null` won't work,\n                    // because in this case the \"suspended\" fiber is the inner\n                    // Offscreen wrapper.\n                    //\n                    // Because the contents of the boundary haven't started rendering\n                    // yet (i.e. nothing in the tree has partially rendered) we can\n                    // switch to the regular, concurrent mode behavior: mark the\n                    // boundary with ShouldCapture and enter the unwind phase.\n                    suspenseBoundary.flags |= ShouldCapture;\n                } else {\n                    suspenseBoundary.flags |= DidCapture;\n                    sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n                    // But we shouldn't call any lifecycle methods or callbacks. Remove\n                    // all lifecycle effect tags.\n                    sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n                    if (supportsPersistence && enablePersistentOffscreenHostContainer) {\n                        // Another legacy Suspense quirk. In persistent mode, if this is the\n                        // initial mount, override the props of the host container to hide\n                        // its contents.\n                        var currentSuspenseBoundary = suspenseBoundary.alternate;\n                        if (currentSuspenseBoundary === null) {\n                            var offscreenFiber = suspenseBoundary.child;\n                            var offscreenContainer = offscreenFiber.child;\n                            if (offscreenContainer !== null) {\n                                var children = offscreenContainer.memoizedProps.children;\n                                var containerProps = getOffscreenContainerProps(\"hidden\", children);\n                                offscreenContainer.pendingProps = containerProps;\n                                offscreenContainer.memoizedProps = containerProps;\n                            }\n                        }\n                    }\n                    if (sourceFiber.tag === ClassComponent) {\n                        var currentSourceFiber = sourceFiber.alternate;\n                        if (currentSourceFiber === null) {\n                            // This is a new mount. Change the tag so it's not mistaken for a\n                            // completed class component. For example, we should not call\n                            // componentWillUnmount if it is deleted.\n                            sourceFiber.tag = IncompleteClassComponent;\n                        } else {\n                            // When we try rendering again, we should not reuse the current fiber,\n                            // since it's known to be in an inconsistent state. Use a force update to\n                            // prevent a bail out.\n                            var update = createUpdate(NoTimestamp, SyncLane);\n                            update.tag = ForceUpdate;\n                            enqueueUpdate(sourceFiber, update);\n                        }\n                    } // The source fiber did not complete. Mark it with Sync priority to\n                    // indicate that it still has pending work.\n                    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n                }\n                return suspenseBoundary;\n            } // Confirmed that the boundary is in a concurrent mode tree. Continue\n            // with the normal suspend path.\n            //\n            // After this we'll use a set of heuristics to determine whether this\n            // render pass will run to completion or restart or \"suspend\" the commit.\n            // The actual logic for this is spread out in different places.\n            //\n            // This first principle is that if we're going to suspend when we complete\n            // a root, then we should also restart if we get an update or ping that\n            // might unsuspend it, and vice versa. The only reason to suspend is\n            // because you think you might want to restart before committing. However,\n            // it doesn't make sense to restart only while in the period we're suspended.\n            //\n            // Restarting too aggressively is also not good because it starves out any\n            // intermediate loading state. So we use heuristics to determine when.\n            // Suspense Heuristics\n            //\n            // If nothing threw a Promise or all the same fallbacks are already showing,\n            // then don't suspend/restart.\n            //\n            // If this is an initial render of a new tree of Suspense boundaries and\n            // those trigger a fallback, then don't suspend/restart. We want to ensure\n            // that we can show the initial loading state as quickly as possible.\n            //\n            // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n            // a fallback, then we should always suspend/restart. Transitions apply\n            // to this case. If none is defined, JND is used instead.\n            //\n            // If we're already showing a fallback and it gets \"retried\", allowing us to show\n            // another level, but there's still an inner boundary that would show a fallback,\n            // then we suspend/restart for 500ms since the last time we showed a fallback\n            // anywhere in the tree. This effectively throttles progressive loading into a\n            // consistent train of commits. This also gives us an opportunity to restart to\n            // get to the completed state slightly earlier.\n            //\n            // If there's ambiguity due to batching it's resolved in preference of:\n            // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n            //\n            // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n            // ensure that new initial loading states can commit as soon as possible.\n            suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n            // the begin phase to prevent an early bailout.\n            suspenseBoundary.lanes = rootRenderLanes;\n            return suspenseBoundary;\n        }\n        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n            // The source fiber did not complete.\n            sourceFiber.flags |= Incomplete;\n            {\n                if (isDevToolsPresent) {\n                    // If we have pending work still, restore the original updaters\n                    restorePendingUpdaters(root, rootRenderLanes);\n                }\n            }\n            if (value !== null && typeof value === \"object\" && typeof value.then === \"function\") {\n                // This is a wakeable. The component suspended.\n                var wakeable = value;\n                resetSuspendedComponent(sourceFiber);\n                var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n                if (suspenseBoundary !== null) {\n                    suspenseBoundary.flags &= ~ForceClientRender;\n                    markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always\n                    // commits fallbacks synchronously, so there are no pings.\n                    if (suspenseBoundary.mode & ConcurrentMode) {\n                        attachPingListener(root, wakeable, rootRenderLanes);\n                    }\n                    attachRetryListener(suspenseBoundary, root, wakeable);\n                    return;\n                } else {\n                    // No boundary was found. Unless this is a sync update, this is OK.\n                    // We can suspend and wait for more data to arrive.\n                    if (!includesSyncLane(rootRenderLanes)) {\n                        // This is not a sync update. Suspend. Since we're not activating a\n                        // Suspense boundary, this will unwind all the way to the root without\n                        // performing a second pass to render a fallback. (This is arguably how\n                        // refresh transitions should work, too, since we're not going to commit\n                        // the fallbacks anyway.)\n                        //\n                        // This case also applies to initial hydration.\n                        attachPingListener(root, wakeable, rootRenderLanes);\n                        renderDidSuspendDelayIfPossible();\n                        return;\n                    } // This is a sync/discrete update. We treat this case like an error\n                    // because discrete renders are expected to produce a complete tree\n                    // synchronously to maintain consistency with external state.\n                    var uncaughtSuspenseError = new Error(\"A component suspended while responding to synchronous input. This \" + \"will cause the UI to be replaced with a loading indicator. To \" + \"fix, updates that suspend should be wrapped \" + \"with startTransition.\"); // If we're outside a transition, fall through to the regular error path.\n                    // The error will be caught by the nearest suspense boundary.\n                    value = uncaughtSuspenseError;\n                }\n            } else {\n                // This is a regular error, not a Suspense wakeable.\n                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n                    markDidSuspendWhileHydratingDEV();\n                    var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n                    // discarding the dehydrated content and switching to a client render.\n                    // Instead of surfacing the error, find the nearest Suspense boundary\n                    // and render it again without hydration.\n                    if (_suspenseBoundary !== null) {\n                        if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n                            // Set a flag to indicate that we should try rendering the normal\n                            // children again, not the fallback.\n                            _suspenseBoundary.flags |= ForceClientRender;\n                        }\n                        markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n                        // still log it so it can be fixed.\n                        queueHydrationError(value);\n                        return;\n                    }\n                }\n            } // We didn't find a boundary that could handle this type of exception. Start\n            // over and traverse parent path again, this time treating the exception\n            // as an error.\n            renderDidError(value);\n            value = createCapturedValue(value, sourceFiber);\n            var workInProgress = returnFiber;\n            do {\n                switch(workInProgress.tag){\n                    case HostRoot:\n                        {\n                            var _errorInfo = value;\n                            workInProgress.flags |= ShouldCapture;\n                            var lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n                            var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);\n                            enqueueCapturedUpdate(workInProgress, update);\n                            return;\n                        }\n                    case ClassComponent:\n                        // Capture and retry\n                        var errorInfo = value;\n                        var ctor = workInProgress.type;\n                        var instance = workInProgress.stateNode;\n                        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === \"function\" || instance !== null && typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state\n                            var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);\n                            enqueueCapturedUpdate(workInProgress, _update);\n                            return;\n                        }\n                        break;\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress !== null);\n        }\n        function getSuspendedCache() {\n            {\n                return null;\n            }\n        }\n        function markUpdate(workInProgress) {\n            // Tag the fiber with an update effect. This turns a Placement into\n            // a PlacementAndUpdate.\n            workInProgress.flags |= Update;\n        }\n        function markRef(workInProgress) {\n            workInProgress.flags |= Ref;\n            {\n                workInProgress.flags |= RefStatic;\n            }\n        }\n        function hadNoMutationsEffects(current, completedWork) {\n            var didBailout = current !== null && current.child === completedWork.child;\n            if (didBailout) {\n                return true;\n            }\n            if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n                return false;\n            } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n            // then we only have to check the `completedWork.subtreeFlags`.\n            var child = completedWork.child;\n            while(child !== null){\n                if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n                    return false;\n                }\n                child = child.sibling;\n            }\n            return true;\n        }\n        var appendAllChildren;\n        var updateHostContainer;\n        var updateHostComponent;\n        var updateHostText;\n        if (supportsMutation) {\n            // Mutation mode\n            appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent || node.tag === HostText) {\n                        appendInitialChild(parent, node.stateNode);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            };\n            updateHostContainer = function(current, workInProgress) {};\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps;\n                if (oldProps === newProps) {\n                    // In mutation mode, this is sufficient for a bailout because\n                    // we won't touch this node even if children changed.\n                    return;\n                } // If we get updated because one of our children updated, we don't\n                // have newProps so we'll have to reuse them.\n                // TODO: Split the update API as separate for the props vs. children.\n                // Even better would be if children weren't special cased at all tho.\n                var instance = workInProgress.stateNode;\n                var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n                // component is hitting the resume path. Figure out why. Possibly\n                // related to `hidden`.\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n                workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n                // is a new ref we mark this as an update. All the work is done in commitWork.\n                if (updatePayload) {\n                    markUpdate(workInProgress);\n                }\n            };\n            updateHostText = function(current, workInProgress, oldText, newText) {\n                // If the text differs, mark it as an update. All the work in done in commitWork.\n                if (oldText !== newText) {\n                    markUpdate(workInProgress);\n                }\n            };\n        } else if (supportsPersistence) {\n            // Persistent host tree mode\n            appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    // eslint-disable-next-line no-labels\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props, node);\n                        }\n                        appendInitialChild(parent, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance = cloneHiddenTextInstance(_instance, text, node);\n                        }\n                        appendInitialChild(parent, _instance);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        }\n                        {\n                            appendAllChildren(parent, node, true, true);\n                        }\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n            var appendAllChildrenToContainer = function(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    // eslint-disable-next-line no-labels\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props, node);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance2 = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance2 = cloneHiddenTextInstance(_instance2, text, node);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, _instance2);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        }\n                        {\n                            appendAllChildrenToContainer(containerChildSet, node, true, true);\n                        }\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            };\n            updateHostContainer = function(current, workInProgress) {\n                var portalOrRoot = workInProgress.stateNode;\n                var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n                if (childrenUnchanged) ;\n                else {\n                    var container = portalOrRoot.containerInfo;\n                    var newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n                    portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n                    markUpdate(workInProgress);\n                    finalizeContainerChildren(container, newChildSet);\n                }\n            };\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {\n                var currentInstance = current.stateNode;\n                var oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n                // This guarantees that we can reuse all of them.\n                var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n                if (childrenUnchanged && oldProps === newProps) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var recyclableInstance = workInProgress.stateNode;\n                var currentHostContext = getHostContext();\n                var updatePayload = null;\n                if (oldProps !== newProps) {\n                    updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n                }\n                if (childrenUnchanged && updatePayload === null) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n                if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n                    markUpdate(workInProgress);\n                }\n                workInProgress.stateNode = newInstance;\n                if (childrenUnchanged) {\n                    // If there are no other effects in this tree, we need to flag this node as having one.\n                    // Even though we're not going to use it for anything.\n                    // Otherwise parents won't know that there are new children to propagate upwards.\n                    markUpdate(workInProgress);\n                } else {\n                    // If children might have changed, we have to add them all to the set.\n                    appendAllChildren(newInstance, workInProgress, false, false);\n                }\n            };\n            updateHostText = function(current, workInProgress, oldText, newText) {\n                if (oldText !== newText) {\n                    // If the text content differs, we'll create a new text instance for it.\n                    var rootContainerInstance = getRootHostContainer();\n                    var currentHostContext = getHostContext();\n                    workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n                    // This lets the parents know that at least one of their children has changed.\n                    markUpdate(workInProgress);\n                } else {\n                    workInProgress.stateNode = current.stateNode;\n                }\n            };\n        } else {\n            // No host operations\n            updateHostContainer = function(current, workInProgress) {};\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {};\n            updateHostText = function(current, workInProgress, oldText, newText) {};\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n            if (getIsHydrating()) {\n                // If we're hydrating, we should consume as many items as we can\n                // so we don't leave any behind.\n                return;\n            }\n            switch(renderState.tailMode){\n                case \"hidden\":\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var tailNode = renderState.tail;\n                        var lastTailNode = null;\n                        while(tailNode !== null){\n                            if (tailNode.alternate !== null) {\n                                lastTailNode = tailNode;\n                            }\n                            tailNode = tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            renderState.tail = null;\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n                case \"collapsed\":\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var _tailNode = renderState.tail;\n                        var _lastTailNode = null;\n                        while(_tailNode !== null){\n                            if (_tailNode.alternate !== null) {\n                                _lastTailNode = _tailNode;\n                            }\n                            _tailNode = _tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (_lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            if (!hasRenderedATailFallback && renderState.tail !== null) {\n                                // We suspended during the head. We want to show at least one\n                                // row at the tail. So we'll keep on and cut off the rest.\n                                renderState.tail.sibling = null;\n                            } else {\n                                renderState.tail = null;\n                            }\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            _lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n            }\n        }\n        function bubbleProperties(completedWork) {\n            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n            var newChildLanes = NoLanes;\n            var subtreeFlags = NoFlags;\n            if (!didBailout) {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var actualDuration = completedWork.actualDuration;\n                    var treeBaseDuration = completedWork.selfBaseDuration;\n                    var child = completedWork.child;\n                    while(child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                        subtreeFlags |= child.subtreeFlags;\n                        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n                        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n                        // When work is done, it should bubble to the parent's actualDuration. If\n                        // the fiber has not been cloned though, (meaning no work was done), then\n                        // this value will reflect the amount of time spent working on a previous\n                        // render. In that case it should not bubble. We determine whether it was\n                        // cloned by comparing the child pointer.\n                        actualDuration += child.actualDuration;\n                        treeBaseDuration += child.treeBaseDuration;\n                        child = child.sibling;\n                    }\n                    completedWork.actualDuration = actualDuration;\n                    completedWork.treeBaseDuration = treeBaseDuration;\n                } else {\n                    var _child = completedWork.child;\n                    while(_child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                        subtreeFlags |= _child.subtreeFlags;\n                        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child.return = completedWork;\n                        _child = _child.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            } else {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var _treeBaseDuration = completedWork.selfBaseDuration;\n                    var _child2 = completedWork.child;\n                    while(_child2 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child2.flags & StaticMask;\n                        _treeBaseDuration += _child2.treeBaseDuration;\n                        _child2 = _child2.sibling;\n                    }\n                    completedWork.treeBaseDuration = _treeBaseDuration;\n                } else {\n                    var _child3 = completedWork.child;\n                    while(_child3 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child3.return = completedWork;\n                        _child3 = _child3.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            }\n            completedWork.childLanes = newChildLanes;\n            return didBailout;\n        }\n        function completeWork(current, workInProgress, renderLanes) {\n            var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case IndeterminateComponent:\n                case LazyComponent:\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                case ForwardRef:\n                case Fragment:\n                case Mode:\n                case Profiler:\n                case ContextConsumer:\n                case MemoComponent:\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            popContext(workInProgress);\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        var fiberRoot = workInProgress.stateNode;\n                        popHostContainer(workInProgress);\n                        popTopLevelContextObject(workInProgress);\n                        resetWorkInProgressVersions();\n                        if (fiberRoot.pendingContext) {\n                            fiberRoot.context = fiberRoot.pendingContext;\n                            fiberRoot.pendingContext = null;\n                        }\n                        if (current === null || current.child === null) {\n                            // If we hydrated, pop so that we can delete any remaining children\n                            // that weren't hydrated.\n                            var wasHydrated = popHydrationState(workInProgress);\n                            if (wasHydrated) {\n                                // If we hydrated, then we'll need to schedule an update for\n                                // the commit side-effects on the root.\n                                markUpdate(workInProgress);\n                            } else {\n                                if (current !== null) {\n                                    var prevState = current.memoizedState;\n                                    if (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                                    (workInProgress.flags & ForceClientRender) !== NoFlags) {\n                                        // Schedule an effect to clear this container at the start of the\n                                        // next commit. This handles the case of React rendering into a\n                                        // container with previous children. It's also safe to do for\n                                        // updates too, because current.child would only be null if the\n                                        // previous render was null (so the container would already\n                                        // be empty).\n                                        workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                                        // recoverable errors during first hydration attempt. If so, add\n                                        // them to a queue so we can log them in the commit phase.\n                                        upgradeHydrationErrorsToRecoverable();\n                                    }\n                                }\n                            }\n                        }\n                        updateHostContainer(current, workInProgress);\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(workInProgress);\n                        var rootContainerInstance = getRootHostContainer();\n                        var type = workInProgress.type;\n                        if (current !== null && workInProgress.stateNode != null) {\n                            updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n                            if (current.ref !== workInProgress.ref) {\n                                markRef(workInProgress);\n                            }\n                        } else {\n                            if (!newProps) {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error(\"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                                } // This can happen when we abort work.\n                                bubbleProperties(workInProgress);\n                                return null;\n                            }\n                            var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                            // \"stack\" as the parent. Then append children as we go in beginWork\n                            // or completeWork depending on whether we want to add them top->down or\n                            // bottom->up. Top->down is faster in IE11.\n                            var _wasHydrated = popHydrationState(workInProgress);\n                            if (_wasHydrated) {\n                                // TODO: Move this and createInstance step into the beginPhase\n                                // to consolidate.\n                                if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n                                    // If changes to the hydrated node need to be applied at the\n                                    // commit-phase we mark this as such.\n                                    markUpdate(workInProgress);\n                                }\n                            } else {\n                                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n                                appendAllChildren(instance, workInProgress, false, false);\n                                workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n                                // (eg DOM renderer supports auto-focus for certain elements).\n                                // Make sure such renderers get scheduled for later work.\n                                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                            if (workInProgress.ref !== null) {\n                                // If there is a ref on a host node we need to schedule a callback\n                                markRef(workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostText:\n                    {\n                        var newText = newProps;\n                        if (current && workInProgress.stateNode != null) {\n                            var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                            // to schedule a side-effect to do the updates.\n                            updateHostText(current, workInProgress, oldText, newText);\n                        } else {\n                            if (typeof newText !== \"string\") {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error(\"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                                } // This can happen when we abort work.\n                            }\n                            var _rootContainerInstance = getRootHostContainer();\n                            var _currentHostContext = getHostContext();\n                            var _wasHydrated2 = popHydrationState(workInProgress);\n                            if (_wasHydrated2) {\n                                if (prepareToHydrateHostTextInstance(workInProgress)) {\n                                    markUpdate(workInProgress);\n                                }\n                            } else {\n                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        var nextState = workInProgress.memoizedState;\n                        {\n                            if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n                                warnIfUnhydratedTailNodes(workInProgress);\n                                resetHydrationState();\n                                workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n                                return workInProgress;\n                            }\n                            if (nextState !== null && nextState.dehydrated !== null) {\n                                // We might be inside a hydration state the first time we're picking up this\n                                // Suspense boundary, and also after we've reentered it for further hydration.\n                                var _wasHydrated3 = popHydrationState(workInProgress);\n                                if (current === null) {\n                                    if (!_wasHydrated3) {\n                                        throw new Error(\"A dehydrated suspense component was completed without a hydrated node. \" + \"This is probably a bug in React.\");\n                                    }\n                                    prepareToHydrateHostSuspenseInstance(workInProgress);\n                                    bubbleProperties(workInProgress);\n                                    {\n                                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                            var isTimedOutSuspense = nextState !== null;\n                                            if (isTimedOutSuspense) {\n                                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                                var primaryChildFragment = workInProgress.child;\n                                                if (primaryChildFragment !== null) {\n                                                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return null;\n                                } else {\n                                    // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n                                    // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n                                    resetHydrationState();\n                                    if ((workInProgress.flags & DidCapture) === NoFlags) {\n                                        // This boundary did not suspend so it's now hydrated and unsuspended.\n                                        workInProgress.memoizedState = null;\n                                    } // If nothing suspended, we need to schedule an effect to mark this boundary\n                                    // as having hydrated so events know that they're free to be invoked.\n                                    // It's also a signal to replay events and the suspense callback.\n                                    // If something suspended, schedule an effect to attach retry listeners.\n                                    // So we might as well always mark this.\n                                    workInProgress.flags |= Update;\n                                    bubbleProperties(workInProgress);\n                                    {\n                                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                            var _isTimedOutSuspense = nextState !== null;\n                                            if (_isTimedOutSuspense) {\n                                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                                var _primaryChildFragment = workInProgress.child;\n                                                if (_primaryChildFragment !== null) {\n                                                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                                    workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return null;\n                                }\n                            } // Successfully completed this tree. If this was a forced client render,\n                            // there may have been recoverable errors during first hydration\n                            // attempt. If so, add them to a queue so we can log them in the\n                            // commit phase.\n                            upgradeHydrationErrorsToRecoverable();\n                        }\n                        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n                            // Something suspended. Re-render with the fallback children.\n                            workInProgress.lanes = renderLanes; // Do not reset the effect list.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            } // Don't bubble properties in this case.\n                            return workInProgress;\n                        }\n                        var nextDidTimeout = nextState !== null;\n                        var prevDidTimeout = false;\n                        if (current === null) {\n                            popHydrationState(workInProgress);\n                        } else {\n                            var _prevState = current.memoizedState;\n                            prevDidTimeout = _prevState !== null;\n                        }\n                        // an effect to toggle the subtree's visibility. When we switch from\n                        // fallback -> primary, the inner Offscreen fiber schedules this effect\n                        // as part of its normal complete phase. But when we switch from\n                        // primary -> fallback, the inner Offscreen fiber does not have a complete\n                        // phase. So we need to schedule its effect here.\n                        //\n                        // We also use this flag to connect/disconnect the effects, but the same\n                        // logic applies: when re-connecting, the Offscreen fiber's complete\n                        // phase will handle scheduling the effect. It's only when the fallback\n                        // is active that we have to do anything special.\n                        if (nextDidTimeout && !prevDidTimeout) {\n                            var _offscreenFiber = workInProgress.child;\n                            _offscreenFiber.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n                            // in the concurrent tree already suspended during this render.\n                            // This is a known bug.\n                            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n                                // TODO: Move this back to throwException because this is too late\n                                // if this is a large tree which is common for initial loads. We\n                                // don't know if we should restart a render or not until we get\n                                // this marker, and this is too late.\n                                // If this render already had a ping or lower pri updates,\n                                // and this is the first time we know we're going to suspend we\n                                // should be able to immediately restart from within throwException.\n                                var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n                                if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                                    // If this was in an invisible tree or a new render, then showing\n                                    // this boundary is ok.\n                                    renderDidSuspend();\n                                } else {\n                                    // Otherwise, we're going to have to hide content so we should\n                                    // suspend for longer if possible.\n                                    renderDidSuspendDelayIfPossible();\n                                }\n                            }\n                        }\n                        var wakeables = workInProgress.updateQueue;\n                        if (wakeables !== null) {\n                            // Schedule an effect to attach a retry listener to the promise.\n                            // TODO: Move to passive phase\n                            workInProgress.flags |= Update;\n                        }\n                        bubbleProperties(workInProgress);\n                        {\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                if (nextDidTimeout) {\n                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                    var _primaryChildFragment2 = workInProgress.child;\n                                    if (_primaryChildFragment2 !== null) {\n                                        // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                        workInProgress.treeBaseDuration -= _primaryChildFragment2.treeBaseDuration;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    updateHostContainer(current, workInProgress);\n                    if (current === null) {\n                        preparePortalMount(workInProgress.stateNode.containerInfo);\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ContextProvider:\n                    // Pop provider fiber\n                    var context = workInProgress.type._context;\n                    popProvider(context, workInProgress);\n                    bubbleProperties(workInProgress);\n                    return null;\n                case IncompleteClassComponent:\n                    {\n                        // Same as class component case. I put it down here so that the tags are\n                        // sequential to ensure this switch is compiled to a jump table.\n                        var _Component = workInProgress.type;\n                        if (isContextProvider(_Component)) {\n                            popContext(workInProgress);\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState === null) {\n                            // We're running in the default, \"independent\" mode.\n                            // We don't do anything in this mode.\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n                        var renderedTail = renderState.rendering;\n                        if (renderedTail === null) {\n                            // We just rendered the head.\n                            if (!didSuspendAlready) {\n                                // This is the first pass. We need to figure out if anything is still\n                                // suspended in the rendered set.\n                                // If new content unsuspended, but there's still some content that\n                                // didn't. Then we need to do a second pass that forces everything\n                                // to keep showing their fallbacks.\n                                // We might be suspended if something in this render pass suspended, or\n                                // something in the previous committed pass suspended. Otherwise,\n                                // there's no chance so we can skip the expensive call to\n                                // findFirstSuspended.\n                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n                                if (!cannotBeSuspended) {\n                                    var row = workInProgress.child;\n                                    while(row !== null){\n                                        var suspended = findFirstSuspended(row);\n                                        if (suspended !== null) {\n                                            didSuspendAlready = true;\n                                            workInProgress.flags |= DidCapture;\n                                            cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                                            // part of the second pass. In that case nothing will subscribe to\n                                            // its thenables. Instead, we'll transfer its thenables to the\n                                            // SuspenseList so that it can retry if they resolve.\n                                            // There might be multiple of these in the list but since we're\n                                            // going to wait for all of them anyway, it doesn't really matter\n                                            // which ones gets to ping. In theory we could get clever and keep\n                                            // track of how many dependencies remain but it gets tricky because\n                                            // in the meantime, we can add/remove/change items and dependencies.\n                                            // We might bail out of the loop before finding any but that\n                                            // doesn't matter since that means that the other boundaries that\n                                            // we did find already has their listeners attached.\n                                            var newThenables = suspended.updateQueue;\n                                            if (newThenables !== null) {\n                                                workInProgress.updateQueue = newThenables;\n                                                workInProgress.flags |= Update;\n                                            } // Rerender the whole list, but this time, we'll force fallbacks\n                                            // to stay in place.\n                                            // Reset the effect flags before doing the second pass since that's now invalid.\n                                            // Reset the child fibers to their original state.\n                                            workInProgress.subtreeFlags = NoFlags;\n                                            resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n                                            // rerender the children.\n                                            pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n                                            return workInProgress.child;\n                                        }\n                                        row = row.sibling;\n                                    }\n                                }\n                                if (renderState.tail !== null && now$1() > getRenderTargetTime()) {\n                                    // We have already passed our CPU deadline but we still have rows\n                                    // left in the tail. We'll just give up further attempts to render\n                                    // the main content and only render fallbacks.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            } else {\n                                cutOffTailIfNeeded(renderState, false);\n                            } // Next we're going to render the tail.\n                        } else {\n                            // Append the rendered row to the child list.\n                            if (!didSuspendAlready) {\n                                var _suspended = findFirstSuspended(renderedTail);\n                                if (_suspended !== null) {\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n                                    // get lost if this row ends up dropped during a second pass.\n                                    var _newThenables = _suspended.updateQueue;\n                                    if (_newThenables !== null) {\n                                        workInProgress.updateQueue = _newThenables;\n                                        workInProgress.flags |= Update;\n                                    }\n                                    cutOffTailIfNeeded(renderState, true); // This might have been modified.\n                                    if (renderState.tail === null && renderState.tailMode === \"hidden\" && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n                                    ) {\n                                        // We're done.\n                                        bubbleProperties(workInProgress);\n                                        return null;\n                                    }\n                                } else if (// time we have to render. So rendering one more row would likely\n                                // exceed it.\n                                now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n                                    // We have now passed our CPU deadline and we'll just give up further\n                                    // attempts to render the main content and only render fallbacks.\n                                    // The assumption is that this is usually faster.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            }\n                            if (renderState.isBackwards) {\n                                // The effect list of the backwards tail will have been added\n                                // to the end. This breaks the guarantee that life-cycles fire in\n                                // sibling order but that isn't a strong guarantee promised by React.\n                                // Especially since these might also just pop in during future commits.\n                                // Append to the beginning of the list.\n                                renderedTail.sibling = workInProgress.child;\n                                workInProgress.child = renderedTail;\n                            } else {\n                                var previousSibling = renderState.last;\n                                if (previousSibling !== null) {\n                                    previousSibling.sibling = renderedTail;\n                                } else {\n                                    workInProgress.child = renderedTail;\n                                }\n                                renderState.last = renderedTail;\n                            }\n                        }\n                        if (renderState.tail !== null) {\n                            // We still have tail rows to render.\n                            // Pop a row.\n                            var next = renderState.tail;\n                            renderState.rendering = next;\n                            renderState.tail = next.sibling;\n                            renderState.renderingStartTime = now$1();\n                            next.sibling = null; // Restore the context.\n                            // TODO: We can probably just avoid popping it instead and only\n                            // setting it the first time we go from not suspended to suspended.\n                            var suspenseContext = suspenseStackCursor.current;\n                            if (didSuspendAlready) {\n                                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n                            } else {\n                                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n                            }\n                            pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n                            // Don't bubble properties in this case.\n                            return next;\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popRenderLanes(workInProgress);\n                        var _nextState = workInProgress.memoizedState;\n                        var nextIsHidden = _nextState !== null;\n                        if (current !== null) {\n                            var _prevState2 = current.memoizedState;\n                            var prevIsHidden = _prevState2 !== null;\n                            if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {\n                                workInProgress.flags |= Visibility;\n                            }\n                        }\n                        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n                            bubbleProperties(workInProgress);\n                        } else {\n                            // Don't bubble properties for hidden children unless we're rendering\n                            // at offscreen priority.\n                            if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n                                bubbleProperties(workInProgress);\n                                if (supportsMutation) {\n                                    // Check if there was an insertion or update in the hidden subtree.\n                                    // If so, we need to hide those nodes in the commit phase, so\n                                    // schedule a visibility effect.\n                                    if (workInProgress.subtreeFlags & (Placement | Update)) {\n                                        workInProgress.flags |= Visibility;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        return null;\n                    }\n                case TracingMarkerComponent:\n                    {\n                        return null;\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutModulePatternComponent;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutFunctionRefs;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        {\n            didWarnAboutBadClass = {};\n            didWarnAboutModulePatternComponent = {};\n            didWarnAboutContextTypeOnFunctionComponent = {};\n            didWarnAboutGetDerivedStateOnFunctionComponent = {};\n            didWarnAboutFunctionRefs = {};\n            didWarnAboutReassigningProps = false;\n            didWarnAboutRevealOrder = {};\n            didWarnAboutTailOptions = {};\n        }\n        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n            if (current === null) {\n                // If this is a fresh new component that hasn't been rendered yet, we\n                // won't update its child set by applying minimal side-effects. Instead,\n                // we will add them all to the child before it gets rendered. That means\n                // we can optimize this reconciliation pass by not tracking side-effects.\n                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                // If the current child is the same as the work in progress, it means that\n                // we haven't yet started any work on these children. Therefore, we use\n                // the clone algorithm to create a copy of all the current children.\n                // If we had any progressed work already, that is invalid at this point so\n                // let's throw it out.\n                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n            }\n        }\n        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n            // This function is fork of reconcileChildren. It's used in cases where we\n            // want to reconcile without matching against the existing set. This has the\n            // effect of all current children being unmounted; even if the type and key\n            // are the same, the old child is unmounted and a new child is created.\n            //\n            // To do this, we're going to go through the reconcile algorithm twice. In\n            // the first pass, we schedule a deletion for all the current children by\n            // passing null.\n            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n            // pass null in place of where we usually pass the current child set. This has\n            // the effect of remounting all children regardless of whether their\n            // identities match.\n            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n        }\n        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens after the first render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            var render = Component.render;\n            var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n                hasId = checkDidRenderIdHook();\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n                        hasId = checkDidRenderIdHook();\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            if (current === null) {\n                var type = Component.type;\n                if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n                Component.defaultProps === undefined) {\n                    var resolvedType = type;\n                    {\n                        resolvedType = resolveFunctionForHotReloading(type);\n                    }\n                    // and with only the default shallow comparison, we upgrade it\n                    // to a SimpleMemoComponent to allow fast path updates.\n                    workInProgress.tag = SimpleMemoComponent;\n                    workInProgress.type = resolvedType;\n                    {\n                        validateFunctionComponentInDev(workInProgress, type);\n                    }\n                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n                }\n                {\n                    var innerPropTypes = type.propTypes;\n                    if (innerPropTypes) {\n                        // Inner memo component props aren't currently validated in createElement.\n                        // We could move it there, but we'd still need this for lazy code path.\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(type));\n                    }\n                }\n                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n                child.ref = workInProgress.ref;\n                child.return = workInProgress;\n                workInProgress.child = child;\n                return child;\n            }\n            {\n                var _type = Component.type;\n                var _innerPropTypes = _type.propTypes;\n                if (_innerPropTypes) {\n                    // Inner memo component props aren't currently validated in createElement.\n                    // We could move it there, but we'd still need this for lazy code path.\n                    checkPropTypes(_innerPropTypes, nextProps, \"prop\", getComponentNameFromType(_type));\n                }\n            }\n            var currentChild = current.child; // This is always exactly one child\n            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n            if (!hasScheduledUpdateOrContext) {\n                // This will be the props with resolved defaultProps,\n                // unlike current.memoizedProps which will be the unresolved ones.\n                var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n                var compare = Component.compare;\n                compare = compare !== null ? compare : shallowEqual;\n                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            var newChild = createWorkInProgress(currentChild, nextProps);\n            newChild.ref = workInProgress.ref;\n            newChild.return = workInProgress;\n            workInProgress.child = newChild;\n            return newChild;\n        }\n        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens when the inner render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var outerMemoType = workInProgress.elementType;\n                    if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n                        // We warn when you define propTypes on lazy()\n                        // so let's just skip over it to find memo() outer wrapper.\n                        // Inner props for memo are validated later.\n                        var lazyComponent = outerMemoType;\n                        var payload = lazyComponent._payload;\n                        var init = lazyComponent._init;\n                        try {\n                            outerMemoType = init(payload);\n                        } catch (x) {\n                            outerMemoType = null;\n                        } // Inner propTypes will be validated in the function component path.\n                        var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n                        if (outerPropTypes) {\n                            checkPropTypes(outerPropTypes, nextProps, \"prop\", getComponentNameFromType(outerMemoType));\n                        }\n                    }\n                }\n            }\n            if (current !== null) {\n                var prevProps = current.memoizedProps;\n                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {\n                    didReceiveUpdate = false;\n                    if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n                        // The pending lanes were cleared at the beginning of beginWork. We're\n                        // about to bail out, but there might be other lanes that weren't\n                        // included in the current render. Usually, the priority level of the\n                        // remaining updates is accumulated during the evaluation of the\n                        // component (i.e. when processing the update queue). But since since\n                        // we're bailing out early *without* evaluating the component, we need\n                        // to account for it here, too. Reset to the value of the current fiber.\n                        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n                        // because a MemoComponent fiber does not have hooks or an update queue;\n                        // rather, it wraps around an inner component, which may or may not\n                        // contains hooks.\n                        // TODO: Move the reset at in beginWork out of the common path so that\n                        // this is no longer necessary.\n                        workInProgress.lanes = current.lanes;\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    }\n                }\n            }\n            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n        }\n        function updateOffscreenComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            var prevState = current !== null ? current.memoizedState : null;\n            if (nextProps.mode === \"hidden\" || enableLegacyHidden) {\n                // Rendering a hidden tree.\n                if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                    // In legacy sync mode, don't defer the subtree. Render it now.\n                    var nextState = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = nextState;\n                    pushRenderLanes(workInProgress, renderLanes);\n                } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n                    var spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out\n                    // and resume this tree later.\n                    var nextBaseLanes;\n                    if (prevState !== null) {\n                        var prevBaseLanes = prevState.baseLanes;\n                        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n                    } else {\n                        nextBaseLanes = renderLanes;\n                    } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n                    var _nextState = {\n                        baseLanes: nextBaseLanes,\n                        cachePool: spawnedCachePool\n                    };\n                    workInProgress.memoizedState = _nextState;\n                    workInProgress.updateQueue = null;\n                    // to avoid a push/pop misalignment.\n                    pushRenderLanes(workInProgress, nextBaseLanes);\n                    return null;\n                } else {\n                    // This is the second render. The surrounding visible content has already\n                    // committed. Now we resume rendering the hidden tree.\n                    // Rendering at offscreen, so we can clear the base lanes.\n                    var _nextState2 = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.\n                    var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n                    pushRenderLanes(workInProgress, subtreeRenderLanes);\n                }\n            } else {\n                // Rendering a visible tree.\n                var _subtreeRenderLanes;\n                if (prevState !== null) {\n                    // We're going from hidden -> visible.\n                    _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n                    workInProgress.memoizedState = null;\n                } else {\n                    // We weren't previously hidden, and we still aren't, so there's nothing\n                    // special to do. Need to push to the stack regardless, though, to avoid\n                    // a push/pop misalignment.\n                    _subtreeRenderLanes = renderLanes;\n                }\n                pushRenderLanes(workInProgress, _subtreeRenderLanes);\n            }\n            {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n                return workInProgress.child;\n            }\n        }\n        function updateFragment(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMode(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateProfiler(current, workInProgress, renderLanes) {\n            {\n                workInProgress.flags |= Update;\n                {\n                    // Reset effect durations for the next eventual effect phase.\n                    // These are reset during render to allow the DevTools commit hook a chance to read them,\n                    var stateNode = workInProgress.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                }\n            }\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markRef$1(current, workInProgress) {\n            var ref = workInProgress.ref;\n            if (current === null && ref !== null || current !== null && current.ref !== ref) {\n                // Schedule a Ref effect\n                workInProgress.flags |= Ref;\n                {\n                    workInProgress.flags |= RefStatic;\n                }\n            }\n        }\n        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            var context;\n            {\n                var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n                context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                        hasId = checkDidRenderIdHook();\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                // This is used by DevTools to force a boundary to error.\n                switch(shouldError(workInProgress)){\n                    case false:\n                        {\n                            var _instance = workInProgress.stateNode;\n                            var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n                            // Is there a better way to do this?\n                            var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n                            var state = tempInstance.state;\n                            _instance.updater.enqueueSetState(_instance, state, null);\n                            break;\n                        }\n                    case true:\n                        {\n                            workInProgress.flags |= DidCapture;\n                            workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n                            var error$1 = new Error(\"Simulated error coming from DevTools\");\n                            var lane = pickArbitraryLane(renderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n                            var update = createClassErrorUpdate(workInProgress, createCapturedValue(error$1, workInProgress), lane);\n                            enqueueCapturedUpdate(workInProgress, update);\n                            break;\n                        }\n                }\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider(Component)) {\n                hasContext = true;\n                pushContextProvider(workInProgress);\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var instance = workInProgress.stateNode;\n            var shouldUpdate;\n            if (instance === null) {\n                if (current !== null) {\n                    // A class component without an instance only mounts if it suspended\n                    // inside a non-concurrent tree, in an inconsistent state. We want to\n                    // treat it like a new mount, even though an empty version of it already\n                    // committed. Disconnect the alternate pointers.\n                    current.alternate = null;\n                    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                    workInProgress.flags |= Placement;\n                } // In the initial pass we might need to construct the instance.\n                constructClassInstance(workInProgress, Component, nextProps);\n                mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n                shouldUpdate = true;\n            } else if (current === null) {\n                // In a resume, we'll already have an instance we can reuse.\n                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            } else {\n                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n            }\n            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n            {\n                var inst = workInProgress.stateNode;\n                if (shouldUpdate && inst.props !== nextProps) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            return nextUnitOfWork;\n        }\n        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n            // Refs should update even if shouldComponentUpdate returns false\n            markRef$1(current, workInProgress);\n            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n            if (!shouldUpdate && !didCaptureError) {\n                // Context providers should defer to sCU for rendering\n                if (hasContext) {\n                    invalidateContextProvider(workInProgress, Component, false);\n                }\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            var instance = workInProgress.stateNode; // Rerender\n            ReactCurrentOwner$1.current = workInProgress;\n            var nextChildren;\n            if (didCaptureError && typeof Component.getDerivedStateFromError !== \"function\") {\n                // If we captured an error, but getDerivedStateFromError is not defined,\n                // unmount all the children. componentDidCatch will schedule an update to\n                // re-render a fallback. This is temporary until we migrate everyone to\n                // the new API.\n                // TODO: Warn in a future release.\n                nextChildren = null;\n                {\n                    stopProfilerTimerIfRunning();\n                }\n            } else {\n                {\n                    markComponentRenderStarted(workInProgress);\n                }\n                {\n                    setIsRendering(true);\n                    nextChildren = instance.render();\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            instance.render();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    setIsRendering(false);\n                }\n                {\n                    markComponentRenderStopped();\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            if (current !== null && didCaptureError) {\n                // If we're recovering from an error, reconcile without reusing any of\n                // the existing children. Conceptually, the normal children and the children\n                // that are shown on error are two different sets, so we shouldn't reuse\n                // normal children even if their identities match.\n                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            } // Memoize state using the values we just used to render.\n            // TODO: Restructure so we never read values from the instance.\n            workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n            if (hasContext) {\n                invalidateContextProvider(workInProgress, Component, true);\n            }\n            return workInProgress.child;\n        }\n        function pushHostRootContext(workInProgress) {\n            var root = workInProgress.stateNode;\n            if (root.pendingContext) {\n                pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n            } else if (root.context) {\n                // Should always be set\n                pushTopLevelContextObject(workInProgress, root.context, false);\n            }\n            pushHostContainer(workInProgress, root.containerInfo);\n        }\n        function updateHostRoot(current, workInProgress, renderLanes) {\n            pushHostRootContext(workInProgress);\n            if (current === null) {\n                throw new Error(\"Should have a current fiber. This is a bug in React.\");\n            }\n            var nextProps = workInProgress.pendingProps;\n            var prevState = workInProgress.memoizedState;\n            var prevChildren = prevState.element;\n            cloneUpdateQueue(current, workInProgress);\n            processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n            var nextState = workInProgress.memoizedState;\n            var root = workInProgress.stateNode;\n            // being called \"element\".\n            var nextChildren = nextState.element;\n            if (supportsHydration && prevState.isDehydrated) {\n                // This is a hydration root whose shell has not yet hydrated. We should\n                // attempt to hydrate.\n                // Flip isDehydrated to false to indicate that when this render\n                // finishes, the root will no longer be dehydrated.\n                var overrideState = {\n                    element: nextChildren,\n                    isDehydrated: false,\n                    cache: nextState.cache,\n                    transitions: nextState.transitions\n                };\n                var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n                // have reducer functions so it doesn't need rebasing.\n                updateQueue.baseState = overrideState;\n                workInProgress.memoizedState = overrideState;\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during a previous attempt to hydrate the shell, so we\n                    // forced a client render.\n                    var recoverableError = new Error(\"There was an error while hydrating. Because the error happened outside \" + \"of a Suspense boundary, the entire root will switch to \" + \"client rendering.\");\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n                } else if (nextChildren !== prevChildren) {\n                    var _recoverableError = new Error(\"This root received an early update, before anything was able \" + \"hydrate. Switched the entire root to client rendering.\");\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);\n                } else {\n                    // The outermost shell has not hydrated yet. Start hydrating.\n                    enterHydrationState(workInProgress);\n                    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n                    workInProgress.child = child;\n                    var node = child;\n                    while(node){\n                        // Mark each child as hydrating. This is a fast path to know whether this\n                        // tree is part of a hydrating tree. This is used to determine if a child\n                        // node has fully mounted yet, and for scheduling event replaying.\n                        // Conceptually this is similar to Placement in that a new subtree is\n                        // inserted into the React tree here. It just happens to not need DOM\n                        // mutations because it already exists.\n                        node.flags = node.flags & ~Placement | Hydrating;\n                        node = node.sibling;\n                    }\n                }\n            } else {\n                // Root is not dehydrated. Either this is a client-only root, or it\n                // already hydrated.\n                resetHydrationState();\n                if (nextChildren === prevChildren) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n            // Revert to client rendering.\n            resetHydrationState();\n            queueHydrationError(recoverableError);\n            workInProgress.flags |= ForceClientRender;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostComponent$1(current, workInProgress, renderLanes) {\n            pushHostContext(workInProgress);\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            }\n            var type = workInProgress.type;\n            var nextProps = workInProgress.pendingProps;\n            var prevProps = current !== null ? current.memoizedProps : null;\n            var nextChildren = nextProps.children;\n            var isDirectTextChild = shouldSetTextContent(type, nextProps);\n            if (isDirectTextChild) {\n                // We special case a direct text child of a host node. This is a common\n                // case. We won't handle it as a reified child. We will instead handle\n                // this in the host environment that also has access to this prop. That\n                // avoids allocating another HostText fiber and traversing it.\n                nextChildren = null;\n            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n                // If we're switching from a direct text child to a normal child, or to\n                // empty, we need to schedule the text content to be reset.\n                workInProgress.flags |= ContentReset;\n            }\n            markRef$1(current, workInProgress);\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostText$1(current, workInProgress) {\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            } // Nothing to do here. This is terminal. We'll do the completion step\n            // immediately after.\n            return null;\n        }\n        function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n            if (_current !== null) {\n                // A lazy component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            }\n            var props = workInProgress.pendingProps;\n            var lazyComponent = elementType;\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload); // Store the unwrapped component in the type.\n            workInProgress.type = Component;\n            var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            var child;\n            switch(resolvedTag){\n                case FunctionComponent:\n                    {\n                        {\n                            validateFunctionComponentInDev(workInProgress, Component);\n                            workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n                        }\n                        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case ClassComponent:\n                    {\n                        {\n                            workInProgress.type = Component = resolveClassForHotReloading(Component);\n                        }\n                        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case ForwardRef:\n                    {\n                        {\n                            workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n                        }\n                        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case MemoComponent:\n                    {\n                        {\n                            if (workInProgress.type !== workInProgress.elementType) {\n                                var outerPropTypes = Component.propTypes;\n                                if (outerPropTypes) {\n                                    checkPropTypes(outerPropTypes, resolvedProps, \"prop\", getComponentNameFromType(Component));\n                                }\n                            }\n                        }\n                        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), renderLanes);\n                        return child;\n                    }\n            }\n            var hint = \"\";\n            {\n                if (Component !== null && typeof Component === \"object\" && Component.$$typeof === REACT_LAZY_TYPE) {\n                    hint = \" Did you wrap a component in React.lazy() more than once?\";\n                }\n            }\n            // because the fact that it's a separate type of work is an\n            // implementation detail.\n            throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n            if (_current !== null) {\n                // An incomplete component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            } // Promote the fiber to a class and try rendering again.\n            workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n            // Push context providers early to prevent context stack mismatches.\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider(Component)) {\n                hasContext = true;\n                pushContextProvider(workInProgress);\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            constructClassInstance(workInProgress, Component, nextProps);\n            mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n        }\n        function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n            if (_current !== null) {\n                // An indeterminate component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            }\n            var props = workInProgress.pendingProps;\n            var context;\n            {\n                var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n                context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var value;\n            var hasId;\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n                }\n                setIsRendering(true);\n                ReactCurrentOwner$1.current = workInProgress;\n                value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n                // During mounting we don't know the child context yet as the instance doesn't exist.\n                // We will invalidate the child context in finishClassComponent() right after rendering.\n                var hasContext = false;\n                if (isContextProvider(Component)) {\n                    hasContext = true;\n                    pushContextProvider(workInProgress);\n                } else {\n                    hasContext = false;\n                }\n                workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n                initializeUpdateQueue(workInProgress);\n                adoptClassInstance(workInProgress, value);\n                mountClassInstance(workInProgress, Component, props, renderLanes);\n                return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n            } else {\n                // Proceed under the assumption that this is a function component\n                workInProgress.tag = FunctionComponent;\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n                            hasId = checkDidRenderIdHook();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                }\n                if (getIsHydrating() && hasId) {\n                    pushMaterializedTreeId(workInProgress);\n                }\n                reconcileChildren(null, workInProgress, value, renderLanes);\n                {\n                    validateFunctionComponentInDev(workInProgress, Component);\n                }\n                return workInProgress.child;\n            }\n        }\n        function validateFunctionComponentInDev(workInProgress, Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (workInProgress.ref !== null) {\n                    var info = \"\";\n                    var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n                    if (ownerName) {\n                        info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                    }\n                    var warningKey = ownerName || \"\";\n                    var debugSource = workInProgress._debugSource;\n                    if (debugSource) {\n                        warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n                    }\n                    if (!didWarnAboutFunctionRefs[warningKey]) {\n                        didWarnAboutFunctionRefs[warningKey] = true;\n                        error(\"Function components cannot be given refs. \" + \"Attempts to access this ref will fail. \" + \"Did you mean to use React.forwardRef()?%s\", info);\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        var SUSPENDED_MARKER = {\n            dehydrated: null,\n            treeContext: null,\n            retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes) {\n            return {\n                baseLanes: renderLanes,\n                cachePool: getSuspendedCache()\n            };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n            var cachePool = null;\n            return {\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n                cachePool: cachePool\n            };\n        } // TODO: Probably should inline this back\n        function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n            // If we're already showing a fallback, there are cases where we need to\n            // remain on that fallback regardless of whether the content has resolved.\n            // For example, SuspenseList coordinates when nested content appears.\n            if (current !== null) {\n                var suspenseState = current.memoizedState;\n                if (suspenseState === null) {\n                    // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n                    // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n                    // Note: This is a factoring smell. Can't remain on a fallback if there's\n                    // no fallback to remain on.\n                    return false;\n                }\n            } // Not currently showing content. Consult the Suspense context.\n            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current, renderLanes) {\n            // TODO: Should not remove render lanes that were pinged during this render\n            return removeLanes(current.childLanes, renderLanes);\n        }\n        function updateSuspenseComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n            {\n                if (shouldSuspend(workInProgress)) {\n                    workInProgress.flags |= DidCapture;\n                }\n            }\n            var suspenseContext = suspenseStackCursor.current;\n            var showFallback = false;\n            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n            if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {\n                // Something in this boundary's subtree already suspended. Switch to\n                // rendering the fallback children.\n                showFallback = true;\n                workInProgress.flags &= ~DidCapture;\n            } else {\n                // Attempting the main content\n                if (current === null || current.memoizedState !== null) {\n                    // This is a new mount or this boundary is already showing a fallback state.\n                    // Mark this subtree context as having at least one invisible parent that could\n                    // handle the fallback state.\n                    // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n                    {\n                        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n                    }\n                }\n            }\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n            pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n            // boundary's children. This involves some custom reconciliation logic. Two\n            // main reasons this is so complicated.\n            //\n            // First, Legacy Mode has different semantics for backwards compatibility. The\n            // primary tree will commit in an inconsistent state, so when we do the\n            // second pass to render the fallback, we do some exceedingly, uh, clever\n            // hacks to make that not totally break. Like transferring effects and\n            // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n            // because we bailout on the primary tree completely and leave it in its old\n            // state, no effects. Same as what we do for Offscreen (except that\n            // Offscreen doesn't have the first render pass).\n            //\n            // Second is hydration. During hydration, the Suspense fiber has a slightly\n            // different layout, where the child points to a dehydrated fragment, which\n            // contains the DOM rendered by the server.\n            //\n            // Third, even if you set all that aside, Suspense is like error boundaries in\n            // that we first we try to render one tree, and if that fails, we render again\n            // and switch to a different tree. Like a try/catch block. So we have to track\n            // which branch we're currently rendering. Ideally we would model this using\n            // a stack.\n            if (current === null) {\n                // Initial mount\n                // If we're currently hydrating, try to hydrate this boundary.\n                tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n                {\n                    var suspenseState = workInProgress.memoizedState;\n                    if (suspenseState !== null) {\n                        var dehydrated = suspenseState.dehydrated;\n                        if (dehydrated !== null) {\n                            return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n                        }\n                    }\n                }\n                var nextPrimaryChildren = nextProps.children;\n                var nextFallbackChildren = nextProps.fallback;\n                if (showFallback) {\n                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var primaryChildFragment = workInProgress.child;\n                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackFragment;\n                } else {\n                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n                }\n            } else {\n                // This is an update.\n                // If the current fiber has a SuspenseState, that means it's already showing\n                // a fallback.\n                var prevState = current.memoizedState;\n                if (prevState !== null) {\n                    // The current tree is already showing a fallback\n                    // Special path for hydration\n                    {\n                        var _dehydrated = prevState.dehydrated;\n                        if (_dehydrated !== null) {\n                            if (!didSuspend) {\n                                return updateDehydratedSuspenseComponent(current, workInProgress, _dehydrated, prevState, renderLanes);\n                            } else if (workInProgress.flags & ForceClientRender) {\n                                // Something errored during hydration. Try again without hydrating.\n                                workInProgress.flags &= ~ForceClientRender;\n                                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error(\"There was an error while hydrating this Suspense boundary. \" + \"Switched to client rendering.\"));\n                            } else if (workInProgress.memoizedState !== null) {\n                                // Something suspended and we should still be in dehydrated mode.\n                                // Leave the existing child in place.\n                                workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n                                // but the normal suspense pass doesn't.\n                                workInProgress.flags |= DidCapture;\n                                return null;\n                            } else {\n                                // Suspended but we should no longer be in dehydrated mode.\n                                // Therefore we now have to render the fallback.\n                                var _nextPrimaryChildren = nextProps.children;\n                                var _nextFallbackChildren = nextProps.fallback;\n                                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n                                var _primaryChildFragment2 = workInProgress.child;\n                                _primaryChildFragment2.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                                workInProgress.memoizedState = SUSPENDED_MARKER;\n                                return fallbackChildFragment;\n                            }\n                        }\n                    }\n                    if (showFallback) {\n                        var _nextFallbackChildren2 = nextProps.fallback;\n                        var _nextPrimaryChildren2 = nextProps.children;\n                        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);\n                        var _primaryChildFragment3 = workInProgress.child;\n                        var prevOffscreenState = current.child.memoizedState;\n                        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n                        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n                        workInProgress.memoizedState = SUSPENDED_MARKER;\n                        return _fallbackChildFragment;\n                    } else {\n                        var _nextPrimaryChildren3 = nextProps.children;\n                        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);\n                        workInProgress.memoizedState = null;\n                        return _primaryChildFragment4;\n                    }\n                } else {\n                    // The current tree is not already showing a fallback.\n                    if (showFallback) {\n                        // Timed out.\n                        var _nextFallbackChildren3 = nextProps.fallback;\n                        var _nextPrimaryChildren4 = nextProps.children;\n                        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);\n                        var _primaryChildFragment5 = workInProgress.child;\n                        var _prevOffscreenState = current.child.memoizedState;\n                        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);\n                        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the\n                        // fallback children.\n                        workInProgress.memoizedState = SUSPENDED_MARKER;\n                        return _fallbackChildFragment2;\n                    } else {\n                        // Still haven't timed out. Continue rendering the children, like we\n                        // normally do.\n                        var _nextPrimaryChildren5 = nextProps.children;\n                        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);\n                        workInProgress.memoizedState = null;\n                        return _primaryChildFragment6;\n                    }\n                }\n            }\n        }\n        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: \"visible\",\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            primaryChildFragment.return = workInProgress;\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var progressedPrimaryFragment = workInProgress.child;\n            var primaryChildProps = {\n                mode: \"hidden\",\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            var fallbackChildFragment;\n            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n                // In legacy mode, we commit the primary tree as if it successfully\n                // completed, even though it's in an inconsistent state.\n                primaryChildFragment = progressedPrimaryFragment;\n                primaryChildFragment.childLanes = NoLanes;\n                primaryChildFragment.pendingProps = primaryChildProps;\n                if (workInProgress.mode & ProfileMode) {\n                    // Reset the durations from the first pass so they aren't included in the\n                    // final amounts. This seems counterintuitive, since we're intentionally\n                    // not measuring part of the render phase, but this makes it match what we\n                    // do in Concurrent Mode.\n                    primaryChildFragment.actualDuration = 0;\n                    primaryChildFragment.actualStartTime = -1;\n                    primaryChildFragment.selfBaseDuration = 0;\n                    primaryChildFragment.treeBaseDuration = 0;\n                }\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            } else {\n                primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            }\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n            // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n            // this wrapper function to constrain it.\n            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n            // The props argument to `createWorkInProgress` is `any` typed, so we use this\n            // wrapper function to constrain it.\n            return createWorkInProgress(current, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n                mode: \"visible\",\n                children: primaryChildren\n            });\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                primaryChildFragment.lanes = renderLanes;\n            }\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = null;\n            if (currentFallbackChildFragment !== null) {\n                // Delete the fallback child fragment\n                var deletions = workInProgress.deletions;\n                if (deletions === null) {\n                    workInProgress.deletions = [\n                        currentFallbackChildFragment\n                    ];\n                    workInProgress.flags |= ChildDeletion;\n                } else {\n                    deletions.push(currentFallbackChildFragment);\n                }\n            }\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildProps = {\n                mode: \"hidden\",\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            if (// completed, even though it's in an inconsistent state.\n            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n            // already cloned. In legacy mode, the only case where this isn't true is\n            // when DevTools forces us to display a fallback; we skip the first render\n            // pass entirely and go straight to rendering the fallback. (In Concurrent\n            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n            // only codepath.)\n            workInProgress.child !== currentPrimaryChildFragment) {\n                var progressedPrimaryFragment = workInProgress.child;\n                primaryChildFragment = progressedPrimaryFragment;\n                primaryChildFragment.childLanes = NoLanes;\n                primaryChildFragment.pendingProps = primaryChildProps;\n                if (workInProgress.mode & ProfileMode) {\n                    // Reset the durations from the first pass so they aren't included in the\n                    // final amounts. This seems counterintuitive, since we're intentionally\n                    // not measuring part of the render phase, but this makes it match what we\n                    // do in Concurrent Mode.\n                    primaryChildFragment.actualDuration = 0;\n                    primaryChildFragment.actualStartTime = -1;\n                    primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n                    primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n                }\n                // However, since we're going to remain on the fallback, we no longer want\n                // to delete it.\n                workInProgress.deletions = null;\n            } else {\n                primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n                // (We don't do this in legacy mode, because in legacy mode we don't re-use\n                // the current tree; see previous branch.)\n                primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n            }\n            var fallbackChildFragment;\n            if (currentFallbackChildFragment !== null) {\n                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n            } else {\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n                // mounted but this is a new fiber.\n                fallbackChildFragment.flags |= Placement;\n            }\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n            // Falling back to client rendering. Because this has performance\n            // implications, it's considered a recoverable error, even though the user\n            // likely won't observe anything wrong with the UI.\n            //\n            // The error is passed in as an argument to enforce that every caller provide\n            // a custom message, or explicitly opt out (currently the only path that opts\n            // out is legacy mode; every concurrent path provides an error).\n            if (recoverableError !== null) {\n                queueHydrationError(recoverableError);\n            } // This will add the old fiber to the deletion list\n            reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n            var nextProps = workInProgress.pendingProps;\n            var primaryChildren = nextProps.children;\n            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n            // mounted but this is a new fiber.\n            primaryChildFragment.flags |= Placement;\n            workInProgress.memoizedState = null;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var fiberMode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: \"visible\",\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n            // boundary) already mounted but this is a new fiber.\n            fallbackChildFragment.flags |= Placement;\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n                // We will have dropped the effect list which contains the\n                // deletion. We need to reconcile to delete the current child.\n                reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n            }\n            return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n            // During the first pass, we'll bail out and not drill into the children.\n            // Instead, we'll leave the content in place and try to hydrate it later.\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                {\n                    error(\"Cannot hydrate Suspense in legacy mode. Switch from \" + \"ReactDOM.hydrate(element, container) to \" + \"ReactDOMClient.hydrateRoot(container, <App />)\" + \".render(element) or remove the Suspense components from \" + \"the server rendered components.\");\n                }\n                workInProgress.lanes = laneToLanes(SyncLane);\n            } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This is a client-only boundary. Since we won't get any content from the server\n                // for this, we need to schedule that at a higher priority based on when it would\n                // have timed out. In theory we could render it in this pass but it would have the\n                // wrong priority associated with it and will prevent hydration of parent path.\n                // Instead, we'll leave work left on it to render it in a separate commit.\n                // TODO This time should be the time at which the server rendered response that is\n                // a parent to this boundary was displayed. However, since we currently don't have\n                // a protocol to transfer that time, we'll just estimate it by using the current\n                // time. This will mean that Suspense timeouts are slightly shifted to later than\n                // they should be.\n                // Schedule a normal pri update to render this content.\n                workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n            } else {\n                // We'll continue hydrating the rest at offscreen priority since we'll already\n                // be showing the right content coming from the server, it is no rush.\n                workInProgress.lanes = laneToLanes(OffscreenLane);\n            }\n            return null;\n        }\n        function updateDehydratedSuspenseComponent(current, workInProgress, suspenseInstance, suspenseState, renderLanes) {\n            // We should never be hydrating at this point because it is the first pass,\n            // but after we've already committed once.\n            warnIfHydrating();\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // required — every concurrent mode path that causes hydration to\n                // de-opt to client rendering should have an error message.\n                null);\n            }\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This boundary is in a permanent fallback state. In this case, we'll never\n                // get an update and we'll never be able to hydrate the final content. Let's just try the\n                // client side render instead.\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // here on the client. Or, in production, a hash/id that corresponds to\n                // the error.\n                new Error(\"The server could not finish this Suspense boundary, likely \" + \"due to an error during server rendering. Switched to \" + \"client rendering.\"));\n            }\n            // any context has changed, we need to treat is as if the input might have changed.\n            var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n            if (didReceiveUpdate || hasContextChanged) {\n                // This boundary has changed since the first render. This means that we are now unable to\n                // hydrate it. We might still be able to hydrate it using a higher priority lane.\n                var root = getWorkInProgressRoot();\n                if (root !== null) {\n                    var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n                    if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                        // Intentionally mutating since this render will get interrupted. This\n                        // is one of the very rare times where we mutate the current tree\n                        // during the render phase.\n                        suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n                        var eventTime = NoTimestamp;\n                        scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\n                    }\n                } // If we have scheduled higher pri work above, this will probably just abort the render\n                // since we now have higher priority work, but in case it doesn't, we need to prepare to\n                // render something, if we time out. Even if that requires us to delete everything and\n                // skip hydration.\n                // Delay having to do this as long as the suspense timeout allows us.\n                renderDidSuspendDelayIfPossible();\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error(\"This Suspense boundary received an update before it finished \" + \"hydrating. This caused the boundary to switch to client rendering. \" + \"The usual way to fix this is to wrap the original update \" + \"in startTransition.\"));\n            } else if (isSuspenseInstancePending(suspenseInstance)) {\n                // This component is still pending more data from the server, so we can't hydrate its\n                // content. We treat it as if this component suspended itself. It might seem as if\n                // we could just try to render it client-side instead. However, this will perform a\n                // lot of unnecessary work and is unlikely to complete since it often will suspend\n                // on missing data anyway. Additionally, the server might be able to render more\n                // than we can on the client yet. In that case we'd end up with more fallback states\n                // on the client than if we just leave it alone. If the server times out or errors\n                // these should update this boundary to the permanent Fallback state instead.\n                // Mark it as having captured (i.e. suspended).\n                workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n                workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n                var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n                registerSuspenseInstanceRetry(suspenseInstance, retry);\n                return null;\n            } else {\n                // This is the first attempt.\n                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n                var nextProps = workInProgress.pendingProps;\n                var primaryChildren = nextProps.children;\n                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n                // tree is part of a hydrating tree. This is used to determine if a child\n                // node has fully mounted yet, and for scheduling event replaying.\n                // Conceptually this is similar to Placement in that a new subtree is\n                // inserted into the React tree here. It just happens to not need DOM\n                // mutations because it already exists.\n                primaryChildFragment.flags |= Hydrating;\n                return primaryChildFragment;\n            }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n            }\n            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n            // Mark any Suspense boundaries with fallbacks as having work to do.\n            // If they were previously forced into fallbacks, they may now be able\n            // to unblock.\n            var node = firstChild;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                    }\n                } else if (node.tag === SuspenseListComponent) {\n                    // If the tail is hidden there might not be an Suspense boundaries\n                    // to schedule work on. In this case we have to schedule it on the\n                    // list itself.\n                    // We don't have to traverse to the children of the list since\n                    // the list will propagate the change when it rerenders.\n                    scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === workInProgress) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === workInProgress) {\n                        return;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function findLastContentRow(firstChild) {\n            // This is going to find the last row among these children that is already\n            // showing content on the screen, as opposed to being in fallback state or\n            // new. If a row has multiple Suspense boundaries, any of them being in the\n            // fallback state, counts as the whole row being in a fallback state.\n            // Note that the \"rows\" will be workInProgress, but any nested children\n            // will still be current since we haven't rendered them yet. The mounted\n            // order may not be the same as the new order. We use the new order.\n            var row = firstChild;\n            var lastContentRow = null;\n            while(row !== null){\n                var currentRow = row.alternate; // New rows can't be content rows.\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    lastContentRow = row;\n                }\n                row = row.sibling;\n            }\n            return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n            {\n                if (revealOrder !== undefined && revealOrder !== \"forwards\" && revealOrder !== \"backwards\" && revealOrder !== \"together\" && !didWarnAboutRevealOrder[revealOrder]) {\n                    didWarnAboutRevealOrder[revealOrder] = true;\n                    if (typeof revealOrder === \"string\") {\n                        switch(revealOrder.toLowerCase()){\n                            case \"together\":\n                            case \"forwards\":\n                            case \"backwards\":\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            case \"forward\":\n                            case \"backward\":\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            default:\n                                error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                                break;\n                        }\n                    } else {\n                        error(\"%s is not a supported value for revealOrder on <SuspenseList />. \" + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    }\n                }\n            }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n            {\n                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n                    if (tailMode !== \"collapsed\" && tailMode !== \"hidden\") {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n                    } else if (revealOrder !== \"forwards\" && revealOrder !== \"backwards\") {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n                    }\n                }\n            }\n        }\n        function validateSuspenseListNestedChild(childSlot, index) {\n            {\n                var isAnArray = isArray(childSlot);\n                var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === \"function\";\n                if (isAnArray || isIterable) {\n                    var type = isAnArray ? \"array\" : \"iterable\";\n                    error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in \" + \"an additional SuspenseList to configure its revealOrder: \" + \"<SuspenseList revealOrder=...> ... \" + \"<SuspenseList revealOrder=...>{%s}</SuspenseList> ... \" + \"</SuspenseList>\", type, index, type);\n                    return false;\n                }\n            }\n            return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n            {\n                if ((revealOrder === \"forwards\" || revealOrder === \"backwards\") && children !== undefined && children !== null && children !== false) {\n                    if (isArray(children)) {\n                        for(var i = 0; i < children.length; i++){\n                            if (!validateSuspenseListNestedChild(children[i], i)) {\n                                return;\n                            }\n                        }\n                    } else {\n                        var iteratorFn = getIteratorFn(children);\n                        if (typeof iteratorFn === \"function\") {\n                            var childrenIterator = iteratorFn.call(children);\n                            if (childrenIterator) {\n                                var step = childrenIterator.next();\n                                var _i = 0;\n                                for(; !step.done; step = childrenIterator.next()){\n                                    if (!validateSuspenseListNestedChild(step.value, _i)) {\n                                        return;\n                                    }\n                                    _i++;\n                                }\n                            }\n                        } else {\n                            error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + \"This is not useful since it needs multiple rows. \" + \"Did you mean to pass multiple children or an array?\", revealOrder);\n                        }\n                    }\n                }\n            }\n        }\n        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n            var renderState = workInProgress.memoizedState;\n            if (renderState === null) {\n                workInProgress.memoizedState = {\n                    isBackwards: isBackwards,\n                    rendering: null,\n                    renderingStartTime: 0,\n                    last: lastContentRow,\n                    tail: tail,\n                    tailMode: tailMode\n                };\n            } else {\n                // We can reuse the existing object from previous renders.\n                renderState.isBackwards = isBackwards;\n                renderState.rendering = null;\n                renderState.renderingStartTime = 0;\n                renderState.last = lastContentRow;\n                renderState.tail = tail;\n                renderState.tailMode = tailMode;\n            }\n        } // This can end up rendering this component multiple passes.\n        // The first pass splits the children fibers into two sets. A head and tail.\n        // We first render the head. If anything is in fallback state, we do another\n        // pass through beginWork to rerender all children (including the tail) with\n        // the force suspend context. If the first render didn't have anything in\n        // in fallback state. Then we render each row in the tail one-by-one.\n        // That happens in the completeWork phase without going back to beginWork.\n        function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var revealOrder = nextProps.revealOrder;\n            var tailMode = nextProps.tail;\n            var newChildren = nextProps.children;\n            validateRevealOrder(revealOrder);\n            validateTailOptions(tailMode, revealOrder);\n            validateSuspenseListChildren(newChildren, revealOrder);\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            var suspenseContext = suspenseStackCursor.current;\n            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n            if (shouldForceFallback) {\n                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n                workInProgress.flags |= DidCapture;\n            } else {\n                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n                if (didSuspendBefore) {\n                    // If we previously forced a fallback, we need to schedule work\n                    // on any nested boundaries to let them know to try to render\n                    // again. This is the same as context updating.\n                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n                }\n                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n            }\n            pushSuspenseContext(workInProgress, suspenseContext);\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                // In legacy mode, SuspenseList doesn't work so we just\n                // use make it a noop by treating it as the default revealOrder.\n                workInProgress.memoizedState = null;\n            } else {\n                switch(revealOrder){\n                    case \"forwards\":\n                        {\n                            var lastContentRow = findLastContentRow(workInProgress.child);\n                            var tail;\n                            if (lastContentRow === null) {\n                                // The whole list is part of the tail.\n                                // TODO: We could fast path by just rendering the tail now.\n                                tail = workInProgress.child;\n                                workInProgress.child = null;\n                            } else {\n                                // Disconnect the tail rows after the content row.\n                                // We're going to render them separately later.\n                                tail = lastContentRow.sibling;\n                                lastContentRow.sibling = null;\n                            }\n                            initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);\n                            break;\n                        }\n                    case \"backwards\":\n                        {\n                            // We're going to find the first row that has existing content.\n                            // At the same time we're going to reverse the list of everything\n                            // we pass in the meantime. That's going to be our tail in reverse\n                            // order.\n                            var _tail = null;\n                            var row = workInProgress.child;\n                            workInProgress.child = null;\n                            while(row !== null){\n                                var currentRow = row.alternate; // New rows can't be content rows.\n                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                                    // This is the beginning of the main content.\n                                    workInProgress.child = row;\n                                    break;\n                                }\n                                var nextRow = row.sibling;\n                                row.sibling = _tail;\n                                _tail = row;\n                                row = nextRow;\n                            } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n                            initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);\n                            break;\n                        }\n                    case \"together\":\n                        {\n                            initSuspenseListRenderState(workInProgress, false, null, null, undefined);\n                            break;\n                        }\n                    default:\n                        {\n                            // The default reveal order is the same as not having\n                            // a boundary.\n                            workInProgress.memoizedState = null;\n                        }\n                }\n            }\n            return workInProgress.child;\n        }\n        function updatePortalComponent(current, workInProgress, renderLanes) {\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            var nextChildren = workInProgress.pendingProps;\n            if (current === null) {\n                // Portals are special because we don't append the children during mount\n                // but at commit. Therefore we need to track insertions which the normal\n                // flow doesn't do during mount. This doesn't happen at the root because\n                // the root always starts with a \"current\" with a null child.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current, workInProgress, renderLanes) {\n            var providerType = workInProgress.type;\n            var context = providerType._context;\n            var newProps = workInProgress.pendingProps;\n            var oldProps = workInProgress.memoizedProps;\n            var newValue = newProps.value;\n            {\n                if (!(\"value\" in newProps)) {\n                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                        error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\");\n                    }\n                }\n                var providerPropTypes = workInProgress.type.propTypes;\n                if (providerPropTypes) {\n                    checkPropTypes(providerPropTypes, newProps, \"prop\", \"Context.Provider\");\n                }\n            }\n            pushProvider(workInProgress, context, newValue);\n            {\n                if (oldProps !== null) {\n                    var oldValue = oldProps.value;\n                    if (objectIs(oldValue, newValue)) {\n                        // No change. Bailout early if children are the same.\n                        if (oldProps.children === newProps.children && !hasContextChanged()) {\n                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                        }\n                    } else {\n                        // The context value changed. Search for matching consumers and schedule\n                        // them to update.\n                        propagateContextChange(workInProgress, context, renderLanes);\n                    }\n                }\n            }\n            var newChildren = newProps.children;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingContextAsConsumer = false;\n        function updateContextConsumer(current, workInProgress, renderLanes) {\n            var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var newProps = workInProgress.pendingProps;\n            var render = newProps.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var newValue = readContext(context);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var newChildren;\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                newChildren = render(newValue);\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n            didReceiveUpdate = true;\n        }\n        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n            if (current !== null) {\n                // Reuse previous dependencies\n                workInProgress.dependencies = current.dependencies;\n            }\n            {\n                // Don't update \"base\" render times for bailouts.\n                stopProfilerTimerIfRunning();\n            }\n            markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n                // The children don't have any work either. We can skip them.\n                // TODO: Once we add back resuming, we should check if the children are\n                // a work-in-progress set. If so, we need to transfer their effects.\n                {\n                    return null;\n                }\n            } // This fiber doesn't have work, but its subtree does. Clone the child\n            // fibers and continue.\n            cloneChildFibers(current, workInProgress);\n            return workInProgress.child;\n        }\n        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n            {\n                var returnFiber = oldWorkInProgress.return;\n                if (returnFiber === null) {\n                    // eslint-disable-next-line react-internal/prod-error-codes\n                    throw new Error(\"Cannot swap the root fiber.\");\n                } // Disconnect from the old current.\n                // It will get deleted.\n                current.alternate = null;\n                oldWorkInProgress.alternate = null; // Connect to the new tree.\n                newWorkInProgress.index = oldWorkInProgress.index;\n                newWorkInProgress.sibling = oldWorkInProgress.sibling;\n                newWorkInProgress.return = oldWorkInProgress.return;\n                newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n                if (oldWorkInProgress === returnFiber.child) {\n                    returnFiber.child = newWorkInProgress;\n                } else {\n                    var prevSibling = returnFiber.child;\n                    if (prevSibling === null) {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"Expected parent to have a child.\");\n                    }\n                    while(prevSibling.sibling !== oldWorkInProgress){\n                        prevSibling = prevSibling.sibling;\n                        if (prevSibling === null) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"Expected to find the previous sibling.\");\n                        }\n                    }\n                    prevSibling.sibling = newWorkInProgress;\n                } // Delete the old fiber and place the new one.\n                // Since the old fiber is disconnected, we have to schedule it manually.\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        current\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(current);\n                }\n                newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n                return newWorkInProgress;\n            }\n        }\n        function checkScheduledUpdateOrContext(current, renderLanes) {\n            // Before performing an early bailout, we must check if there are pending\n            // updates or context.\n            var updateLanes = current.lanes;\n            if (includesSomeLane(updateLanes, renderLanes)) {\n                return true;\n            } // No pending update, but because context is propagated lazily, we need\n            return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n            // This fiber does not have any pending work. Bailout without entering\n            // the begin phase. There's still some bookkeeping we that needs to be done\n            // in this optimized path, mostly pushing stuff onto the stack.\n            switch(workInProgress.tag){\n                case HostRoot:\n                    pushHostRootContext(workInProgress);\n                    var root = workInProgress.stateNode;\n                    resetHydrationState();\n                    break;\n                case HostComponent:\n                    pushHostContext(workInProgress);\n                    break;\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            pushContextProvider(workInProgress);\n                        }\n                        break;\n                    }\n                case HostPortal:\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    break;\n                case ContextProvider:\n                    {\n                        var newValue = workInProgress.memoizedProps.value;\n                        var context = workInProgress.type._context;\n                        pushProvider(workInProgress, context, newValue);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        // Profiler should only call onRender when one of its descendants actually rendered.\n                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (hasChildWork) {\n                            workInProgress.flags |= Update;\n                        }\n                        {\n                            // Reset effect durations for the next eventual effect phase.\n                            // These are reset during render to allow the DevTools commit hook a chance to read them,\n                            var stateNode = workInProgress.stateNode;\n                            stateNode.effectDuration = 0;\n                            stateNode.passiveEffectDuration = 0;\n                        }\n                    }\n                    break;\n                case SuspenseComponent:\n                    {\n                        var state = workInProgress.memoizedState;\n                        if (state !== null) {\n                            {\n                                if (state.dehydrated !== null) {\n                                    pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n                                    // been unsuspended it has committed as a resolved Suspense component.\n                                    // If it needs to be retried, it should have work scheduled on it.\n                                    workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n                                    // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n                                    return null;\n                                }\n                            }\n                            // whether to retry the primary children, or to skip over it and\n                            // go straight to the fallback. Check the priority of the primary\n                            // child fragment.\n                            var primaryChildFragment = workInProgress.child;\n                            var primaryChildLanes = primaryChildFragment.childLanes;\n                            if (includesSomeLane(renderLanes, primaryChildLanes)) {\n                                // The primary children have pending work. Use the normal path\n                                // to attempt to render the primary children again.\n                                return updateSuspenseComponent(current, workInProgress, renderLanes);\n                            } else {\n                                // The primary child fragment does not have pending work marked\n                                // on it\n                                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n                                // priority. Bailout.\n                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                                if (child !== null) {\n                                    // The fallback children have pending work. Skip over the\n                                    // primary children and work on the fallback.\n                                    return child.sibling;\n                                } else {\n                                    // Note: We can return `null` here because we already checked\n                                    // whether there were nested context consumers, via the call to\n                                    // `bailoutOnAlreadyFinishedWork` above.\n                                    return null;\n                                }\n                            }\n                        } else {\n                            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                        }\n                        break;\n                    }\n                case SuspenseListComponent:\n                    {\n                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (didSuspendBefore) {\n                            if (_hasChildWork) {\n                                // If something was in fallback state last time, and we have all the\n                                // same children then we're still in progressive loading state.\n                                // Something might get unblocked by state updates or retries in the\n                                // tree which will affect the tail. So we need to use the normal\n                                // path to compute the correct tail.\n                                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                            } // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            workInProgress.flags |= DidCapture;\n                        } // If nothing suspended before and we're rendering the same children,\n                        // then the tail doesn't matter. Anything new that suspends will work\n                        // in the \"together\" mode, so we can continue from the state we had.\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState !== null) {\n                            // Reset to the \"together\" mode in case we've started a different\n                            // update in the past but didn't complete it.\n                            renderState.rendering = null;\n                            renderState.tail = null;\n                            renderState.lastEffect = null;\n                        }\n                        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n                        if (_hasChildWork) {\n                            break;\n                        } else {\n                            // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            return null;\n                        }\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        // Need to check if the tree still needs to be deferred. This is\n                        // almost identical to the logic used in the normal update path,\n                        // so we'll just enter that. The only difference is we'll bail out\n                        // at the next level instead of this one, because the child props\n                        // have not changed. Which is fine.\n                        // TODO: Probably should refactor `beginWork` to split the bailout\n                        // path from the normal path. I'm tempted to do a labeled break here\n                        // but I won't :)\n                        workInProgress.lanes = NoLanes;\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n            }\n            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        function beginWork(current, workInProgress, renderLanes) {\n            {\n                if (workInProgress._debugNeedsRemount && current !== null) {\n                    // This will restart the begin phase with a new fiber.\n                    return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n                }\n            }\n            if (current !== null) {\n                var oldProps = current.memoizedProps;\n                var newProps = workInProgress.pendingProps;\n                if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) {\n                    // If props or context changed, mark the fiber as having performed work.\n                    // This may be unset if the props are determined to be equal later (memo).\n                    didReceiveUpdate = true;\n                } else {\n                    // Neither props nor legacy context changes. Check if there's a pending\n                    // update or context change.\n                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n                    if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n                    // may not be work scheduled on `current`, so we check for this flag.\n                    (workInProgress.flags & DidCapture) === NoFlags) {\n                        // No pending updates or context. Bail out now.\n                        didReceiveUpdate = false;\n                        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n                    }\n                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    } else {\n                        // An update was scheduled on this fiber, but there are no new props\n                        // nor legacy context. Set this to false. If an update queue or context\n                        // consumer produces a changed value, it will set this to true. Otherwise,\n                        // the component will assume the children have not changed and bail out.\n                        didReceiveUpdate = false;\n                    }\n                }\n            } else {\n                didReceiveUpdate = false;\n                if (getIsHydrating() && isForkedChild(workInProgress)) {\n                    // Check if this child belongs to a list of muliple children in\n                    // its parent.\n                    //\n                    // In a true multi-threaded implementation, we would render children on\n                    // parallel threads. This would represent the beginning of a new render\n                    // thread for this subtree.\n                    //\n                    // We only use this for id generation during hydration, which is why the\n                    // logic is located in this special branch.\n                    var slotIndex = workInProgress.index;\n                    var numberOfForks = getForksAtLevel();\n                    pushTreeId(workInProgress, numberOfForks, slotIndex);\n                }\n            } // Before entering the begin phase, clear pending update priority.\n            // TODO: This assumes that we're about to evaluate the component and process\n            // the update queue. However, there's an exception: SimpleMemoComponent\n            // sometimes bails out later in the begin phase. This indicates that we should\n            // move this assignment out of the common path and into each branch.\n            workInProgress.lanes = NoLanes;\n            switch(workInProgress.tag){\n                case IndeterminateComponent:\n                    {\n                        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n                    }\n                case LazyComponent:\n                    {\n                        var elementType = workInProgress.elementType;\n                        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n                    }\n                case FunctionComponent:\n                    {\n                        var Component = workInProgress.type;\n                        var unresolvedProps = workInProgress.pendingProps;\n                        var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n                        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n                    }\n                case ClassComponent:\n                    {\n                        var _Component = workInProgress.type;\n                        var _unresolvedProps = workInProgress.pendingProps;\n                        var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n                        return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);\n                    }\n                case HostRoot:\n                    return updateHostRoot(current, workInProgress, renderLanes);\n                case HostComponent:\n                    return updateHostComponent$1(current, workInProgress, renderLanes);\n                case HostText:\n                    return updateHostText$1(current, workInProgress);\n                case SuspenseComponent:\n                    return updateSuspenseComponent(current, workInProgress, renderLanes);\n                case HostPortal:\n                    return updatePortalComponent(current, workInProgress, renderLanes);\n                case ForwardRef:\n                    {\n                        var type = workInProgress.type;\n                        var _unresolvedProps2 = workInProgress.pendingProps;\n                        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n                        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);\n                    }\n                case Fragment:\n                    return updateFragment(current, workInProgress, renderLanes);\n                case Mode:\n                    return updateMode(current, workInProgress, renderLanes);\n                case Profiler:\n                    return updateProfiler(current, workInProgress, renderLanes);\n                case ContextProvider:\n                    return updateContextProvider(current, workInProgress, renderLanes);\n                case ContextConsumer:\n                    return updateContextConsumer(current, workInProgress, renderLanes);\n                case MemoComponent:\n                    {\n                        var _type2 = workInProgress.type;\n                        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n                        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n                        {\n                            if (workInProgress.type !== workInProgress.elementType) {\n                                var outerPropTypes = _type2.propTypes;\n                                if (outerPropTypes) {\n                                    checkPropTypes(outerPropTypes, _resolvedProps3, \"prop\", getComponentNameFromType(_type2));\n                                }\n                            }\n                        }\n                        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n                        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);\n                    }\n                case SimpleMemoComponent:\n                    {\n                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n                    }\n                case IncompleteClassComponent:\n                    {\n                        var _Component2 = workInProgress.type;\n                        var _unresolvedProps4 = workInProgress.pendingProps;\n                        var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n                        return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);\n                    }\n                case SuspenseListComponent:\n                    {\n                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n        }\n        function unwindWork(current, workInProgress, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            popContext(workInProgress);\n                        }\n                        var flags = workInProgress.flags;\n                        if (flags & ShouldCapture) {\n                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        popHostContainer(workInProgress);\n                        popTopLevelContextObject(workInProgress);\n                        resetWorkInProgressVersions();\n                        var _flags = workInProgress.flags;\n                        if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n                            // There was an error during render that wasn't captured by a suspense\n                            // boundary. Do a second pass on the root to unmount the children.\n                            workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n                            return workInProgress;\n                        } // We unwound to the root without completing it. Exit.\n                        return null;\n                    }\n                case HostComponent:\n                    {\n                        // TODO: popHydrationState\n                        popHostContext(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        {\n                            var suspenseState = workInProgress.memoizedState;\n                            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                                if (workInProgress.alternate === null) {\n                                    throw new Error(\"Threw in newly mounted dehydrated component. This is likely a bug in \" + \"React. Please file an issue.\");\n                                }\n                                resetHydrationState();\n                            }\n                        }\n                        var _flags2 = workInProgress.flags;\n                        if (_flags2 & ShouldCapture) {\n                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n                        // caught by a nested boundary. If not, it should bubble through.\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    return null;\n                case ContextProvider:\n                    var context = workInProgress.type._context;\n                    popProvider(context, workInProgress);\n                    return null;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popRenderLanes(workInProgress);\n                    return null;\n                case CacheComponent:\n                    return null;\n                default:\n                    return null;\n            }\n        }\n        function unwindInterruptedWork(current, interruptedWork, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(interruptedWork);\n            switch(interruptedWork.tag){\n                case ClassComponent:\n                    {\n                        var childContextTypes = interruptedWork.type.childContextTypes;\n                        if (childContextTypes !== null && childContextTypes !== undefined) {\n                            popContext(interruptedWork);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        popHostContainer(interruptedWork);\n                        popTopLevelContextObject(interruptedWork);\n                        resetWorkInProgressVersions();\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(interruptedWork);\n                        break;\n                    }\n                case HostPortal:\n                    popHostContainer(interruptedWork);\n                    break;\n                case SuspenseComponent:\n                    popSuspenseContext(interruptedWork);\n                    break;\n                case SuspenseListComponent:\n                    popSuspenseContext(interruptedWork);\n                    break;\n                case ContextProvider:\n                    var context = interruptedWork.type._context;\n                    popProvider(context, interruptedWork);\n                    break;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popRenderLanes(interruptedWork);\n                    break;\n            }\n        }\n        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n            var funcArgs = Array.prototype.slice.call(arguments, 3);\n            try {\n                func.apply(context, funcArgs);\n            } catch (error) {\n                this.onError(error);\n            }\n        }\n        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n        {\n            // In DEV mode, we swap out invokeGuardedCallback for a special version\n            // that plays more nicely with the browser's DevTools. The idea is to preserve\n            // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n            // functions in invokeGuardedCallback, and the production version of\n            // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n            // like caught exceptions, and the DevTools won't pause unless the developer\n            // takes the extra step of enabling pause on caught exceptions. This is\n            // unintuitive, though, because even though React has caught the error, from\n            // the developer's perspective, the error is uncaught.\n            //\n            // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n            // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n            // DOM node, and call the user-provided callback from inside an event handler\n            // for that fake event. If the callback throws, the error is \"captured\" using\n            // a global event handler. But because the error happens in a different\n            // event loop context, it does not interrupt the normal program flow.\n            // Effectively, this gives us try-catch behavior without actually using\n            // try-catch. Neat!\n            // Check that the browser supports the APIs we need to implement our special\n            // DEV version of invokeGuardedCallback\n            if (false) { var fakeNode; }\n        }\n        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n        var hasError = false;\n        var caughtError = null; // Used by event system to capture/rethrow the first error.\n        var reporter = {\n            onError: function(error) {\n                hasError = true;\n                caughtError = error;\n            }\n        };\n        /**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */ function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n            hasError = false;\n            caughtError = null;\n            invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n        }\n        function hasCaughtError() {\n            return hasError;\n        }\n        function clearCaughtError() {\n            if (hasError) {\n                var error = caughtError;\n                hasError = false;\n                caughtError = null;\n                return error;\n            } else {\n                throw new Error(\"clearCaughtError was called but no error was captured. This error \" + \"is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n        }\n        // Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n        // Only used when enableSuspenseLayoutEffectSemantics is enabled.\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false;\n        var PossiblyWeakSet = typeof WeakSet === \"function\" ? WeakSet : Set;\n        var nextEffect = null; // Used for Profiling builds to track updaters.\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function reportUncaughtErrorInDEV(error) {\n            // Wrapping each small part of the commit phase into a guarded\n            // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n            // But we rely on it to surface errors to DEV tools like overlays\n            // (https://github.com/facebook/react/issues/21712).\n            // As a compromise, rethrow only caught errors in a guard.\n            {\n                invokeGuardedCallback(null, function() {\n                    throw error;\n                });\n                clearCaughtError();\n            }\n        }\n        var callComponentWillUnmountWithTimer = function(current, instance) {\n            instance.props = current.memoizedProps;\n            instance.state = current.memoizedState;\n            if (current.mode & ProfileMode) {\n                try {\n                    startLayoutEffectTimer();\n                    instance.componentWillUnmount();\n                } finally{\n                    recordLayoutEffectDuration(current);\n                }\n            } else {\n                instance.componentWillUnmount();\n            }\n        }; // Capture errors so they don't interrupt mounting.\n        function safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n            try {\n                commitHookEffectListMount(Layout, current);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt unmounting.\n        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n            try {\n                callComponentWillUnmountWithTimer(current, instance);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyAttachRef(current, nearestMountedAncestor) {\n            try {\n                commitAttachRef(current);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        function safelyDetachRef(current, nearestMountedAncestor) {\n            var ref = current.ref;\n            if (ref !== null) {\n                if (typeof ref === \"function\") {\n                    var retVal;\n                    try {\n                        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                retVal = ref(null);\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            retVal = ref(null);\n                        }\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    }\n                    {\n                        if (typeof retVal === \"function\") {\n                            error(\"Unexpected return value from a callback ref in %s. \" + \"A callback ref should not return a function.\", getComponentNameFromFiber(current));\n                        }\n                    }\n                } else {\n                    ref.current = null;\n                }\n            }\n        }\n        function safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        var focusedInstanceHandle = null;\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root, firstChild) {\n            focusedInstanceHandle = prepareForCommit(root.containerInfo);\n            nextEffect = firstChild;\n            commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n            var shouldFire = shouldFireAfterActiveInstanceBlur;\n            shouldFireAfterActiveInstanceBlur = false;\n            focusedInstanceHandle = null;\n            return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitBeforeMutationEffects_complete();\n                }\n            }\n        }\n        function commitBeforeMutationEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentFiber(fiber);\n                try {\n                    commitBeforeMutationEffectsOnFiber(fiber);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags;\n            if ((flags & Snapshot) !== NoFlags) {\n                setCurrentFiber(finishedWork);\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            if (current !== null) {\n                                var prevProps = current.memoizedProps;\n                                var prevState = current.memoizedState;\n                                var instance = finishedWork.stateNode; // We could update instance props and state here,\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                {\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error(\"Expected %s props to match memoized props before \" + \"getSnapshotBeforeUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error(\"Expected %s state to match memoized state before \" + \"getSnapshotBeforeUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                    }\n                                }\n                                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n                                {\n                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                                        didWarnSet.add(finishedWork.type);\n                                        error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" + \"must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n                                    }\n                                }\n                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                            }\n                            break;\n                        }\n                    case HostRoot:\n                        {\n                            if (supportsMutation) {\n                                var root = finishedWork.stateNode;\n                                clearContainer(root.containerInfo);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                    case HostText:\n                    case HostPortal:\n                    case IncompleteClassComponent:\n                        break;\n                    default:\n                        {\n                            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n                        }\n                }\n                resetCurrentFiber();\n            }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        // Unmount\n                        var destroy = effect.destroy;\n                        effect.destroy = undefined;\n                        if (destroy !== undefined) {\n                            {\n                                if ((flags & Passive$1) !== NoFlags$1) {\n                                    markComponentPassiveEffectUnmountStarted(finishedWork);\n                                } else if ((flags & Layout) !== NoFlags$1) {\n                                    markComponentLayoutEffectUnmountStarted(finishedWork);\n                                }\n                            }\n                            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                            {\n                                if ((flags & Passive$1) !== NoFlags$1) {\n                                    markComponentPassiveEffectUnmountStopped();\n                                } else if ((flags & Layout) !== NoFlags$1) {\n                                    markComponentLayoutEffectUnmountStopped();\n                                }\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        {\n                            if ((flags & Passive$1) !== NoFlags$1) {\n                                markComponentPassiveEffectMountStarted(finishedWork);\n                            } else if ((flags & Layout) !== NoFlags$1) {\n                                markComponentLayoutEffectMountStarted(finishedWork);\n                            }\n                        }\n                        var create = effect.create;\n                        effect.destroy = create();\n                        {\n                            if ((flags & Passive$1) !== NoFlags$1) {\n                                markComponentPassiveEffectMountStopped();\n                            } else if ((flags & Layout) !== NoFlags$1) {\n                                markComponentLayoutEffectMountStopped();\n                            }\n                        }\n                        {\n                            var destroy = effect.destroy;\n                            if (destroy !== undefined && typeof destroy !== \"function\") {\n                                var hookName = void 0;\n                                if ((effect.tag & Layout) !== NoFlags) {\n                                    hookName = \"useLayoutEffect\";\n                                } else if ((effect.tag & Insertion) !== NoFlags) {\n                                    hookName = \"useInsertionEffect\";\n                                } else {\n                                    hookName = \"useEffect\";\n                                }\n                                var addendum = void 0;\n                                if (destroy === null) {\n                                    addendum = \" You returned null. If your effect does not require clean \" + \"up, return undefined (or nothing).\";\n                                } else if (typeof destroy.then === \"function\") {\n                                    addendum = \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. \" + \"Instead, write the async function inside your effect \" + \"and call it immediately:\\n\\n\" + hookName + \"(() => {\\n\" + \"  async function fetchData() {\\n\" + \"    // You can await here\\n\" + \"    const response = await MyAPI.getData(someId);\\n\" + \"    // ...\\n\" + \"  }\\n\" + \"  fetchData();\\n\" + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + \"Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching\";\n                                } else {\n                                    addendum = \" You returned: \" + destroy;\n                                }\n                                error(\"%s must not return anything besides a function, \" + \"which is used for clean-up.%s\", hookName, addendum);\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n            {\n                // Only Profilers with work in their subtree will have an Update effect scheduled.\n                if ((finishedWork.flags & Update) !== NoFlags) {\n                    switch(finishedWork.tag){\n                        case Profiler:\n                            {\n                                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n                                // It does not get reset until the start of the next commit phase.\n                                var commitTime = getCommitTime();\n                                var phase = finishedWork.alternate === null ? \"mount\" : \"update\";\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = \"nested-update\";\n                                    }\n                                }\n                                if (typeof onPostCommit === \"function\") {\n                                    onPostCommit(id, phase, passiveEffectDuration, commitTime);\n                                } // Bubble times to the next nearest ancestor Profiler.\n                                // After we process that Profiler, we'll bubble further up.\n                                var parentFiber = finishedWork.return;\n                                outer: while(parentFiber !== null){\n                                    switch(parentFiber.tag){\n                                        case HostRoot:\n                                            var root = parentFiber.stateNode;\n                                            root.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                        case Profiler:\n                                            var parentStateNode = parentFiber.stateNode;\n                                            parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                    }\n                                    parentFiber = parentFiber.return;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n            if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            if (!offscreenSubtreeWasHidden) {\n                                // At this point layout effects have already been destroyed (during mutation phase).\n                                // This is done to prevent sibling component effects from interfering with each other,\n                                // e.g. a destroy function in one component should never override a ref set\n                                // by a create function in another component during the same commit.\n                                if (finishedWork.mode & ProfileMode) {\n                                    try {\n                                        startLayoutEffectTimer();\n                                        commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                                    } finally{\n                                        recordLayoutEffectDuration(finishedWork);\n                                    }\n                                } else {\n                                    commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                                }\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = finishedWork.stateNode;\n                            if (finishedWork.flags & Update) {\n                                if (!offscreenSubtreeWasHidden) {\n                                    if (current === null) {\n                                        // We could update instance props and state here,\n                                        // but instead we rely on them being set during last render.\n                                        // TODO: revisit this when we implement resuming.\n                                        {\n                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                                if (instance.props !== finishedWork.memoizedProps) {\n                                                    error(\"Expected %s props to match memoized props before \" + \"componentDidMount. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                                if (instance.state !== finishedWork.memoizedState) {\n                                                    error(\"Expected %s state to match memoized state before \" + \"componentDidMount. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                            }\n                                        }\n                                        if (finishedWork.mode & ProfileMode) {\n                                            try {\n                                                startLayoutEffectTimer();\n                                                instance.componentDidMount();\n                                            } finally{\n                                                recordLayoutEffectDuration(finishedWork);\n                                            }\n                                        } else {\n                                            instance.componentDidMount();\n                                        }\n                                    } else {\n                                        var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n                                        var prevState = current.memoizedState; // We could update instance props and state here,\n                                        // but instead we rely on them being set during last render.\n                                        // TODO: revisit this when we implement resuming.\n                                        {\n                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                                if (instance.props !== finishedWork.memoizedProps) {\n                                                    error(\"Expected %s props to match memoized props before \" + \"componentDidUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                                if (instance.state !== finishedWork.memoizedState) {\n                                                    error(\"Expected %s state to match memoized state before \" + \"componentDidUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                            }\n                                        }\n                                        if (finishedWork.mode & ProfileMode) {\n                                            try {\n                                                startLayoutEffectTimer();\n                                                instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                                            } finally{\n                                                recordLayoutEffectDuration(finishedWork);\n                                            }\n                                        } else {\n                                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                                        }\n                                    }\n                                }\n                            } // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                {\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error(\"Expected %s props to match memoized props before \" + \"processing the update queue. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error(\"Expected %s state to match memoized state before \" + \"processing the update queue. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                    }\n                                }\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                commitUpdateQueue(finishedWork, updateQueue, instance);\n                            }\n                            break;\n                        }\n                    case HostRoot:\n                        {\n                            // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var _updateQueue = finishedWork.updateQueue;\n                            if (_updateQueue !== null) {\n                                var _instance = null;\n                                if (finishedWork.child !== null) {\n                                    switch(finishedWork.child.tag){\n                                        case HostComponent:\n                                            _instance = getPublicInstance(finishedWork.child.stateNode);\n                                            break;\n                                        case ClassComponent:\n                                            _instance = finishedWork.child.stateNode;\n                                            break;\n                                    }\n                                }\n                                commitUpdateQueue(finishedWork, _updateQueue, _instance);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n                            // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                            // These effects should only be committed when components are first mounted,\n                            // aka when there is no current/alternate.\n                            if (current === null && finishedWork.flags & Update) {\n                                var type = finishedWork.type;\n                                var props = finishedWork.memoizedProps;\n                                commitMount(_instance2, type, props, finishedWork);\n                            }\n                            break;\n                        }\n                    case HostText:\n                        {\n                            break;\n                        }\n                    case HostPortal:\n                        {\n                            break;\n                        }\n                    case Profiler:\n                        {\n                            {\n                                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                                var effectDuration = finishedWork.stateNode.effectDuration;\n                                var commitTime = getCommitTime();\n                                var phase = current === null ? \"mount\" : \"update\";\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = \"nested-update\";\n                                    }\n                                }\n                                if (typeof onRender === \"function\") {\n                                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n                                }\n                                {\n                                    if (typeof onCommit === \"function\") {\n                                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n                                    } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n                                    // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n                                    // because the effect is also where times bubble to parent Profilers.\n                                    enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n                                    // Do not reset these values until the next render so DevTools has a chance to read them first.\n                                    var parentFiber = finishedWork.return;\n                                    outer: while(parentFiber !== null){\n                                        switch(parentFiber.tag){\n                                            case HostRoot:\n                                                var root = parentFiber.stateNode;\n                                                root.effectDuration += effectDuration;\n                                                break outer;\n                                            case Profiler:\n                                                var parentStateNode = parentFiber.stateNode;\n                                                parentStateNode.effectDuration += effectDuration;\n                                                break outer;\n                                        }\n                                        parentFiber = parentFiber.return;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case SuspenseComponent:\n                        {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                            break;\n                        }\n                    case SuspenseListComponent:\n                    case IncompleteClassComponent:\n                    case ScopeComponent:\n                    case OffscreenComponent:\n                    case LegacyHiddenComponent:\n                        {\n                            break;\n                        }\n                    default:\n                        throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n                }\n            }\n            if (!offscreenSubtreeWasHidden) {\n                {\n                    if (finishedWork.flags & Ref) {\n                        commitAttachRef(finishedWork);\n                    }\n                }\n            }\n        }\n        function reappearLayoutEffectsOnFiber(node) {\n            // Turn on layout effects in a tree that previously disappeared.\n            // TODO (Offscreen) Check: flags & LayoutStatic\n            switch(node.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (node.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                safelyCallCommitHookLayoutEffectListMount(node, node.return);\n                            } finally{\n                                recordLayoutEffectDuration(node);\n                            }\n                        } else {\n                            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n                        }\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        var instance = node.stateNode;\n                        if (typeof instance.componentDidMount === \"function\") {\n                            safelyCallComponentDidMount(node, node.return, instance);\n                        }\n                        safelyAttachRef(node, node.return);\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        safelyAttachRef(node, node.return);\n                        break;\n                    }\n            }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n            // Only hide or unhide the top-most host nodes.\n            var hostSubtreeRoot = null;\n            if (supportsMutation) {\n                // We only have the top Fiber that was inserted but we need to recurse down its\n                // children to find all the terminal nodes.\n                var node = finishedWork;\n                while(true){\n                    if (node.tag === HostComponent) {\n                        if (hostSubtreeRoot === null) {\n                            hostSubtreeRoot = node;\n                            var instance = node.stateNode;\n                            if (isHidden) {\n                                hideInstance(instance);\n                            } else {\n                                unhideInstance(node.stateNode, node.memoizedProps);\n                            }\n                        }\n                    } else if (node.tag === HostText) {\n                        if (hostSubtreeRoot === null) {\n                            var _instance3 = node.stateNode;\n                            if (isHidden) {\n                                hideTextInstance(_instance3);\n                            } else {\n                                unhideTextInstance(_instance3, node.memoizedProps);\n                            }\n                        }\n                    } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === finishedWork) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === finishedWork) {\n                            return;\n                        }\n                        if (hostSubtreeRoot === node) {\n                            hostSubtreeRoot = null;\n                        }\n                        node = node.return;\n                    }\n                    if (hostSubtreeRoot === node) {\n                        hostSubtreeRoot = null;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function commitAttachRef(finishedWork) {\n            var ref = finishedWork.ref;\n            if (ref !== null) {\n                var instance = finishedWork.stateNode;\n                var instanceToUse;\n                switch(finishedWork.tag){\n                    case HostComponent:\n                        instanceToUse = getPublicInstance(instance);\n                        break;\n                    default:\n                        instanceToUse = instance;\n                } // Moved outside to ensure DCE works with this flag\n                if (typeof ref === \"function\") {\n                    var retVal;\n                    if (finishedWork.mode & ProfileMode) {\n                        try {\n                            startLayoutEffectTimer();\n                            retVal = ref(instanceToUse);\n                        } finally{\n                            recordLayoutEffectDuration(finishedWork);\n                        }\n                    } else {\n                        retVal = ref(instanceToUse);\n                    }\n                    {\n                        if (typeof retVal === \"function\") {\n                            error(\"Unexpected return value from a callback ref in %s. \" + \"A callback ref should not return a function.\", getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                } else {\n                    {\n                        if (!ref.hasOwnProperty(\"current\")) {\n                            error(\"Unexpected ref object provided for %s. \" + \"Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                    ref.current = instanceToUse;\n                }\n            }\n        }\n        function commitDetachRef(current) {\n            var currentRef = current.ref;\n            if (currentRef !== null) {\n                if (typeof currentRef === \"function\") {\n                    if (current.mode & ProfileMode) {\n                        try {\n                            startLayoutEffectTimer();\n                            currentRef(null);\n                        } finally{\n                            recordLayoutEffectDuration(current);\n                        }\n                    } else {\n                        currentRef(null);\n                    }\n                } else {\n                    currentRef.current = null;\n                }\n            }\n        } // User-originating errors (lifecycles and refs) should not interrupt\n        // deletion, so don't let them throw. Host-originating errors should\n        // interrupt deletion, so it's okay\n        function commitUnmount(finishedRoot, current, nearestMountedAncestor) {\n            onCommitUnmount(current);\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        var updateQueue = current.updateQueue;\n                        if (updateQueue !== null) {\n                            var lastEffect = updateQueue.lastEffect;\n                            if (lastEffect !== null) {\n                                var firstEffect = lastEffect.next;\n                                var effect = firstEffect;\n                                do {\n                                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;\n                                    if (destroy !== undefined) {\n                                        if ((tag & Insertion) !== NoFlags$1) {\n                                            safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                        } else if ((tag & Layout) !== NoFlags$1) {\n                                            {\n                                                markComponentLayoutEffectUnmountStarted(current);\n                                            }\n                                            if (current.mode & ProfileMode) {\n                                                startLayoutEffectTimer();\n                                                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                                recordLayoutEffectDuration(current);\n                                            } else {\n                                                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                            }\n                                            {\n                                                markComponentLayoutEffectUnmountStopped();\n                                            }\n                                        }\n                                    }\n                                    effect = effect.next;\n                                }while (effect !== firstEffect);\n                            }\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        safelyDetachRef(current, nearestMountedAncestor);\n                        var instance = current.stateNode;\n                        if (typeof instance.componentWillUnmount === \"function\") {\n                            safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance);\n                        }\n                        return;\n                    }\n                case HostComponent:\n                    {\n                        safelyDetachRef(current, nearestMountedAncestor);\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        // TODO: this is recursive.\n                        // We are also not using this parent because\n                        // the portal will get pushed immediately.\n                        if (supportsMutation) {\n                            unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n                        } else if (supportsPersistence) {\n                            emptyPortalContainer(current);\n                        }\n                        return;\n                    }\n                case DehydratedFragment:\n                    {\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        return;\n                    }\n            }\n        }\n        function commitNestedUnmounts(finishedRoot, root, nearestMountedAncestor) {\n            // While we're inside a removed host node we don't want to call\n            // removeChild on the inner nodes because they're removed by the top\n            // call anyway. We also want to call componentWillUnmount on all\n            // composites before this host node is removed from the tree. Therefore\n            // we do an inner loop while we're still inside the host node.\n            var node = root;\n            while(true){\n                commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because they may contain more composite or host nodes.\n                // Skip portals because commitUnmount() currently visits them recursively.\n                if (node.child !== null && // If we don't use mutation we drill down into portals here instead.\n                (!supportsMutation || node.tag !== HostPortal)) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === root) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === root) {\n                        return;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function detachFiberMutation(fiber) {\n            // Cut off the return pointer to disconnect it from the tree.\n            // This enables us to detect and warn against state updates on an unmounted component.\n            // It also prevents events from bubbling from within disconnected components.\n            //\n            // Ideally, we should also clear the child pointer of the parent alternate to let this\n            // get GC:ed but we don't know which for sure which parent is the current\n            // one so we'll settle for GC:ing the subtree of this child.\n            // This child itself will be GC:ed when the parent updates the next time.\n            //\n            // Note that we can't clear child or sibling pointers yet.\n            // They're needed for passive effects and for findDOMNode.\n            // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n            //\n            // Don't reset the alternate yet, either. We need that so we can detach the\n            // alternate's fields in the passive phase. Clearing the return pointer is\n            // sufficient for findDOMNode semantics.\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.return = null;\n            }\n            fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                fiber.alternate = null;\n                detachFiberAfterEffects(alternate);\n            } // Note: Defensively using negation instead of < in case\n            // `deletedTreeCleanUpLevel` is undefined.\n            {\n                // Clear cyclical Fiber fields. This level alone is designed to roughly\n                // approximate the planned Fiber refactor. In that world, `setState` will be\n                // bound to a special \"instance\" object instead of a Fiber. The Instance\n                // object will not have any of these fields. It will only be connected to\n                // the fiber tree via a single link at the root. So if this level alone is\n                // sufficient to fix memory issues, that bodes well for our plans.\n                fiber.child = null;\n                fiber.deletions = null;\n                fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n                // tree, which has its own pointers to children, parents, and siblings.\n                // The other host nodes also point back to fibers, so we should detach that\n                // one, too.\n                if (fiber.tag === HostComponent) {\n                    var hostInstance = fiber.stateNode;\n                    if (hostInstance !== null) {\n                        detachDeletedInstance(hostInstance);\n                    }\n                }\n                fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n                // already disconnect the `return` pointer at the root of the deleted\n                // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n                // cyclical — it's only cyclical when combined with `child`, `sibling`, and\n                // `alternate`. But we'll clear it in the next level anyway, just in case.\n                {\n                    fiber._debugOwner = null;\n                }\n                {\n                    // Theoretically, nothing in here should be necessary, because we already\n                    // disconnected the fiber from the tree. So even if something leaks this\n                    // particular fiber, it won't leak anything else\n                    //\n                    // The purpose of this branch is to be super aggressive so we can measure\n                    // if there's any difference in memory impact. If there is, that could\n                    // indicate a React leak we don't know about.\n                    fiber.return = null;\n                    fiber.dependencies = null;\n                    fiber.memoizedProps = null;\n                    fiber.memoizedState = null;\n                    fiber.pendingProps = null;\n                    fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n                    fiber.updateQueue = null;\n                }\n            }\n        }\n        function emptyPortalContainer(current) {\n            if (!supportsPersistence) {\n                return;\n            }\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet(containerInfo);\n            replaceContainerChildren(containerInfo, emptyChildSet);\n        }\n        function commitContainer(finishedWork) {\n            if (!supportsPersistence) {\n                return;\n            }\n            switch(finishedWork.tag){\n                case ClassComponent:\n                case HostComponent:\n                case HostText:\n                    {\n                        return;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var portalOrRoot = finishedWork.stateNode;\n                        var containerInfo = portalOrRoot.containerInfo, pendingChildren = portalOrRoot.pendingChildren;\n                        replaceContainerChildren(containerInfo, pendingChildren);\n                        return;\n                    }\n            }\n            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n        }\n        function getHostParentFiber(fiber) {\n            var parent = fiber.return;\n            while(parent !== null){\n                if (isHostParent(parent)) {\n                    return parent;\n                }\n                parent = parent.return;\n            }\n            throw new Error(\"Expected to find a host parent. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n        }\n        function isHostParent(fiber) {\n            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n            // We're going to search forward into the tree until we find a sibling host\n            // node. Unfortunately, if multiple insertions are done in a row we have to\n            // search past them. This leads to exponential search for the next sibling.\n            // TODO: Find a more efficient way to do this.\n            var node = fiber;\n            siblings: while(true){\n                // If we didn't find anything, let's try the next sibling.\n                while(node.sibling === null){\n                    if (node.return === null || isHostParent(node.return)) {\n                        // If we pop out of the root or hit the parent the fiber we are the\n                        // last sibling.\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n                while(node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment){\n                    // If it is not host node and, we might have a host node inside it.\n                    // Try to search down until we find one.\n                    if (node.flags & Placement) {\n                        continue siblings;\n                    } // If we don't have a child, try the siblings instead.\n                    // We also skip portals because they are not part of this host tree.\n                    if (node.child === null || node.tag === HostPortal) {\n                        continue siblings;\n                    } else {\n                        node.child.return = node;\n                        node = node.child;\n                    }\n                } // Check if this host node is stable or about to be placed.\n                if (!(node.flags & Placement)) {\n                    // Found it!\n                    return node.stateNode;\n                }\n            }\n        }\n        function commitPlacement(finishedWork) {\n            if (!supportsMutation) {\n                return;\n            } // Recursively insert all host nodes into the parent.\n            var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n            switch(parentFiber.tag){\n                case HostComponent:\n                    {\n                        var parent = parentFiber.stateNode;\n                        if (parentFiber.flags & ContentReset) {\n                            // Reset the text content of the parent before doing any insertions\n                            resetTextContent(parent); // Clear ContentReset from the effect tag\n                            parentFiber.flags &= ~ContentReset;\n                        }\n                        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                        // children to find all the terminal nodes.\n                        insertOrAppendPlacementNode(finishedWork, before, parent);\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var _parent = parentFiber.stateNode.containerInfo;\n                        var _before = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n                        break;\n                    }\n                // eslint-disable-next-line-no-fallthrough\n                default:\n                    throw new Error(\"Invalid host parent fiber. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n            }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertInContainerBefore(parent, stateNode, before);\n                } else {\n                    appendChildToContainer(parent, stateNode);\n                }\n            } else if (tag === HostPortal) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertBefore(parent, stateNode, before);\n                } else {\n                    appendChild(parent, stateNode);\n                }\n            } else if (tag === HostPortal) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNode(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNode(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function unmountHostComponents(finishedRoot, current, nearestMountedAncestor) {\n            // We only have the top Fiber that was deleted but we need to recurse down its\n            // children to find all the terminal nodes.\n            var node = current; // Each iteration, currentParent is populated with node's host parent if not\n            // currentParentIsValid.\n            var currentParentIsValid = false; // Note: these two variables *must* always be updated together.\n            var currentParent;\n            var currentParentIsContainer;\n            while(true){\n                if (!currentParentIsValid) {\n                    var parent = node.return;\n                    findParent: while(true){\n                        if (parent === null) {\n                            throw new Error(\"Expected to find a host parent. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n                        }\n                        var parentStateNode = parent.stateNode;\n                        switch(parent.tag){\n                            case HostComponent:\n                                currentParent = parentStateNode;\n                                currentParentIsContainer = false;\n                                break findParent;\n                            case HostRoot:\n                                currentParent = parentStateNode.containerInfo;\n                                currentParentIsContainer = true;\n                                break findParent;\n                            case HostPortal:\n                                currentParent = parentStateNode.containerInfo;\n                                currentParentIsContainer = true;\n                                break findParent;\n                        }\n                        parent = parent.return;\n                    }\n                    currentParentIsValid = true;\n                }\n                if (node.tag === HostComponent || node.tag === HostText) {\n                    commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor); // After all the children have unmounted, it is now safe to remove the\n                    // node from the tree.\n                    if (currentParentIsContainer) {\n                        removeChildFromContainer(currentParent, node.stateNode);\n                    } else {\n                        removeChild(currentParent, node.stateNode);\n                    } // Don't visit children because we already visited them.\n                } else if (node.tag === DehydratedFragment) {\n                    if (currentParentIsContainer) {\n                        clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);\n                    } else {\n                        clearSuspenseBoundary(currentParent, node.stateNode);\n                    }\n                } else if (node.tag === HostPortal) {\n                    if (node.child !== null) {\n                        // When we go into a portal, it becomes the parent to remove from.\n                        // We will reassign it back when we pop the portal on the way up.\n                        currentParent = node.stateNode.containerInfo;\n                        currentParentIsContainer = true; // Visit children because portals might contain host components.\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                } else {\n                    commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because we may find more host components below.\n                    if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                }\n                if (node === current) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === current) {\n                        return;\n                    }\n                    node = node.return;\n                    if (node.tag === HostPortal) {\n                        // When we go out of the portal, we need to restore the parent.\n                        // Since we don't keep a stack of them, we will search for it.\n                        currentParentIsValid = false;\n                    }\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function commitDeletion(finishedRoot, current, nearestMountedAncestor) {\n            if (supportsMutation) {\n                // Recursively delete all host nodes from the parent.\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n            } else {\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                commitNestedUnmounts(finishedRoot, current, nearestMountedAncestor);\n            }\n            detachFiberMutation(current);\n        }\n        function commitWork(current, finishedWork) {\n            if (!supportsMutation) {\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                            commitHookEffectListMount(Insertion | HasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n                            // destroy functions for all fibers are called before any create functions.\n                            // This prevents sibling component effects from interfering with each other,\n                            // e.g. a destroy function in one component should never override a ref set\n                            // by a create function in another component during the same commit.\n                            // TODO: Check if we're inside an Offscreen subtree that disappeared\n                            // during this commit. If so, we would have already unmounted its\n                            // layout hooks. (However, since we null out the `destroy` function\n                            // right before calling it, the behavior is already correct, so this\n                            // would mostly be for modeling purposes.)\n                            if (finishedWork.mode & ProfileMode) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } finally{\n                                    recordLayoutEffectDuration(finishedWork);\n                                }\n                            } else {\n                                commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                            }\n                            return;\n                        }\n                    case Profiler:\n                        {\n                            return;\n                        }\n                    case SuspenseComponent:\n                        {\n                            commitSuspenseCallback(finishedWork);\n                            attachSuspenseRetryListeners(finishedWork);\n                            return;\n                        }\n                    case SuspenseListComponent:\n                        {\n                            attachSuspenseRetryListeners(finishedWork);\n                            return;\n                        }\n                    case HostRoot:\n                        {\n                            if (supportsHydration) {\n                                if (current !== null) {\n                                    var prevRootState = current.memoizedState;\n                                    if (prevRootState.isDehydrated) {\n                                        var root = finishedWork.stateNode;\n                                        commitHydratedContainer(root.containerInfo);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case OffscreenComponent:\n                    case LegacyHiddenComponent:\n                        {\n                            return;\n                        }\n                }\n                commitContainer(finishedWork);\n                return;\n            }\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                        commitHookEffectListMount(Insertion | HasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n                        // destroy functions for all fibers are called before any create functions.\n                        // This prevents sibling component effects from interfering with each other,\n                        // e.g. a destroy function in one component should never override a ref set\n                        // by a create function in another component during the same commit.\n                        if (finishedWork.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                            } finally{\n                                recordLayoutEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        return;\n                    }\n                case HostComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        if (instance != null) {\n                            // Commit the work prepared earlier.\n                            var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                            // as the newProps. The updatePayload will contain the real change in\n                            // this case.\n                            var oldProps = current !== null ? current.memoizedProps : newProps;\n                            var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n                            var updatePayload = finishedWork.updateQueue;\n                            finishedWork.updateQueue = null;\n                            if (updatePayload !== null) {\n                                commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                            }\n                        }\n                        return;\n                    }\n                case HostText:\n                    {\n                        if (finishedWork.stateNode === null) {\n                            throw new Error(\"This should have a text node initialized. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                        }\n                        var textInstance = finishedWork.stateNode;\n                        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                        // as the newProps. The updatePayload will contain the real change in\n                        // this case.\n                        var oldText = current !== null ? current.memoizedProps : newText;\n                        commitTextUpdate(textInstance, oldText, newText);\n                        return;\n                    }\n                case HostRoot:\n                    {\n                        if (supportsHydration) {\n                            if (current !== null) {\n                                var _prevRootState = current.memoizedState;\n                                if (_prevRootState.isDehydrated) {\n                                    var _root = finishedWork.stateNode;\n                                    commitHydratedContainer(_root.containerInfo);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case Profiler:\n                    {\n                        return;\n                    }\n                case SuspenseComponent:\n                    {\n                        commitSuspenseCallback(finishedWork);\n                        attachSuspenseRetryListeners(finishedWork);\n                        return;\n                    }\n                case SuspenseListComponent:\n                    {\n                        attachSuspenseRetryListeners(finishedWork);\n                        return;\n                    }\n                case IncompleteClassComponent:\n                    {\n                        return;\n                    }\n            }\n            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n        }\n        function commitSuspenseCallback(finishedWork) {\n            // TODO: Move this to passive phase\n            var newState = finishedWork.memoizedState;\n        }\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n            if (!supportsHydration) {\n                return;\n            }\n            var newState = finishedWork.memoizedState;\n            if (newState === null) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        var suspenseInstance = prevState.dehydrated;\n                        if (suspenseInstance !== null) {\n                            commitHydratedSuspenseInstance(suspenseInstance);\n                        }\n                    }\n                }\n            }\n        }\n        function attachSuspenseRetryListeners(finishedWork) {\n            // If this boundary just timed out, then it will have a set of wakeables.\n            // For each wakeable, attach a listener so that when it resolves, React\n            // attempts to re-render the boundary in the primary (pre-timeout) state.\n            var wakeables = finishedWork.updateQueue;\n            if (wakeables !== null) {\n                finishedWork.updateQueue = null;\n                var retryCache = finishedWork.stateNode;\n                if (retryCache === null) {\n                    retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n                }\n                wakeables.forEach(function(wakeable) {\n                    // Memoize using the boundary fiber to prevent redundant listeners.\n                    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n                    if (!retryCache.has(wakeable)) {\n                        retryCache.add(wakeable);\n                        {\n                            if (isDevToolsPresent) {\n                                if (inProgressLanes !== null && inProgressRoot !== null) {\n                                    // If we have pending work still, associate the original updaters with it.\n                                    restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                                } else {\n                                    throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                                }\n                            }\n                        }\n                        wakeable.then(retry, retry);\n                    }\n                });\n            }\n        } // This function detects when a Suspense boundary goes from visible to hidden.\n        function commitResetTextContent(current) {\n            if (!supportsMutation) {\n                return;\n            }\n            resetTextContent(current.stateNode);\n        }\n        function commitMutationEffects(root, firstChild, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            nextEffect = firstChild;\n            commitMutationEffects_begin(root, committedLanes);\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function commitMutationEffects_begin(root, lanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // TODO: Should wrap this in flags check, too, as optimization\n                var deletions = fiber.deletions;\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i];\n                        try {\n                            commitDeletion(root, childToDelete, fiber);\n                        } catch (error) {\n                            reportUncaughtErrorInDEV(error);\n                            captureCommitPhaseError(childToDelete, fiber, error);\n                        }\n                    }\n                }\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitMutationEffects_complete(root, lanes);\n                }\n            }\n        }\n        function commitMutationEffects_complete(root, lanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentFiber(fiber);\n                try {\n                    commitMutationEffectsOnFiber(fiber, root, lanes);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n            // TODO: The factoring of this phase could probably be improved. Consider\n            // switching on the type of work before checking the flags. That's what\n            // we do in all the other phases. I think this one is only different\n            // because of the shared reconciliation logic below.\n            var flags = finishedWork.flags;\n            if (flags & ContentReset) {\n                commitResetTextContent(finishedWork);\n            }\n            if (flags & Ref) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    commitDetachRef(current);\n                }\n            }\n            if (flags & Visibility) {\n                switch(finishedWork.tag){\n                    case SuspenseComponent:\n                        {\n                            var newState = finishedWork.memoizedState;\n                            var isHidden = newState !== null;\n                            if (isHidden) {\n                                var _current = finishedWork.alternate;\n                                var wasHidden = _current !== null && _current.memoizedState !== null;\n                                if (!wasHidden) {\n                                    // TODO: Move to passive phase\n                                    markCommitTimeOfFallback();\n                                }\n                            }\n                            break;\n                        }\n                    case OffscreenComponent:\n                        {\n                            var _newState = finishedWork.memoizedState;\n                            var _isHidden = _newState !== null;\n                            var _current2 = finishedWork.alternate;\n                            var _wasHidden = _current2 !== null && _current2.memoizedState !== null;\n                            var offscreenBoundary = finishedWork;\n                            if (supportsMutation) {\n                                // TODO: This needs to run whenever there's an insertion or update\n                                // inside a hidden Offscreen tree.\n                                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n                            }\n                            {\n                                if (_isHidden) {\n                                    if (!_wasHidden) {\n                                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                                            nextEffect = offscreenBoundary;\n                                            var offscreenChild = offscreenBoundary.child;\n                                            while(offscreenChild !== null){\n                                                nextEffect = offscreenChild;\n                                                disappearLayoutEffects_begin(offscreenChild);\n                                                offscreenChild = offscreenChild.sibling;\n                                            }\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                }\n            } // The following switch statement is only concerned about placement,\n            // updates, and deletions. To avoid needing to add a case for every possible\n            // bitmap value, we remove the secondary effects from the effect tag and\n            // switch on that value.\n            var primaryFlags = flags & (Placement | Update | Hydrating);\n            switch(primaryFlags){\n                case Placement:\n                    {\n                        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n                        // inserted, before any life-cycles like componentDidMount gets called.\n                        // TODO: findDOMNode doesn't rely on this any more but isMounted does\n                        // and isMounted is deprecated anyway so we should be able to kill this.\n                        finishedWork.flags &= ~Placement;\n                        break;\n                    }\n                case PlacementAndUpdate:\n                    {\n                        // Placement\n                        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n                        // inserted, before any life-cycles like componentDidMount gets called.\n                        finishedWork.flags &= ~Placement; // Update\n                        var _current3 = finishedWork.alternate;\n                        commitWork(_current3, finishedWork);\n                        break;\n                    }\n                case Hydrating:\n                    {\n                        finishedWork.flags &= ~Hydrating;\n                        break;\n                    }\n                case HydratingAndUpdate:\n                    {\n                        finishedWork.flags &= ~Hydrating; // Update\n                        var _current4 = finishedWork.alternate;\n                        commitWork(_current4, finishedWork);\n                        break;\n                    }\n                case Update:\n                    {\n                        var _current5 = finishedWork.alternate;\n                        commitWork(_current5, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitLayoutEffects(finishedWork, root, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            nextEffect = finishedWork;\n            commitLayoutEffects_begin(finishedWork, root, committedLanes);\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n            // Suspense layout effects semantics don't change for legacy roots.\n            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if (fiber.tag === OffscreenComponent && isModernRoot) {\n                    // Keep track of the current Offscreen stack's state.\n                    var isHidden = fiber.memoizedState !== null;\n                    var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n                    if (newOffscreenSubtreeIsHidden) {\n                        // The Offscreen tree is hidden. Skip over its layout effects.\n                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                        continue;\n                    } else {\n                        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n                        var current = fiber.alternate;\n                        var wasHidden = current !== null && current.memoizedState !== null;\n                        var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n                        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                            // This is the root of a reappearing boundary. Turn its layout effects\n                            // back on.\n                            nextEffect = fiber;\n                            reappearLayoutEffects_begin(fiber);\n                        }\n                        var child = firstChild;\n                        while(child !== null){\n                            nextEffect = child;\n                            commitLayoutEffects_begin(child, root, committedLanes);\n                            child = child.sibling;\n                        } // Restore Offscreen state and resume in our-progress traversal.\n                        nextEffect = fiber;\n                        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                        continue;\n                    }\n                }\n                if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n                    ensureCorrectReturnPointer(firstChild, fiber);\n                    nextEffect = firstChild;\n                } else {\n                    commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                }\n            }\n        }\n        function commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & LayoutMask) !== NoFlags) {\n                    var current = fiber.alternate;\n                    setCurrentFiber(fiber);\n                    try {\n                        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(fiber, fiber.return, error);\n                    }\n                    resetCurrentFiber();\n                }\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function disappearLayoutEffects_begin(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if (fiber.mode & ProfileMode) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                                } finally{\n                                    recordLayoutEffectDuration(fiber);\n                                }\n                            } else {\n                                commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            // TODO (Offscreen) Check: flags & RefStatic\n                            safelyDetachRef(fiber, fiber.return);\n                            var instance = fiber.stateNode;\n                            if (typeof instance.componentWillUnmount === \"function\") {\n                                safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            safelyDetachRef(fiber, fiber.return);\n                            break;\n                        }\n                    case OffscreenComponent:\n                        {\n                            // Check if this is a\n                            var isHidden = fiber.memoizedState !== null;\n                            if (isHidden) {\n                                // Nested Offscreen tree is already hidden. Don't disappear\n                                // its effects.\n                                disappearLayoutEffects_complete(subtreeRoot);\n                                continue;\n                            }\n                            break;\n                        }\n                } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n                if (firstChild !== null) {\n                    firstChild.return = fiber;\n                    nextEffect = firstChild;\n                } else {\n                    disappearLayoutEffects_complete(subtreeRoot);\n                }\n            }\n        }\n        function disappearLayoutEffects_complete(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function reappearLayoutEffects_begin(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if (fiber.tag === OffscreenComponent) {\n                    var isHidden = fiber.memoizedState !== null;\n                    if (isHidden) {\n                        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n                        reappearLayoutEffects_complete(subtreeRoot);\n                        continue;\n                    }\n                } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n                if (firstChild !== null) {\n                    // This node may have been reused from a previous render, so we can't\n                    // assume its return pointer is correct.\n                    firstChild.return = fiber;\n                    nextEffect = firstChild;\n                } else {\n                    reappearLayoutEffects_complete(subtreeRoot);\n                }\n            }\n        }\n        function reappearLayoutEffects_complete(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n                setCurrentFiber(fiber);\n                try {\n                    reappearLayoutEffectsOnFiber(fiber);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    // This node may have been reused from a previous render, so we can't\n                    // assume its return pointer is correct.\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveMountEffects(root, finishedWork) {\n            nextEffect = finishedWork;\n            commitPassiveMountEffects_begin(finishedWork, root);\n        }\n        function commitPassiveMountEffects_begin(subtreeRoot, root) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n                    ensureCorrectReturnPointer(firstChild, fiber);\n                    nextEffect = firstChild;\n                } else {\n                    commitPassiveMountEffects_complete(subtreeRoot, root);\n                }\n            }\n        }\n        function commitPassiveMountEffects_complete(subtreeRoot, root) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & Passive) !== NoFlags) {\n                    setCurrentFiber(fiber);\n                    try {\n                        commitPassiveMountOnFiber(root, fiber);\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(fiber, fiber.return, error);\n                    }\n                    resetCurrentFiber();\n                }\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (finishedWork.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            try {\n                                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n                            } finally{\n                                recordPassiveEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n                        }\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffects(firstChild) {\n            nextEffect = firstChild;\n            commitPassiveUnmountEffects_begin();\n        }\n        function commitPassiveUnmountEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var child = fiber.child;\n                if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n                    var deletions = fiber.deletions;\n                    if (deletions !== null) {\n                        for(var i = 0; i < deletions.length; i++){\n                            var fiberToDelete = deletions[i];\n                            nextEffect = fiberToDelete;\n                            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n                        }\n                        {\n                            // A fiber was deleted from this parent fiber, but it's still part of\n                            // the previous (alternate) parent fiber's list of children. Because\n                            // children are a linked list, an earlier sibling that's still alive\n                            // will be connected to the deleted fiber via its `alternate`:\n                            //\n                            //   live fiber\n                            //   --alternate--> previous live fiber\n                            //   --sibling--> deleted fiber\n                            //\n                            // We can't disconnect `alternate` on nodes that haven't been deleted\n                            // yet, but we can disconnect the `sibling` and `child` pointers.\n                            var previousFiber = fiber.alternate;\n                            if (previousFiber !== null) {\n                                var detachedChild = previousFiber.child;\n                                if (detachedChild !== null) {\n                                    previousFiber.child = null;\n                                    do {\n                                        var detachedSibling = detachedChild.sibling;\n                                        detachedChild.sibling = null;\n                                        detachedChild = detachedSibling;\n                                    }while (detachedChild !== null);\n                                }\n                            }\n                        }\n                        nextEffect = fiber;\n                    }\n                }\n                if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffects_complete();\n                }\n            }\n        }\n        function commitPassiveUnmountEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & Passive) !== NoFlags) {\n                    setCurrentFiber(fiber);\n                    commitPassiveUnmountOnFiber(fiber);\n                    resetCurrentFiber();\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (finishedWork.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n                            recordPassiveEffectDuration(finishedWork);\n                        } else {\n                            commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // Deletion effects fire in parent -> child order\n                // TODO: Check if fiber has a PassiveStatic flag\n                setCurrentFiber(fiber);\n                commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n                resetCurrentFiber();\n                var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n                // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n                if (child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n                }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var sibling = fiber.sibling;\n                var returnFiber = fiber.return;\n                {\n                    // Recursively traverse the entire deleted tree and clean up fiber fields.\n                    // This is more aggressive than ideal, and the long term goal is to only\n                    // have to detach the deleted tree at the root.\n                    detachFiberAfterEffects(fiber);\n                    if (fiber === deletedSubtreeRoot) {\n                        nextEffect = null;\n                        return;\n                    }\n                }\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, returnFiber);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (current.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n                            recordPassiveEffectDuration(current);\n                        } else {\n                            commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n                        }\n                        break;\n                    }\n            }\n        }\n        var didWarnWrongReturnPointer = false;\n        function ensureCorrectReturnPointer(fiber, expectedReturnFiber) {\n            {\n                if (!didWarnWrongReturnPointer && fiber.return !== expectedReturnFiber) {\n                    didWarnWrongReturnPointer = true;\n                    error(\"Internal React error: Return pointer is inconsistent \" + \"with parent.\");\n                }\n            }\n            // anything, by checking the warning logs for the above invariant\n            fiber.return = expectedReturnFiber;\n        } // TODO: Reuse reappearLayoutEffects traversal here?\n        function invokeLayoutEffectMountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListMount(Layout | HasEffect, fiber);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = fiber.stateNode;\n                            try {\n                                instance.componentDidMount();\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokePassiveEffectMountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokeLayoutEffectUnmountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = fiber.stateNode;\n                            if (typeof instance.componentWillUnmount === \"function\") {\n                                safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokePassiveEffectUnmountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                        }\n                }\n            }\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === \"function\" && Symbol.for) {\n            var symbolFor = Symbol.for;\n            COMPONENT_TYPE = symbolFor(\"selector.component\");\n            HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n            ROLE_TYPE = symbolFor(\"selector.role\");\n            TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n            TEXT_TYPE = symbolFor(\"selector.text\");\n        }\n        function createComponentSelector(component) {\n            return {\n                $$typeof: COMPONENT_TYPE,\n                value: component\n            };\n        }\n        function createHasPseudoClassSelector(selectors) {\n            return {\n                $$typeof: HAS_PSEUDO_CLASS_TYPE,\n                value: selectors\n            };\n        }\n        function createRoleSelector(role) {\n            return {\n                $$typeof: ROLE_TYPE,\n                value: role\n            };\n        }\n        function createTextSelector(text) {\n            return {\n                $$typeof: TEXT_TYPE,\n                value: text\n            };\n        }\n        function createTestNameSelector(id) {\n            return {\n                $$typeof: TEST_NAME_TYPE,\n                value: id\n            };\n        }\n        function findFiberRootForHostRoot(hostRoot) {\n            var maybeFiber = getInstanceFromNode(hostRoot);\n            if (maybeFiber != null) {\n                if (typeof maybeFiber.memoizedProps[\"data-testname\"] !== \"string\") {\n                    throw new Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n                }\n                return maybeFiber;\n            } else {\n                var fiberRoot = findFiberRoot(hostRoot);\n                if (fiberRoot === null) {\n                    throw new Error(\"Could not find React container within specified host subtree.\");\n                } // The Flow type for FiberRoot is a little funky.\n                // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n                return fiberRoot.stateNode.current;\n            }\n        }\n        function matchSelector(fiber, selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    if (fiber.type === selector.value) {\n                        return true;\n                    }\n                    break;\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return hasMatchingPaths(fiber, selector.value);\n                case ROLE_TYPE:\n                    if (fiber.tag === HostComponent) {\n                        var node = fiber.stateNode;\n                        if (matchAccessibilityRole(node, selector.value)) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEXT_TYPE:\n                    if (fiber.tag === HostComponent || fiber.tag === HostText) {\n                        var textContent = getTextContent(fiber);\n                        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEST_NAME_TYPE:\n                    if (fiber.tag === HostComponent) {\n                        var dataTestID = fiber.memoizedProps[\"data-testname\"];\n                        if (typeof dataTestID === \"string\" && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n                            return true;\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error(\"Invalid selector type specified.\");\n            }\n            return false;\n        }\n        function selectorToString(selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    var displayName = getComponentNameFromType(selector.value) || \"Unknown\";\n                    return \"<\" + displayName + \">\";\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n                case ROLE_TYPE:\n                    return '[role=\"' + selector.value + '\"]';\n                case TEXT_TYPE:\n                    return '\"' + selector.value + '\"';\n                case TEST_NAME_TYPE:\n                    return '[data-testname=\"' + selector.value + '\"]';\n                default:\n                    throw new Error(\"Invalid selector type specified.\");\n            }\n        }\n        function findPaths(root, selectors) {\n            var matchingFibers = [];\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    matchingFibers.push(fiber);\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return matchingFibers;\n        } // Same as findPaths but with eager bailout on first match\n        function hasMatchingPaths(root, selectors) {\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    return true;\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return false;\n        }\n        function findAllNodes(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var instanceRoots = [];\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var node = stack[index++];\n                if (node.tag === HostComponent) {\n                    if (isHiddenSubtree(node)) {\n                        continue;\n                    }\n                    instanceRoots.push(node.stateNode);\n                } else {\n                    var child = node.child;\n                    while(child !== null){\n                        stack.push(child);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return instanceRoots;\n        }\n        function getFindAllNodesFailureDescription(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var maxSelectorIndex = 0;\n            var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else if (matchSelector(fiber, selector)) {\n                    matchedNames.push(selectorToString(selector));\n                    selectorIndex++;\n                    if (selectorIndex > maxSelectorIndex) {\n                        maxSelectorIndex = selectorIndex;\n                    }\n                }\n                if (selectorIndex < selectors.length) {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            if (maxSelectorIndex < selectors.length) {\n                var unmatchedNames = [];\n                for(var i = maxSelectorIndex; i < selectors.length; i++){\n                    unmatchedNames.push(selectorToString(selectors[i]));\n                }\n                return \"findAllNodes was able to match part of the selector:\\n\" + (\"  \" + matchedNames.join(\" > \") + \"\\n\\n\") + \"No matching component was found for:\\n\" + (\"  \" + unmatchedNames.join(\" > \"));\n            }\n            return null;\n        }\n        function findBoundingRects(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var boundingRects = [];\n            for(var i = 0; i < instanceRoots.length; i++){\n                boundingRects.push(getBoundingRect(instanceRoots[i]));\n            }\n            for(var _i = boundingRects.length - 1; _i > 0; _i--){\n                var targetRect = boundingRects[_i];\n                var targetLeft = targetRect.x;\n                var targetRight = targetLeft + targetRect.width;\n                var targetTop = targetRect.y;\n                var targetBottom = targetTop + targetRect.height;\n                for(var j = _i - 1; j >= 0; j--){\n                    if (_i !== j) {\n                        var otherRect = boundingRects[j];\n                        var otherLeft = otherRect.x;\n                        var otherRight = otherLeft + otherRect.width;\n                        var otherTop = otherRect.y;\n                        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n                        // but we can handle the most common cases:\n                        // 1. completely overlapping rects\n                        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n                        //\n                        // Even given the above constraints,\n                        // we still won't end up with the fewest possible rects without doing multiple passes,\n                        // but it's good enough for this purpose.\n                        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                            // Complete overlapping rects; remove the inner one.\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n                            // Adjacent vertical rects; merge them.\n                            if (otherTop > targetTop) {\n                                otherRect.height += otherTop - targetTop;\n                                otherRect.y = targetTop;\n                            }\n                            if (otherBottom < targetBottom) {\n                                otherRect.height = targetBottom - otherTop;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n                            // Adjacent horizontal rects; merge them.\n                            if (otherLeft > targetLeft) {\n                                otherRect.width += otherLeft - targetLeft;\n                                otherRect.x = targetLeft;\n                            }\n                            if (otherRight < targetRight) {\n                                otherRect.width = targetRight - otherLeft;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            return boundingRects;\n        }\n        function focusWithin(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                if (isHiddenSubtree(fiber)) {\n                    continue;\n                }\n                if (fiber.tag === HostComponent) {\n                    var node = fiber.stateNode;\n                    if (setFocusIfFocusable(node)) {\n                        return true;\n                    }\n                }\n                var child = fiber.child;\n                while(child !== null){\n                    stack.push(child);\n                    child = child.sibling;\n                }\n            }\n            return false;\n        }\n        var commitHooks = [];\n        function onCommitRoot$1() {\n            if (supportsTestSelectors) {\n                commitHooks.forEach(function(commitHook) {\n                    return commitHook();\n                });\n            }\n        }\n        function observeVisibleRects(hostRoot, selectors, callback, options) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n            var commitHook = function() {\n                var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n                instanceRoots.forEach(function(target) {\n                    if (nextInstanceRoots.indexOf(target) < 0) {\n                        unobserve(target);\n                    }\n                });\n                nextInstanceRoots.forEach(function(target) {\n                    if (instanceRoots.indexOf(target) < 0) {\n                        observe(target);\n                    }\n                });\n            };\n            commitHooks.push(commitHook);\n            return {\n                disconnect: function() {\n                    // Stop listening for React mutations:\n                    var index = commitHooks.indexOf(commitHook);\n                    if (index >= 0) {\n                        commitHooks.splice(index, 1);\n                    } // Disconnect the host observer:\n                    disconnect();\n                }\n            };\n        }\n        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\n        function isLegacyActEnvironment(fiber) {\n            {\n                // Legacy mode. We preserve the behavior of React 17's act. It assumes an\n                // act environment whenever `jest` is defined, but you can still turn off\n                // spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n                // to false.\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : undefined; // $FlowExpectedError - Flow doesn't know about jest\n                var jestIsDefined = typeof jest !== \"undefined\";\n                return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;\n            }\n        }\n        function isConcurrentActEnvironment() {\n            {\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : undefined;\n                if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n                    // TODO: Include link to relevant documentation page.\n                    error(\"The current testing environment is not configured to support \" + \"act(...)\");\n                }\n                return isReactActEnvironmentGlobal;\n            }\n        }\n        var ceil = Math.ceil;\n        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\n        var NoContext = /*             */ 0;\n        var BatchedContext = /*               */ 1;\n        var RenderContext = /*                */ 2;\n        var CommitContext = /*                */ 4;\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6; // Describes where we are in the React execution stack\n        var executionContext = NoContext; // The root we're working on\n        var workInProgressRoot = null; // The fiber we're working on\n        var workInProgress = null; // The lanes we're rendering\n        var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n        // This is a superset of the lanes we started working on at the root. The only\n        // case where it's different from `workInProgressRootRenderLanes` is when we\n        // enter a subtree that is hidden and needs to be unhidden: Suspense and\n        // Offscreen component.\n        //\n        // Most things in the work loop should deal with workInProgressRootRenderLanes.\n        // Most things in begin/complete phases should deal with subtreeRenderLanes.\n        var subtreeRenderLanes = NoLanes;\n        var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n        var workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n        var workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n        // slightly different than `renderLanes` because `renderLanes` can change as you\n        // enter and exit an Offscreen tree. This value is the combination of all render\n        // lanes for the entire render phase.\n        var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\n        // includes unprocessed updates, not work in bailed out children.\n        var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n        var workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n        var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n        // We will log them once the tree commits.\n        var workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n        // model where we don't commit new loading states in too quick succession.\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n        // more and prefer CPU suspense heuristics instead.\n        var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n        // suspense heuristics and opt out of rendering more content.\n        var RENDER_TIMEOUT_MS = 500;\n        function resetRenderTimer() {\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n            return workInProgressRootRenderTargetTime;\n        }\n        var hasUncaughtError = false;\n        var firstUncaughtError = null;\n        var legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0; // If two updates are scheduled within the same event, we should treat their\n        // event times as simultaneous, even if the actual clock time has advanced\n        // between the first and second call.\n        var currentEventTime = NoTimestamp;\n        var currentEventTransitionLane = NoLanes;\n        function getWorkInProgressRoot() {\n            return workInProgressRoot;\n        }\n        function requestEventTime() {\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                // We're inside React, so it's fine to read the actual time.\n                return now$1();\n            } // We're not inside React, so we may be in the middle of a browser event.\n            if (currentEventTime !== NoTimestamp) {\n                // Use the same start time for all updates until we enter React again.\n                return currentEventTime;\n            } // This is the first update since React yielded. Compute a new start time.\n            currentEventTime = now$1();\n            return currentEventTime;\n        }\n        function requestUpdateLane(fiber) {\n            // Special cases\n            var mode = fiber.mode;\n            if ((mode & ConcurrentMode) === NoMode) {\n                return SyncLane;\n            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n                // This is a render phase update. These are not officially supported. The\n                // old behavior is to give this the same \"thread\" (lanes) as\n                // whatever is currently rendering. So if you call `setState` on a component\n                // that happens later in the same render, it will flush. Ideally, we want to\n                // remove the special case and treat them as if they came from an\n                // interleaved event. Regardless, this pattern is not officially supported.\n                // This behavior is only a fallback. The flag only exists until we can roll\n                // out the setState warning, since existing code might accidentally rely on\n                // the current behavior.\n                return pickArbitraryLane(workInProgressRootRenderLanes);\n            }\n            var isTransition = requestCurrentTransition() !== NoTransition;\n            if (isTransition) {\n                if (ReactCurrentBatchConfig$2.transition !== null) {\n                    var transition = ReactCurrentBatchConfig$2.transition;\n                    if (!transition._updatedFibers) {\n                        transition._updatedFibers = new Set();\n                    }\n                    transition._updatedFibers.add(fiber);\n                } // The algorithm for assigning an update to a lane should be stable for all\n                // updates at the same priority within the same event. To do this, the\n                // inputs to the algorithm must be the same.\n                //\n                // The trick we use is to cache the first of each of these inputs within an\n                // event. Then reset the cached values once we can be sure the event is\n                // over. Our heuristic for that is whenever we enter a concurrent work loop.\n                if (currentEventTransitionLane === NoLane) {\n                    // All transitions within the same event are assigned the same lane.\n                    currentEventTransitionLane = claimNextTransitionLane();\n                }\n                return currentEventTransitionLane;\n            } // Updates originating inside certain React methods, like flushSync, have\n            // their priority set by tracking it with a context variable.\n            //\n            // The opaque type returned by the host config is internally a lane, so we can\n            // use that directly.\n            // TODO: Move this type conversion to the event priority module.\n            var updateLane = getCurrentUpdatePriority();\n            if (updateLane !== NoLane) {\n                return updateLane;\n            } // This update originated outside React. Ask the host environment for an\n            // appropriate priority, based on the type of event.\n            //\n            // The opaque type returned by the host config is internally a lane, so we can\n            // use that directly.\n            // TODO: Move this type conversion to the event priority module.\n            var eventLane = getCurrentEventPriority();\n            return eventLane;\n        }\n        function requestRetryLane(fiber) {\n            // This is a fork of `requestUpdateLane` designed specifically for Suspense\n            // \"retries\" — a special update that attempts to flip a Suspense boundary\n            // from its placeholder state to its primary/resolved state.\n            // Special cases\n            var mode = fiber.mode;\n            if ((mode & ConcurrentMode) === NoMode) {\n                return SyncLane;\n            }\n            return claimNextRetryLane();\n        }\n        function scheduleUpdateOnFiber(fiber, lane, eventTime) {\n            checkForNestedUpdates();\n            var root = markUpdateLaneFromFiberToRoot(fiber, lane);\n            if (root === null) {\n                return null;\n            } // Mark that the root has a pending update.\n            markRootUpdated(root, lane, eventTime);\n            if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n                // This update was dispatched during the render phase. This is a mistake\n                // if the update originates from user space (with the exception of local\n                // hook updates, which are handled differently and don't reach this\n                // function), but there are some internal React features that use this as\n                // an implementation detail, like selective hydration.\n                warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n            } else {\n                // This is a normal update, scheduled from outside the render phase. For\n                // example, during an input event.\n                {\n                    if (isDevToolsPresent) {\n                        addFiberToLanesMap(root, fiber, lane);\n                    }\n                }\n                warnIfUpdatesNotWrappedWithActDEV(fiber);\n                if (root === workInProgressRoot) {\n                    // TODO: Consolidate with `isInterleavedUpdate` check\n                    // Received an update to a tree that's in the middle of rendering. Mark\n                    // that there was an interleaved update work on this root. Unless the\n                    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n                    // phase update. In that case, we don't treat render phase updates as if\n                    // they were interleaved, for backwards compat reasons.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n                    }\n                    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                        // The root already suspended with a delay, which means this render\n                        // definitely won't finish. Since we have a new update, let's mark it as\n                        // suspended now, right before marking the incoming update. This has the\n                        // effect of interrupting the current render and switching to the update.\n                        // TODO: Make sure this doesn't override pings that happen while we've\n                        // already started rendering.\n                        markRootSuspended$1(root, workInProgressRootRenderLanes);\n                    }\n                }\n                ensureRootIsScheduled(root, eventTime);\n                if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n                !ReactCurrentActQueue$1.isBatchingLegacy) {\n                    // Flush the synchronous work now, unless we're already working or inside\n                    // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                    // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                    // without immediately flushing it. We only do this for user-initiated\n                    // updates, to preserve historical behavior of legacy mode.\n                    resetRenderTimer();\n                    flushSyncCallbacksOnlyInLegacyMode();\n                }\n            }\n            return root;\n        }\n        function scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n            // This is a special fork of scheduleUpdateOnFiber that is only used to\n            // schedule the initial hydration of a root that has just been created. Most\n            // of the stuff in scheduleUpdateOnFiber can be skipped.\n            //\n            // The main reason for this separate path, though, is to distinguish the\n            // initial children from subsequent updates. In fully client-rendered roots\n            // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n            // updates, but hydration roots are special because the initial render must\n            // match what was rendered on the server.\n            var current = root.current;\n            current.lanes = lane;\n            markRootUpdated(root, lane, eventTime);\n            ensureRootIsScheduled(root, eventTime);\n        } // This is split into a separate function so we can mark a fiber with pending\n        // work without treating it as a typical update that originates from an event;\n        // e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n        // on a fiber.\n        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n            // Update the source fiber's lanes\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n            var alternate = sourceFiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            }\n            {\n                if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n            }\n            var node = sourceFiber;\n            var parent = sourceFiber.return;\n            while(parent !== null){\n                parent.childLanes = mergeLanes(parent.childLanes, lane);\n                alternate = parent.alternate;\n                if (alternate !== null) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n                } else {\n                    {\n                        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n                            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                        }\n                    }\n                }\n                node = parent;\n                parent = parent.return;\n            }\n            if (node.tag === HostRoot) {\n                var root = node.stateNode;\n                return root;\n            } else {\n                return null;\n            }\n        }\n        function isInterleavedUpdate(fiber, lane) {\n            return(// Requires some refactoring. Not a big deal though since it's rare for\n            // concurrent apps to have more than a single root.\n            workInProgressRoot !== null && (fiber.mode & ConcurrentMode) !== NoMode && // then don't treat this as an interleaved update. This pattern is\n            // accompanied by a warning but we haven't fully deprecated it yet. We can\n            // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n            (executionContext & RenderContext) === NoContext);\n        } // Use this function to schedule a task for a root. There's only one task per\n        // root; if a task was already scheduled, we'll check to make sure the priority\n        // of the existing task is the same as the priority of the next level that the\n        // root has work on. This function is called on every update, and right before\n        // exiting a task.\n        function ensureRootIsScheduled(root, currentTime) {\n            var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n            // expired so we know to work on those next.\n            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (nextLanes === NoLanes) {\n                // Special case: There's nothing to work on.\n                if (existingCallbackNode !== null) {\n                    cancelCallback$1(existingCallbackNode);\n                }\n                root.callbackNode = null;\n                root.callbackPriority = NoLane;\n                return;\n            } // We use the highest priority lane to represent the priority of the callback.\n            var newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n            var existingCallbackPriority = root.callbackPriority;\n            if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n            // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n            // on the `act` queue.\n            !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n                {\n                    // If we're going to re-use an existing task, it needs to exist.\n                    // Assume that discrete update microtasks are non-cancellable and null.\n                    // TODO: Temporary until we confirm this warning is not fired.\n                    if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n                        error(\"Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.\");\n                    }\n                }\n                return;\n            }\n            if (existingCallbackNode != null) {\n                // Cancel the existing callback. We'll schedule a new one below.\n                cancelCallback$1(existingCallbackNode);\n            } // Schedule a new callback.\n            var newCallbackNode;\n            if (newCallbackPriority === SyncLane) {\n                // Special case: Sync React callbacks are scheduled on a special\n                // internal queue\n                if (root.tag === LegacyRoot) {\n                    if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n                        ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n                    }\n                    scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n                } else {\n                    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n                }\n                if (supportsMicrotasks) {\n                    // Flush the queue in a microtask.\n                    if (ReactCurrentActQueue$1.current !== null) {\n                        // Inside `act`, use our internal `act` queue so that these get flushed\n                        // at the end of the current scope even when using the sync version\n                        // of `act`.\n                        ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n                    } else {\n                        scheduleMicrotask(function() {\n                            // In Safari, appending an iframe forces microtasks to run.\n                            // https://github.com/facebook/react/issues/22459\n                            // We don't support running callbacks in the middle of render\n                            // or commit so we need to check against that.\n                            if (executionContext === NoContext) {\n                                // It's only safe to do this conditionally because we always\n                                // check for pending work before we exit the task.\n                                flushSyncCallbacks();\n                            }\n                        });\n                    }\n                } else {\n                    // Flush the queue in an Immediate task.\n                    scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);\n                }\n                newCallbackNode = null;\n            } else {\n                var schedulerPriorityLevel;\n                switch(lanesToEventPriority(nextLanes)){\n                    case DiscreteEventPriority:\n                        schedulerPriorityLevel = ImmediatePriority;\n                        break;\n                    case ContinuousEventPriority:\n                        schedulerPriorityLevel = UserBlockingPriority;\n                        break;\n                    case DefaultEventPriority:\n                        schedulerPriorityLevel = NormalPriority;\n                        break;\n                    case IdleEventPriority:\n                        schedulerPriorityLevel = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriorityLevel = NormalPriority;\n                        break;\n                }\n                newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n            }\n            root.callbackPriority = newCallbackPriority;\n            root.callbackNode = newCallbackNode;\n        } // This is the entry point for every concurrent task, i.e. anything that\n        // goes through Scheduler.\n        function performConcurrentWorkOnRoot(root, didTimeout) {\n            {\n                resetNestedUpdateFlag();\n            }\n            // event time. The next update will compute a new event time.\n            currentEventTime = NoTimestamp;\n            currentEventTransitionLane = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            } // Flush any pending passive effects before deciding which lanes to work on,\n            // in case they schedule additional work.\n            var originalCallbackNode = root.callbackNode;\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // Something in the passive effect phase may have canceled the current task.\n                // Check if the task node for this root was changed.\n                if (root.callbackNode !== originalCallbackNode) {\n                    // The current task was canceled. Exit. We don't need to call\n                    // `ensureRootIsScheduled` because the check above implies either that\n                    // there's a new task, or that there's no remaining work on this root.\n                    return null;\n                }\n            } // Determine the next lanes to work on, using the fields stored\n            // on the root.\n            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (lanes === NoLanes) {\n                // Defensive coding. This is never expected to happen.\n                return null;\n            } // We disable time-slicing in some cases: if the work has been CPU-bound\n            // for too long (\"expired\" work, to prevent starvation), or we're in\n            // sync-updates-by-default mode.\n            // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n            // bug we're still investigating. Once the bug in Scheduler is fixed,\n            // we can remove this, since we track expiration ourselves.\n            var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;\n            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n            if (exitStatus !== RootInProgress) {\n                if (exitStatus === RootErrored) {\n                    // If something threw an error, try rendering one more time. We'll\n                    // render synchronously to block concurrent data mutations, and we'll\n                    // includes all pending updates are included. If it still fails after\n                    // the second attempt, we'll give up and commit the resulting tree.\n                    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                    if (errorRetryLanes !== NoLanes) {\n                        lanes = errorRetryLanes;\n                        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    var fatalError = workInProgressRootFatalError;\n                    prepareFreshStack(root, NoLanes);\n                    markRootSuspended$1(root, lanes);\n                    ensureRootIsScheduled(root, now$1());\n                    throw fatalError;\n                }\n                if (exitStatus === RootDidNotComplete) {\n                    // The render unwound without completing the tree. This happens in special\n                    // cases where need to exit the current render without producing a\n                    // consistent tree or committing.\n                    //\n                    // This should only happen during a concurrent render, not a discrete or\n                    // synchronous update. We should have already checked for this when we\n                    // unwound the stack.\n                    markRootSuspended$1(root, lanes);\n                } else {\n                    // The render completed.\n                    // Check if this render may have yielded to a concurrent event, and if so,\n                    // confirm that any newly rendered stores are consistent.\n                    // TODO: It's possible that even a concurrent render may never have yielded\n                    // to the main thread, if it was fast enough, or if it expired. We could\n                    // skip the consistency check in that case, too.\n                    var renderWasConcurrent = !includesBlockingLane(root, lanes);\n                    var finishedWork = root.current.alternate;\n                    if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                        // A store was mutated in an interleaved event. Render again,\n                        // synchronously, to block further mutations.\n                        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n                        if (exitStatus === RootErrored) {\n                            var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                            if (_errorRetryLanes !== NoLanes) {\n                                lanes = _errorRetryLanes;\n                                exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n                            // concurrent events.\n                            }\n                        }\n                        if (exitStatus === RootFatalErrored) {\n                            var _fatalError = workInProgressRootFatalError;\n                            prepareFreshStack(root, NoLanes);\n                            markRootSuspended$1(root, lanes);\n                            ensureRootIsScheduled(root, now$1());\n                            throw _fatalError;\n                        }\n                    } // We now have a consistent tree. The next step is either to commit it,\n                    // or, if something suspended, wait to commit it after a timeout.\n                    root.finishedWork = finishedWork;\n                    root.finishedLanes = lanes;\n                    finishConcurrentRender(root, exitStatus, lanes);\n                }\n            }\n            ensureRootIsScheduled(root, now$1());\n            if (root.callbackNode === originalCallbackNode) {\n                // The task node scheduled for this root is the same one that's\n                // currently executed. Need to return a continuation.\n                return performConcurrentWorkOnRoot.bind(null, root);\n            }\n            return null;\n        }\n        function recoverFromConcurrentError(root, errorRetryLanes) {\n            // If an error occurred during hydration, discard server response and fall\n            // back to client side render.\n            // Before rendering again, save the errors from the previous attempt.\n            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n            if (isRootDehydrated(root)) {\n                // The shell failed to hydrate. Set a flag to force a client rendering\n                // during the next attempt. To do this, we call prepareFreshStack now\n                // to create the root work-in-progress fiber. This is a bit weird in terms\n                // of factoring, because it relies on renderRootSync not calling\n                // prepareFreshStack again in the call below, which happens because the\n                // root and lanes haven't changed.\n                //\n                // TODO: I think what we should do is set ForceClientRender inside\n                // throwException, like we do for nested Suspense boundaries. The reason\n                // it's here instead is so we can switch to the synchronous work loop, too.\n                // Something to consider for a future refactor.\n                var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n                rootWorkInProgress.flags |= ForceClientRender;\n                {\n                    errorHydratingContainer(root.containerInfo);\n                }\n            }\n            var exitStatus = renderRootSync(root, errorRetryLanes);\n            if (exitStatus !== RootErrored) {\n                // Successfully finished rendering on retry\n                // The errors from the failed first attempt have been recovered. Add\n                // them to the collection of recoverable errors. We'll log them in the\n                // commit phase.\n                var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n                workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n                // from the first attempt, to preserve the causal sequence.\n                if (errorsFromSecondAttempt !== null) {\n                    queueRecoverableErrors(errorsFromSecondAttempt);\n                }\n            }\n            return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n            if (workInProgressRootRecoverableErrors === null) {\n                workInProgressRootRecoverableErrors = errors;\n            } else {\n                workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n            }\n        }\n        function finishConcurrentRender(root, exitStatus, lanes) {\n            switch(exitStatus){\n                case RootInProgress:\n                case RootFatalErrored:\n                    {\n                        throw new Error(\"Root did not complete. This is a bug in React.\");\n                    }\n                // Flow knows about invariant, so it complains if I add a break\n                // statement, but eslint doesn't know about invariant, so it complains\n                // if I do. eslint-disable-next-line no-fallthrough\n                case RootErrored:\n                    {\n                        // We should have already attempted to retry this tree. If we reached\n                        // this point, it errored again. Commit it.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootSuspended:\n                    {\n                        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we\n                        // should immediately commit it or wait a bit.\n                        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n                        !shouldForceFlushFallbacksInDEV()) {\n                            // This render only included retries, no updates. Throttle committing\n                            // retries so that we don't show too many loading states too quickly.\n                            var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(); // Don't bother with a very short suspense time.\n                            if (msUntilTimeout > 10) {\n                                var nextLanes = getNextLanes(root, NoLanes);\n                                if (nextLanes !== NoLanes) {\n                                    break;\n                                }\n                                var suspendedLanes = root.suspendedLanes;\n                                if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n                                    // We should prefer to render the fallback of at the last\n                                    // suspended level. Ping the last suspended level to try\n                                    // rendering it again.\n                                    // FIXME: What if the suspended lanes are Idle? Should not restart.\n                                    var eventTime = requestEventTime();\n                                    markRootPinged(root, suspendedLanes);\n                                    break;\n                                } // The render is suspended, it hasn't timed out, and there's no\n                                // lower priority work to do. Instead of committing the fallback\n                                // immediately, wait for more data to arrive.\n                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), msUntilTimeout);\n                                break;\n                            }\n                        } // The work expired. Commit immediately.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootSuspendedWithDelay:\n                    {\n                        markRootSuspended$1(root, lanes);\n                        if (includesOnlyTransitions(lanes)) {\n                            break;\n                        }\n                        if (!shouldForceFlushFallbacksInDEV()) {\n                            // This is not a transition, but we did trigger an avoided state.\n                            // Schedule a placeholder to display after a short delay, using the Just\n                            // Noticeable Difference.\n                            // TODO: Is the JND optimization worth the added complexity? If this is\n                            // the only reason we track the event time, then probably not.\n                            // Consider removing.\n                            var mostRecentEventTime = getMostRecentEventTime(root, lanes);\n                            var eventTimeMs = mostRecentEventTime;\n                            var timeElapsedMs = now$1() - eventTimeMs;\n                            var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n                            if (_msUntilTimeout > 10) {\n                                // Instead of committing the fallback immediately, wait for more data\n                                // to arrive.\n                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), _msUntilTimeout);\n                                break;\n                            }\n                        } // Commit the placeholder.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootCompleted:\n                    {\n                        // The work completed. Ready to commit.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown root exit status.\");\n                    }\n            }\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n            // Search the rendered tree for external store reads, and check whether the\n            // stores were mutated in a concurrent event. Intentionally using an iterative\n            // loop instead of recursion so we can exit early.\n            var node = finishedWork;\n            while(true){\n                if (node.flags & StoreConsistency) {\n                    var updateQueue = node.updateQueue;\n                    if (updateQueue !== null) {\n                        var checks = updateQueue.stores;\n                        if (checks !== null) {\n                            for(var i = 0; i < checks.length; i++){\n                                var check = checks[i];\n                                var getSnapshot = check.getSnapshot;\n                                var renderedValue = check.value;\n                                try {\n                                    if (!objectIs(getSnapshot(), renderedValue)) {\n                                        // Found an inconsistent store.\n                                        return false;\n                                    }\n                                } catch (error) {\n                                    // If `getSnapshot` throws, return `false`. This will schedule\n                                    // a re-render, and the error will be rethrown during render.\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                }\n                var child = node.child;\n                if (node.subtreeFlags & StoreConsistency && child !== null) {\n                    child.return = node;\n                    node = child;\n                    continue;\n                }\n                if (node === finishedWork) {\n                    return true;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === finishedWork) {\n                        return true;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            } // Flow doesn't know this is unreachable, but eslint does\n            // eslint-disable-next-line no-unreachable\n            return true;\n        }\n        function markRootSuspended$1(root, suspendedLanes) {\n            // When suspending, we should always exclude lanes that were pinged or (more\n            // rarely, since we try to avoid it) updated during the render phase.\n            // TODO: Lol maybe there's a better way to factor this besides this\n            // obnoxiously named function :)\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n            markRootSuspended(root, suspendedLanes);\n        } // This is the entry point for synchronous tasks that don't go\n        // through Scheduler\n        function performSyncWorkOnRoot(root) {\n            {\n                syncNestedUpdateFlag();\n            }\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            }\n            flushPassiveEffects();\n            var lanes = getNextLanes(root, NoLanes);\n            if (!includesSomeLane(lanes, SyncLane)) {\n                // There's no remaining sync work left.\n                ensureRootIsScheduled(root, now$1());\n                return null;\n            }\n            var exitStatus = renderRootSync(root, lanes);\n            if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n                // If something threw an error, try rendering one more time. We'll render\n                // synchronously to block concurrent data mutations, and we'll includes\n                // all pending updates are included. If it still fails after the second\n                // attempt, we'll give up and commit the resulting tree.\n                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                if (errorRetryLanes !== NoLanes) {\n                    lanes = errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n                }\n            }\n            if (exitStatus === RootFatalErrored) {\n                var fatalError = workInProgressRootFatalError;\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended$1(root, lanes);\n                ensureRootIsScheduled(root, now$1());\n                throw fatalError;\n            }\n            if (exitStatus === RootDidNotComplete) {\n                throw new Error(\"Root did not complete. This is a bug in React.\");\n            } // We now have a consistent tree. Because this is a sync render, we\n            // will commit it even if something suspended.\n            var finishedWork = root.current.alternate;\n            root.finishedWork = finishedWork;\n            root.finishedLanes = lanes;\n            commitRoot(root, workInProgressRootRecoverableErrors); // Before exiting, make sure there's a callback scheduled for the next\n            // pending level.\n            ensureRootIsScheduled(root, now$1());\n            return null;\n        }\n        function flushRoot(root, lanes) {\n            if (lanes !== NoLanes) {\n                markRootEntangled(root, mergeLanes(lanes, SyncLane));\n                ensureRootIsScheduled(root, now$1());\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    resetRenderTimer();\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function deferredUpdates(fn) {\n            var previousPriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DefaultEventPriority);\n                return fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n            }\n        }\n        function batchedUpdates(fn, a) {\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            try {\n                return fn(a);\n            } finally{\n                executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n                // most batchedUpdates-like method.\n                if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n                !ReactCurrentActQueue$1.isBatchingLegacy) {\n                    resetRenderTimer();\n                    flushSyncCallbacksOnlyInLegacyMode();\n                }\n            }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n            var previousPriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                return fn(a, b, c, d);\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                if (executionContext === NoContext) {\n                    resetRenderTimer();\n                }\n            }\n        } // Overload the definition to the two valid signatures.\n        // Warning, this opts-out of checking the function body.\n        // eslint-disable-next-line no-redeclare\n        function flushSync(fn) {\n            // In legacy mode, we flush pending passive effects at the beginning of the\n            // next event, not at the end of the previous one.\n            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushPassiveEffects();\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                if (fn) {\n                    return fn();\n                } else {\n                    return undefined;\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n                // Note that this will happen even if batchedUpdates is higher up\n                // the stack.\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function isAlreadyRendering() {\n            // Used by the renderer to print a warning if certain APIs are called from\n            // the wrong context.\n            return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        function flushControlled(fn) {\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                executionContext = prevExecutionContext;\n                if (executionContext === NoContext) {\n                    // Flush the immediate callbacks that were scheduled during this batch\n                    resetRenderTimer();\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function pushRenderLanes(fiber, lanes) {\n            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n        }\n        function popRenderLanes(fiber) {\n            subtreeRenderLanes = subtreeRenderLanesCursor.current;\n            pop(subtreeRenderLanesCursor, fiber);\n        }\n        function prepareFreshStack(root, lanes) {\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            var timeoutHandle = root.timeoutHandle;\n            if (timeoutHandle !== noTimeout) {\n                // The root previous suspended and scheduled a timeout to commit a fallback\n                // state. Now that we have additional work, cancel the timeout.\n                root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n                cancelTimeout(timeoutHandle);\n            }\n            if (workInProgress !== null) {\n                var interruptedWork = workInProgress.return;\n                while(interruptedWork !== null){\n                    var current = interruptedWork.alternate;\n                    unwindInterruptedWork(current, interruptedWork);\n                    interruptedWork = interruptedWork.return;\n                }\n            }\n            workInProgressRoot = root;\n            var rootWorkInProgress = createWorkInProgress(root.current, null);\n            workInProgress = rootWorkInProgress;\n            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n            workInProgressRootExitStatus = RootInProgress;\n            workInProgressRootFatalError = null;\n            workInProgressRootSkippedLanes = NoLanes;\n            workInProgressRootInterleavedUpdatedLanes = NoLanes;\n            workInProgressRootPingedLanes = NoLanes;\n            workInProgressRootConcurrentErrors = null;\n            workInProgressRootRecoverableErrors = null;\n            enqueueInterleavedUpdates();\n            {\n                ReactStrictModeWarnings.discardPendingWarnings();\n            }\n            return rootWorkInProgress;\n        }\n        function handleError(root, thrownValue) {\n            do {\n                var erroredWork = workInProgress;\n                try {\n                    // Reset module-level state that was set during the render phase.\n                    resetContextDependencies();\n                    resetHooksAfterThrow();\n                    resetCurrentFiber(); // TODO: I found and added this missing line while investigating a\n                    // separate issue. Write a regression test using string refs.\n                    ReactCurrentOwner$2.current = null;\n                    if (erroredWork === null || erroredWork.return === null) {\n                        // Expected to be working on a non-root fiber. This is a fatal error\n                        // because there's no ancestor that can handle it; the root is\n                        // supposed to capture all errors that weren't caught by an error\n                        // boundary.\n                        workInProgressRootExitStatus = RootFatalErrored;\n                        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n                        // sibling, or the parent if there are no siblings. But since the root\n                        // has no siblings nor a parent, we set it to null. Usually this is\n                        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n                        // intentionally not calling those, we need set it here.\n                        // TODO: Consider calling `unwindWork` to pop the contexts.\n                        workInProgress = null;\n                        return;\n                    }\n                    if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n                        // Record the time spent rendering before an error was thrown. This\n                        // avoids inaccurate Profiler durations in the case of a\n                        // suspended render.\n                        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n                    }\n                    if (enableSchedulingProfiler) {\n                        markComponentRenderStopped();\n                        if (thrownValue !== null && typeof thrownValue === \"object\" && typeof thrownValue.then === \"function\") {\n                            var wakeable = thrownValue;\n                            markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                        } else {\n                            markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                        }\n                    }\n                    throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n                    completeUnitOfWork(erroredWork);\n                } catch (yetAnotherThrownValue) {\n                    // Something in the return path also threw.\n                    thrownValue = yetAnotherThrownValue;\n                    if (workInProgress === erroredWork && erroredWork !== null) {\n                        // If this boundary has already errored, then we had trouble processing\n                        // the error. Bubble it to the next boundary.\n                        erroredWork = erroredWork.return;\n                        workInProgress = erroredWork;\n                    } else {\n                        erroredWork = workInProgress;\n                    }\n                    continue;\n                } // Return to the normal work loop.\n                return;\n            }while (true);\n        }\n        function pushDispatcher() {\n            var prevDispatcher = ReactCurrentDispatcher$2.current;\n            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n            if (prevDispatcher === null) {\n                // The React isomorphic package does not include a default dispatcher.\n                // Instead the first renderer will lazily attach one, in order to give\n                // nicer error messages.\n                return ContextOnlyDispatcher;\n            } else {\n                return prevDispatcher;\n            }\n        }\n        function popDispatcher(prevDispatcher) {\n            ReactCurrentDispatcher$2.current = prevDispatcher;\n        }\n        function markCommitTimeOfFallback() {\n            globalMostRecentFallbackTime = now$1();\n        }\n        function markSkippedUpdateLanes(lane) {\n            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootSuspended;\n            }\n        }\n        function renderDidSuspendDelayIfPossible() {\n            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n                workInProgressRootExitStatus = RootSuspendedWithDelay;\n            } // Check if there are updates that we skipped tree that might have unblocked\n            // this render.\n            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n                // Mark the current render as suspended so that we switch to working on\n                // the updates that were skipped. Usually we only suspend at the end of\n                // the render phase.\n                // TODO: We should probably always mark the root as suspended immediately\n                // (inside this function), since by suspending at the end of the render\n                // phase introduces a potential mistake where we suspend lanes that were\n                // pinged or updated while we were rendering.\n                markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n            }\n        }\n        function renderDidError(error) {\n            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n                workInProgressRootExitStatus = RootErrored;\n            }\n            if (workInProgressRootConcurrentErrors === null) {\n                workInProgressRootConcurrentErrors = [\n                    error\n                ];\n            } else {\n                workInProgressRootConcurrentErrors.push(error);\n            }\n        } // Called during render to determine if anything has suspended.\n        // Returns false if we're not sure.\n        function renderHasNotSuspendedYet() {\n            // If something errored or completed, we can't really be sure,\n            // so those are false.\n            return workInProgressRootExitStatus === RootInProgress;\n        }\n        function renderRootSync(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            do {\n                try {\n                    workLoopSync();\n                    break;\n                } catch (thrownValue) {\n                    handleError(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            executionContext = prevExecutionContext;\n            popDispatcher(prevDispatcher);\n            if (workInProgress !== null) {\n                // This is a sync render, so we should have finished the whole tree.\n                throw new Error(\"Cannot commit an incomplete root. This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n            }\n            {\n                markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes;\n            return workInProgressRootExitStatus;\n        } // The work loop is an extremely hot path. Tell Closure not to inline it.\n        /** @noinline */ function workLoopSync() {\n            // Already timed out, so perform work without checking if we need to yield.\n            while(workInProgress !== null){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function renderRootConcurrent(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                resetRenderTimer();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            do {\n                try {\n                    workLoopConcurrent();\n                    break;\n                } catch (thrownValue) {\n                    handleError(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            popDispatcher(prevDispatcher);\n            executionContext = prevExecutionContext;\n            if (workInProgress !== null) {\n                // Still work remaining.\n                {\n                    markRenderYielded();\n                }\n                return RootInProgress;\n            } else {\n                // Completed the tree.\n                {\n                    markRenderStopped();\n                }\n                workInProgressRoot = null;\n                workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n                return workInProgressRootExitStatus;\n            }\n        }\n        /** @noinline */ function workLoopConcurrent() {\n            // Perform work until Scheduler asks us to yield\n            while(workInProgress !== null && !shouldYield()){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function performUnitOfWork(unitOfWork) {\n            // The current, flushed, state of this fiber is the alternate. Ideally\n            // nothing should rely on this, but relying on it here means that we don't\n            // need an additional field on the work in progress.\n            var current = unitOfWork.alternate;\n            setCurrentFiber(unitOfWork);\n            var next;\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n                startProfilerTimer(unitOfWork);\n                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } else {\n                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n            }\n            resetCurrentFiber();\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n            ReactCurrentOwner$2.current = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n            // Attempt to complete the current unit of work, then move to the next\n            // sibling. If there are no more siblings, return to the parent fiber.\n            var completedWork = unitOfWork;\n            do {\n                // The current, flushed, state of this fiber is the alternate. Ideally\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = completedWork.alternate;\n                var returnFiber = completedWork.return; // Check if the work completed or if something threw.\n                if ((completedWork.flags & Incomplete) === NoFlags) {\n                    setCurrentFiber(completedWork);\n                    var next = void 0;\n                    if ((completedWork.mode & ProfileMode) === NoMode) {\n                        next = completeWork(current, completedWork, subtreeRenderLanes);\n                    } else {\n                        startProfilerTimer(completedWork);\n                        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                    }\n                    resetCurrentFiber();\n                    if (next !== null) {\n                        // Completing this fiber spawned new work. Work on that next.\n                        workInProgress = next;\n                        return;\n                    }\n                } else {\n                    // This fiber did not complete because something threw. Pop values off\n                    // the stack without entering the complete phase. If this is a boundary,\n                    // capture values if possible.\n                    var _next = unwindWork(current, completedWork); // Because this fiber did not complete, don't reset its lanes.\n                    if (_next !== null) {\n                        // If completing this work spawned new work, do that next. We'll come\n                        // back here again.\n                        // Since we're restarting, remove anything that is not a host effect\n                        // from the effect tag.\n                        _next.flags &= HostEffectMask;\n                        workInProgress = _next;\n                        return;\n                    }\n                    if ((completedWork.mode & ProfileMode) !== NoMode) {\n                        // Record the render duration for the fiber that errored.\n                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n                        var actualDuration = completedWork.actualDuration;\n                        var child = completedWork.child;\n                        while(child !== null){\n                            actualDuration += child.actualDuration;\n                            child = child.sibling;\n                        }\n                        completedWork.actualDuration = actualDuration;\n                    }\n                    if (returnFiber !== null) {\n                        // Mark the parent fiber as incomplete and clear its subtree flags.\n                        returnFiber.flags |= Incomplete;\n                        returnFiber.subtreeFlags = NoFlags;\n                        returnFiber.deletions = null;\n                    } else {\n                        // We've unwound all the way to the root.\n                        workInProgressRootExitStatus = RootDidNotComplete;\n                        workInProgress = null;\n                        return;\n                    }\n                }\n                var siblingFiber = completedWork.sibling;\n                if (siblingFiber !== null) {\n                    // If there is more work to do in this returnFiber, do that next.\n                    workInProgress = siblingFiber;\n                    return;\n                } // Otherwise, return to the parent\n                completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = completedWork;\n            }while (completedWork !== null); // We've reached the root.\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootCompleted;\n            }\n        }\n        function commitRoot(root, recoverableErrors) {\n            // TODO: This no longer makes any sense. We already wrap the mutation and\n            // layout phases. Should be able to remove.\n            var previousUpdateLanePriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                commitRootImpl(root, recoverableErrors, previousUpdateLanePriority);\n            } finally{\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                setCurrentUpdatePriority(previousUpdateLanePriority);\n            }\n            return null;\n        }\n        function commitRootImpl(root, recoverableErrors, renderPriorityLevel) {\n            do {\n                // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n                // means `flushPassiveEffects` will sometimes result in additional\n                // passive effects. So we need to keep flushing in a loop until there are\n                // no more pending effects.\n                // TODO: Might be better if `flushPassiveEffects` did not automatically\n                // flush synchronous work at the end, to avoid factoring hazards like this.\n                flushPassiveEffects();\n            }while (rootWithPendingPassiveEffects !== null);\n            flushRenderPhaseStrictModeWarningsInDEV();\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            }\n            var finishedWork = root.finishedWork;\n            var lanes = root.finishedLanes;\n            {\n                markCommitStarted(lanes);\n            }\n            if (finishedWork === null) {\n                {\n                    markCommitStopped();\n                }\n                return null;\n            } else {\n                {\n                    if (lanes === NoLanes) {\n                        error(\"root.finishedLanes should not be empty during a commit. This is a \" + \"bug in React.\");\n                    }\n                }\n            }\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            if (finishedWork === root.current) {\n                throw new Error(\"Cannot commit the same tree as before. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n            } // commitRoot never returns a continuation; it always finishes synchronously.\n            // So we can clear these now to allow a new callback to be scheduled.\n            root.callbackNode = null;\n            root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n            // pending time is whatever is left on the root fiber.\n            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n            markRootFinished(root, remainingLanes);\n            if (root === workInProgressRoot) {\n                // We can reset these now that they are finished.\n                workInProgressRoot = null;\n                workInProgress = null;\n                workInProgressRootRenderLanes = NoLanes;\n            } // If there are pending passive effects, schedule a callback to process them.\n            // Do this as early as possible, so it is queued before anything else that\n            // might get scheduled in the commit phase. (See #16714.)\n            // TODO: Delete all other places that schedule the passive effect callback\n            // They're redundant.\n            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback$1(NormalPriority, function() {\n                        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n                        // *after* passive effects fire to avoid freeing a cache pool that may\n                        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n                        return null;\n                    });\n                }\n            } // Check if there are any effects in the whole tree.\n            // TODO: This is left over from the effect list implementation, where we had\n            // to check for the existence of `firstEffect` to satisfy Flow. I think the\n            // only other reason this optimization exists is because it affects profiling.\n            // Reconsider whether this is necessary.\n            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n            if (subtreeHasEffects || rootHasEffect) {\n                var prevTransition = ReactCurrentBatchConfig$2.transition;\n                ReactCurrentBatchConfig$2.transition = null;\n                var previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext; // Reset this to null before calling lifecycles\n                ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n                // of the effect list for each phase: all mutation effects come before all\n                // layout effects, and so on.\n                // The first phase a \"before mutation\" phase. We use this phase to read the\n                // state of the host tree right before we mutate it. This is where\n                // getSnapshotBeforeUpdate is called.\n                var shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n                {\n                    // Mark the current commit time to be shared by all Profilers in this\n                    // batch. This enables them to be grouped later.\n                    recordCommitTime();\n                }\n                commitMutationEffects(root, finishedWork, lanes);\n                resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n                // the mutation phase, so that the previous tree is still current during\n                // componentWillUnmount, but before the layout phase, so that the finished\n                // work is current during componentDidMount/Update.\n                root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n                {\n                    markLayoutEffectsStarted(lanes);\n                }\n                commitLayoutEffects(finishedWork, root, lanes);\n                {\n                    markLayoutEffectsStopped();\n                }\n                // opportunity to paint.\n                requestPaint();\n                executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n            } else {\n                // No effects.\n                root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n                // no effects.\n                // TODO: Maybe there's a better way to report this.\n                {\n                    recordCommitTime();\n                }\n            }\n            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n            if (rootDoesHavePassiveEffects) {\n                // This commit has passive effects. Stash a reference to them. But don't\n                // schedule a callback until after flushing layout work.\n                rootDoesHavePassiveEffects = false;\n                rootWithPendingPassiveEffects = root;\n                pendingPassiveEffectsLanes = lanes;\n            } // Read this again, since an effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n            // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n            // is to detect whether something might have called setState inside\n            // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n            // inside `componentDidCatch` is itself flawed — that's why we recommend\n            // `getDerivedStateFromError` instead. However, it could be improved by\n            // checking if remainingLanes includes Sync work, instead of whether there's\n            // any work remaining at all (which would also include stuff like Suspense\n            // retries or transitions). It's been like this for a while, though, so fixing\n            // it probably isn't that urgent.\n            if (remainingLanes === NoLanes) {\n                // If there's no remaining work, we can clear the set of already failed\n                // error boundaries.\n                legacyErrorBoundariesThatAlreadyFailed = null;\n            }\n            {\n                if (!rootDidHavePassiveEffects) {\n                    commitDoubleInvokeEffectsInDEV(root.current, false);\n                }\n            }\n            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n            {\n                if (isDevToolsPresent) {\n                    root.memoizedUpdaters.clear();\n                }\n            }\n            {\n                onCommitRoot$1();\n            }\n            // additional work on this root is scheduled.\n            ensureRootIsScheduled(root, now$1());\n            if (recoverableErrors !== null) {\n                // There were errors during this render, but recovered from them without\n                // needing to surface it to the UI. We log them here.\n                var onRecoverableError = root.onRecoverableError;\n                for(var i = 0; i < recoverableErrors.length; i++){\n                    var recoverableError = recoverableErrors[i];\n                    onRecoverableError(recoverableError);\n                }\n            }\n            if (hasUncaughtError) {\n                hasUncaughtError = false;\n                var error$1 = firstUncaughtError;\n                firstUncaughtError = null;\n                throw error$1;\n            } // If the passive effects are the result of a discrete render, flush them\n            // synchronously at the end of the current task so that the result is\n            // immediately observable. Otherwise, we assume that they are not\n            // order-dependent and do not need to be observed by external systems, so we\n            // can wait until after paint.\n            // TODO: We can optimize this by not scheduling the callback earlier. Since we\n            // currently schedule the callback in multiple places, will wait until those\n            // are consolidated.\n            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n                flushPassiveEffects();\n            } // Read this again, since a passive effect might have updated it\n            remainingLanes = root.pendingLanes;\n            if (includesSomeLane(remainingLanes, SyncLane)) {\n                {\n                    markNestedUpdateScheduled();\n                }\n                // finishing. If there are too many, it indicates an infinite update loop.\n                if (root === rootWithNestedUpdates) {\n                    nestedUpdateCount++;\n                } else {\n                    nestedUpdateCount = 0;\n                    rootWithNestedUpdates = root;\n                }\n            } else {\n                nestedUpdateCount = 0;\n            } // If layout work was scheduled, flush it now.\n            flushSyncCallbacks();\n            {\n                markCommitStopped();\n            }\n            return null;\n        }\n        function flushPassiveEffects() {\n            // Returns whether passive effects were flushed.\n            // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n            // probably just combine the two functions. I believe they were only separate\n            // in the first place because we used to wrap it with\n            // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n            // priority within React itself, so we can mutate the variable directly.\n            if (rootWithPendingPassiveEffects !== null) {\n                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n                var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n                var prevTransition = ReactCurrentBatchConfig$2.transition;\n                var previousPriority = getCurrentUpdatePriority();\n                try {\n                    ReactCurrentBatchConfig$2.transition = null;\n                    setCurrentUpdatePriority(priority);\n                    return flushPassiveEffectsImpl();\n                } finally{\n                    setCurrentUpdatePriority(previousPriority);\n                    ReactCurrentBatchConfig$2.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n                }\n            }\n            return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n            {\n                pendingPassiveProfilerEffects.push(fiber);\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback$1(NormalPriority, function() {\n                        flushPassiveEffects();\n                        return null;\n                    });\n                }\n            }\n        }\n        function flushPassiveEffectsImpl() {\n            if (rootWithPendingPassiveEffects === null) {\n                return false;\n            }\n            var root = rootWithPendingPassiveEffects;\n            var lanes = pendingPassiveEffectsLanes;\n            rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n            // Figure out why and fix it. It's not causing any known issues (probably\n            // because it's only used for profiling), but it's a refactor hazard.\n            pendingPassiveEffectsLanes = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Cannot flush passive effects while already rendering.\");\n            }\n            {\n                markPassiveEffectsStarted(lanes);\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            commitPassiveUnmountEffects(root.current);\n            commitPassiveMountEffects(root, root.current); // TODO: Move to commitPassiveMountEffects\n            {\n                var profilerEffects = pendingPassiveProfilerEffects;\n                pendingPassiveProfilerEffects = [];\n                for(var i = 0; i < profilerEffects.length; i++){\n                    var _fiber = profilerEffects[i];\n                    commitPassiveEffectDurations(root, _fiber);\n                }\n            }\n            {\n                markPassiveEffectsStopped();\n            }\n            {\n                commitDoubleInvokeEffectsInDEV(root.current, true);\n            }\n            executionContext = prevExecutionContext;\n            flushSyncCallbacks(); // If additional passive effects were scheduled, increment a counter. If this\n            // exceeds the limit, we'll fire a warning.\n            nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1; // TODO: Move to commitPassiveMountEffects\n            onPostCommitRoot(root);\n            {\n                var stateNode = root.current.stateNode;\n                stateNode.effectDuration = 0;\n                stateNode.passiveEffectDuration = 0;\n            }\n            return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n            if (legacyErrorBoundariesThatAlreadyFailed === null) {\n                legacyErrorBoundariesThatAlreadyFailed = new Set([\n                    instance\n                ]);\n            } else {\n                legacyErrorBoundariesThatAlreadyFailed.add(instance);\n            }\n        }\n        function prepareToThrowUncaughtError(error) {\n            if (!hasUncaughtError) {\n                hasUncaughtError = true;\n                firstUncaughtError = error;\n            }\n        }\n        var onUncaughtError = prepareToThrowUncaughtError;\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n            var errorInfo = createCapturedValue(error, sourceFiber);\n            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n            enqueueUpdate(rootFiber, update);\n            var eventTime = requestEventTime();\n            var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);\n            if (root !== null) {\n                markRootUpdated(root, SyncLane, eventTime);\n                ensureRootIsScheduled(root, eventTime);\n            }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n            if (sourceFiber.tag === HostRoot) {\n                // Error was thrown at the root. There is no parent, so the root\n                // itself should capture it.\n                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n                return;\n            }\n            var fiber = null;\n            {\n                fiber = nearestMountedAncestor;\n            }\n            while(fiber !== null){\n                if (fiber.tag === HostRoot) {\n                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n                    return;\n                } else if (fiber.tag === ClassComponent) {\n                    var ctor = fiber.type;\n                    var instance = fiber.stateNode;\n                    if (typeof ctor.getDerivedStateFromError === \"function\" || typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                        var errorInfo = createCapturedValue(error$1, sourceFiber);\n                        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n                        enqueueUpdate(fiber, update);\n                        var eventTime = requestEventTime();\n                        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);\n                        if (root !== null) {\n                            markRootUpdated(root, SyncLane, eventTime);\n                            ensureRootIsScheduled(root, eventTime);\n                        }\n                        return;\n                    }\n                }\n                fiber = fiber.return;\n            }\n            {\n                // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n                // will fire for errors that are thrown by destroy functions inside deleted\n                // trees. What it should instead do is propagate the error to the parent of\n                // the deleted tree. In the meantime, do not add this warning to the\n                // allowlist; this is only for our internal use.\n                error(\"Internal React error: Attempted to capture a commit phase error \" + \"inside a detached tree. This indicates a bug in React. Likely \" + \"causes include deleting the same fiber more than once, committing an \" + \"already-finished tree, or an inconsistent return pointer.\\n\\n\" + \"Error message:\\n\\n%s\", error$1);\n            }\n        }\n        function pingSuspendedRoot(root, wakeable, pingedLanes) {\n            var pingCache = root.pingCache;\n            if (pingCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                pingCache.delete(wakeable);\n            }\n            var eventTime = requestEventTime();\n            markRootPinged(root, pingedLanes);\n            warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n                // Received a ping at the same priority level at which we're currently\n                // rendering. We might want to restart this render. This should mirror\n                // the logic of whether or not a root suspends once it completes.\n                // TODO: If we're rendering sync either due to Sync, Batched or expired,\n                // we should probably never restart.\n                // If we're suspended with delay, or if it's a retry, we'll always suspend\n                // so we can always restart.\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n                    // Restart from the root.\n                    prepareFreshStack(root, NoLanes);\n                } else {\n                    // Even though we can't restart right now, we might get an\n                    // opportunity later. So we mark this render as having a ping.\n                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n                }\n            }\n            ensureRootIsScheduled(root, eventTime);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n            // The boundary fiber (a Suspense component or SuspenseList component)\n            // previously was rendered in its fallback state. One of the promises that\n            // suspended it has resolved, which means at least part of the tree was\n            // likely unblocked. Try rendering again, at a new lanes.\n            if (retryLane === NoLane) {\n                // TODO: Assign this to `suspenseState.retryLane`? to avoid\n                // unnecessary entanglement?\n                retryLane = requestRetryLane(boundaryFiber);\n            } // TODO: Special case idle priority?\n            var eventTime = requestEventTime();\n            var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\n            if (root !== null) {\n                markRootUpdated(root, retryLane, eventTime);\n                ensureRootIsScheduled(root, eventTime);\n            }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n            var suspenseState = boundaryFiber.memoizedState;\n            var retryLane = NoLane;\n            if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n            var retryLane = NoLane; // Default\n            var retryCache;\n            {\n                switch(boundaryFiber.tag){\n                    case SuspenseComponent:\n                        retryCache = boundaryFiber.stateNode;\n                        var suspenseState = boundaryFiber.memoizedState;\n                        if (suspenseState !== null) {\n                            retryLane = suspenseState.retryLane;\n                        }\n                        break;\n                    case SuspenseListComponent:\n                        retryCache = boundaryFiber.stateNode;\n                        break;\n                    default:\n                        throw new Error(\"Pinged unknown suspense boundary type. \" + \"This is probably a bug in React.\");\n                }\n            }\n            if (retryCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                retryCache.delete(wakeable);\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        } // Computes the next Just Noticeable Difference (JND) boundary.\n        // The theory is that a person can't tell the difference between small differences in time.\n        // Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n        // difference in the experience. However, waiting for longer might mean that we can avoid\n        // showing an intermediate loading state. The longer we have already waited, the harder it\n        // is to tell small differences in time. Therefore, the longer we've already waited,\n        // the longer we can wait additionally. At some point we have to give up though.\n        // We pick a train model where the next boundary commits at a consistent schedule.\n        // These particular numbers are vague estimates. We expect to adjust them based on research.\n        function jnd(timeElapsed) {\n            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n        }\n        function checkForNestedUpdates() {\n            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n                nestedUpdateCount = 0;\n                rootWithNestedUpdates = null;\n                throw new Error(\"Maximum update depth exceeded. This can happen when a component \" + \"repeatedly calls setState inside componentWillUpdate or \" + \"componentDidUpdate. React limits the number of nested updates to \" + \"prevent infinite loops.\");\n            }\n            {\n                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n                    nestedPassiveUpdateCount = 0;\n                    error(\"Maximum update depth exceeded. This can happen when a component \" + \"calls setState inside useEffect, but useEffect either doesn't \" + \"have a dependency array, or one of the dependencies changes on \" + \"every render.\");\n                }\n            }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n            {\n                ReactStrictModeWarnings.flushLegacyContextWarning();\n                {\n                    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n                }\n            }\n        }\n        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n            {\n                // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n                // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n                // Maybe not a big deal since this is DEV only behavior.\n                setCurrentFiber(fiber);\n                invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n                if (hasPassiveEffects) {\n                    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n                }\n                invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n                if (hasPassiveEffects) {\n                    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n                }\n                resetCurrentFiber();\n            }\n        }\n        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                var current = firstChild;\n                var subtreeRoot = null;\n                while(current !== null){\n                    var primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n                    if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n                        current = current.child;\n                    } else {\n                        if ((current.flags & fiberFlags) !== NoFlags) {\n                            invokeEffectFn(current);\n                        }\n                        if (current.sibling !== null) {\n                            current = current.sibling;\n                        } else {\n                            current = subtreeRoot = current.return;\n                        }\n                    }\n                }\n            }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n            {\n                if ((executionContext & RenderContext) !== NoContext) {\n                    // We let the other warning about render phase updates deal with this one.\n                    return;\n                }\n                if (!(fiber.mode & ConcurrentMode)) {\n                    return;\n                }\n                var tag = fiber.tag;\n                if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n                    // Only warn for user-defined components, not internal ones like Suspense.\n                    return;\n                } // We show the whole stack but dedupe on the top component's name because\n                // the problematic code almost always lies inside that component.\n                var componentName = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                        return;\n                    }\n                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n                } else {\n                    didWarnStateUpdateForNotYetMountedComponent = new Set([\n                        componentName\n                    ]);\n                }\n                var previousFiber = current;\n                try {\n                    setCurrentFiber(fiber);\n                    error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + \"This indicates that you have a side-effect in your render function that \" + \"asynchronously later calls tries to update the component. Move this work to \" + \"useEffect instead.\");\n                } finally{\n                    if (previousFiber) {\n                        setCurrentFiber(fiber);\n                    } else {\n                        resetCurrentFiber();\n                    }\n                }\n            }\n        }\n        var beginWork$1;\n        {\n            var dummyFiber = null;\n            beginWork$1 = function(current, unitOfWork, lanes) {\n                // If a component throws an error, we replay it again in a synchronously\n                // dispatched event, so that the debugger will treat it as an uncaught\n                // error See ReactErrorUtils for more information.\n                // Before entering the begin phase, copy the work-in-progress onto a dummy\n                // fiber. If beginWork throws, we'll use this to reset the state.\n                var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n                try {\n                    return beginWork(current, unitOfWork, lanes);\n                } catch (originalError) {\n                    if (originalError !== null && typeof originalError === \"object\" && typeof originalError.then === \"function\") {\n                        // Don't replay promises. Treat everything else like an error.\n                        throw originalError;\n                    } // Keep this code in sync with handleError; any changes here must have\n                    // corresponding changes there.\n                    resetContextDependencies();\n                    resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n                    // same fiber again.\n                    // Unwind the failed stack frame\n                    unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.\n                    assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n                    if (unitOfWork.mode & ProfileMode) {\n                        // Reset the profiler timer.\n                        startProfilerTimer(unitOfWork);\n                    } // Run beginWork again.\n                    invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);\n                    if (hasCaughtError()) {\n                        var replayError = clearCaughtError();\n                        if (typeof replayError === \"object\" && replayError !== null && replayError._suppressLogging && typeof originalError === \"object\" && originalError !== null && !originalError._suppressLogging) {\n                            // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n                            originalError._suppressLogging = true;\n                        }\n                    } // We always throw the original error in case the second render pass is not idempotent.\n                    // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n                    throw originalError;\n                }\n            };\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n            didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n            {\n                if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n                    switch(fiber.tag){\n                        case FunctionComponent:\n                        case ForwardRef:\n                        case SimpleMemoComponent:\n                            {\n                                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\"; // Dedupe by the rendering component because it's the one that needs to be fixed.\n                                var dedupeKey = renderingComponentName;\n                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                                    var setStateComponentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                                    error(\"Cannot update a component (`%s`) while rendering a \" + \"different component (`%s`). To locate the bad setState() call inside `%s`, \" + \"follow the stack trace as described in https://reactjs.org/link/setstate-in-render\", setStateComponentName, renderingComponentName, renderingComponentName);\n                                }\n                                break;\n                            }\n                        case ClassComponent:\n                            {\n                                if (!didWarnAboutUpdateInRender) {\n                                    error(\"Cannot update during an existing state transition (such as \" + \"within `render`). Render methods should be a pure \" + \"function of props and state.\");\n                                    didWarnAboutUpdateInRender = true;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function restorePendingUpdaters(root, lanes) {\n            {\n                if (isDevToolsPresent) {\n                    var memoizedUpdaters = root.memoizedUpdaters;\n                    memoizedUpdaters.forEach(function(schedulingFiber) {\n                        addFiberToLanesMap(root, schedulingFiber, lanes);\n                    }); // This function intentionally does not clear memoized updaters.\n                // Those may still be relevant to the current commit\n                // and a future one (e.g. Suspense).\n                }\n            }\n        }\n        var fakeActCallbackNode = {};\n        function scheduleCallback$1(priorityLevel, callback) {\n            {\n                // If we're currently inside an `act` scope, bypass Scheduler and push to\n                // the `act` queue instead.\n                var actQueue = ReactCurrentActQueue$1.current;\n                if (actQueue !== null) {\n                    actQueue.push(callback);\n                    return fakeActCallbackNode;\n                } else {\n                    return scheduleCallback(priorityLevel, callback);\n                }\n            }\n        }\n        function cancelCallback$1(callbackNode) {\n            if (callbackNode === fakeActCallbackNode) {\n                return;\n            } // In production, always call Scheduler. This function will be stripped out.\n            return cancelCallback(callbackNode);\n        }\n        function shouldForceFlushFallbacksInDEV() {\n            // Never force flush in production. This function should get stripped out.\n            return ReactCurrentActQueue$1.current !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n            {\n                if (fiber.mode & ConcurrentMode) {\n                    if (!isConcurrentActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                } else {\n                    // Legacy mode has additional cases where we suppress a warning.\n                    if (!isLegacyActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                    if (executionContext !== NoContext) {\n                        // Legacy mode doesn't warn if the update is batched, i.e.\n                        // batchedUpdates or flushSync.\n                        return;\n                    }\n                    if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n                        // For backwards compatibility with pre-hooks code, legacy mode only\n                        // warns for updates that originate from a hook.\n                        return;\n                    }\n                }\n                if (ReactCurrentActQueue$1.current === null) {\n                    var previousFiber = current;\n                    try {\n                        setCurrentFiber(fiber);\n                        error(\"An update to %s inside a test was not wrapped in act(...).\\n\\n\" + \"When testing, code that causes React state updates should be \" + \"wrapped into act(...):\\n\\n\" + \"act(() => {\\n\" + \"  /* fire events that update state */\\n\" + \"});\\n\" + \"/* assert on the output */\\n\\n\" + \"This ensures that you're testing the behavior the user would see \" + \"in the browser.\" + \" Learn more at https://reactjs.org/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n                    } finally{\n                        if (previousFiber) {\n                            setCurrentFiber(fiber);\n                        } else {\n                            resetCurrentFiber();\n                        }\n                    }\n                }\n            }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n            {\n                if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n                    error(\"A suspended resource finished loading inside a test, but the event \" + \"was not wrapped in act(...).\\n\\n\" + \"When testing, code that resolves suspended data should be wrapped \" + \"into act(...):\\n\\n\" + \"act(() => {\\n\" + \"  /* finish loading suspended data */\\n\" + \"});\\n\" + \"/* assert on the output */\\n\\n\" + \"This ensures that you're testing the behavior the user would see \" + \"in the browser.\" + \" Learn more at https://reactjs.org/link/wrap-tests-with-act\");\n                }\n            }\n        }\n        /* eslint-disable react-internal/prod-error-codes */ var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n            {\n                resolveFamily = handler;\n            }\n        };\n        function resolveFunctionForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function resolveClassForHotReloading(type) {\n            // No implementation differences.\n            return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    // Check if we're dealing with a real forwardRef. Don't want to crash early.\n                    if (type !== null && type !== undefined && typeof type.render === \"function\") {\n                        // ForwardRef is special because its resolved .type is an object,\n                        // but it's possible that we only have its inner render function in the map.\n                        // If that inner render function is different, we'll build a new forwardRef type.\n                        var currentRender = resolveFunctionForHotReloading(type.render);\n                        if (type.render !== currentRender) {\n                            var syntheticType = {\n                                $$typeof: REACT_FORWARD_REF_TYPE,\n                                render: currentRender\n                            };\n                            if (type.displayName !== undefined) {\n                                syntheticType.displayName = type.displayName;\n                            }\n                            return syntheticType;\n                        }\n                    }\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return false;\n                }\n                var prevType = fiber.elementType;\n                var nextType = element.type; // If we got here, we know types aren't === equal.\n                var needsCompareFamilies = false;\n                var $$typeofNextType = typeof nextType === \"object\" && nextType !== null ? nextType.$$typeof : null;\n                switch(fiber.tag){\n                    case ClassComponent:\n                        {\n                            if (typeof nextType === \"function\") {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case FunctionComponent:\n                        {\n                            if (typeof nextType === \"function\") {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                // We don't know the inner type yet.\n                                // We're going to assume that the lazy inner type is stable,\n                                // and so it is sufficient to avoid reconciling it away.\n                                // We're not going to unwrap or actually use the new lazy type.\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case ForwardRef:\n                        {\n                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if ($$typeofNextType === REACT_MEMO_TYPE) {\n                                // TODO: if it was but can no longer be simple,\n                                // we shouldn't set this.\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    default:\n                        return false;\n                } // Check if both types have a family and it's the same one.\n                if (needsCompareFamilies) {\n                    // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n                    // This means both of them need to be registered to preserve state.\n                    // If we unwrapped and compared the inner types for wrappers instead,\n                    // then we would risk falsely saying two separate memo(Foo)\n                    // calls are equivalent because they wrap the same Foo function.\n                    var prevFamily = resolveFamily(prevType);\n                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                if (typeof WeakSet !== \"function\") {\n                    return;\n                }\n                if (failedBoundaries === null) {\n                    failedBoundaries = new WeakSet();\n                }\n                failedBoundaries.add(fiber);\n            }\n        }\n        var scheduleRefresh = function(root, update) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n                flushPassiveEffects();\n                flushSync(function() {\n                    scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n                });\n            }\n        };\n        var scheduleRoot = function(root, element) {\n            {\n                if (root.context !== emptyContextObject) {\n                    // Super edge case: root has a legacy _renderSubtree context\n                    // but we don't know the parentComponent so we can't pass it.\n                    // Just ignore. We'll delete this with _renderSubtree code path later.\n                    return;\n                }\n                flushPassiveEffects();\n                flushSync(function() {\n                    updateContainer(element, root, null, null);\n                });\n            }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n            {\n                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                if (resolveFamily === null) {\n                    throw new Error(\"Expected resolveFamily to be set during hot reload.\");\n                }\n                var needsRender = false;\n                var needsRemount = false;\n                if (candidateType !== null) {\n                    var family = resolveFamily(candidateType);\n                    if (family !== undefined) {\n                        if (staleFamilies.has(family)) {\n                            needsRemount = true;\n                        } else if (updatedFamilies.has(family)) {\n                            if (tag === ClassComponent) {\n                                needsRemount = true;\n                            } else {\n                                needsRender = true;\n                            }\n                        }\n                    }\n                }\n                if (failedBoundaries !== null) {\n                    if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n                        needsRemount = true;\n                    }\n                }\n                if (needsRemount) {\n                    fiber._debugNeedsRemount = true;\n                }\n                if (needsRemount || needsRender) {\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n                if (child !== null && !needsRemount) {\n                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n                }\n                if (sibling !== null) {\n                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n                }\n            }\n        }\n        var findHostInstancesForRefresh = function(root, families) {\n            {\n                var hostInstances = new Set();\n                var types = new Set(families.map(function(family) {\n                    return family.current;\n                }));\n                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n                return hostInstances;\n            }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n            {\n                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                var didMatch = false;\n                if (candidateType !== null) {\n                    if (types.has(candidateType)) {\n                        didMatch = true;\n                    }\n                }\n                if (didMatch) {\n                    // We have a match. This only drills down to the closest host components.\n                    // There's no need to search deeper because for the purpose of giving\n                    // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n                    findHostInstancesForFiberShallowly(fiber, hostInstances);\n                } else {\n                    // If there's no match, maybe there will be one further down in the child tree.\n                    if (child !== null) {\n                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n                    }\n                }\n                if (sibling !== null) {\n                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n                }\n            }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n                if (foundHostInstances) {\n                    return;\n                } // If we didn't find any host children, fallback to closest host parent.\n                var node = fiber;\n                while(true){\n                    switch(node.tag){\n                        case HostComponent:\n                            hostInstances.add(node.stateNode);\n                            return;\n                        case HostPortal:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                        case HostRoot:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                    }\n                    if (node.return === null) {\n                        throw new Error(\"Expected to reach root first.\");\n                    }\n                    node = node.return;\n                }\n            }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var node = fiber;\n                var foundHostInstances = false;\n                while(true){\n                    if (node.tag === HostComponent) {\n                        // We got a match.\n                        foundHostInstances = true;\n                        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === fiber) {\n                        return foundHostInstances;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === fiber) {\n                            return foundHostInstances;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n            return false;\n        }\n        var hasBadMapPolyfill;\n        {\n            hasBadMapPolyfill = false;\n            try {\n                var nonExtensibleObject = Object.preventExtensions({});\n                /* eslint-disable no-new */ new Map([\n                    [\n                        nonExtensibleObject,\n                        null\n                    ]\n                ]);\n                new Set([\n                    nonExtensibleObject\n                ]);\n            /* eslint-enable no-new */ } catch (e) {\n                // TODO: Consider warning about bad polyfills\n                hasBadMapPolyfill = true;\n            }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n            // Instance\n            this.tag = tag;\n            this.key = key;\n            this.elementType = null;\n            this.type = null;\n            this.stateNode = null; // Fiber\n            this.return = null;\n            this.child = null;\n            this.sibling = null;\n            this.index = 0;\n            this.ref = null;\n            this.pendingProps = pendingProps;\n            this.memoizedProps = null;\n            this.updateQueue = null;\n            this.memoizedState = null;\n            this.dependencies = null;\n            this.mode = mode; // Effects\n            this.flags = NoFlags;\n            this.subtreeFlags = NoFlags;\n            this.deletions = null;\n            this.lanes = NoLanes;\n            this.childLanes = NoLanes;\n            this.alternate = null;\n            {\n                // Note: The following is done to avoid a v8 performance cliff.\n                //\n                // Initializing the fields below to smis and later updating them with\n                // double values will cause Fibers to end up having separate shapes.\n                // This behavior/bug has something to do with Object.preventExtension().\n                // Fortunately this only impacts DEV builds.\n                // Unfortunately it makes React unusably slow for some applications.\n                // To work around this, initialize the fields below with doubles.\n                //\n                // Learn more about this here:\n                // https://github.com/facebook/react/issues/14365\n                // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n                this.actualDuration = Number.NaN;\n                this.actualStartTime = Number.NaN;\n                this.selfBaseDuration = Number.NaN;\n                this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n                // This won't trigger the performance cliff mentioned above,\n                // and it simplifies other profiler code (including DevTools).\n                this.actualDuration = 0;\n                this.actualStartTime = -1;\n                this.selfBaseDuration = 0;\n                this.treeBaseDuration = 0;\n            }\n            {\n                // This isn't directly used but is handy for debugging internals:\n                this._debugSource = null;\n                this._debugOwner = null;\n                this._debugNeedsRemount = false;\n                this._debugHookTypes = null;\n                if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n                    Object.preventExtensions(this);\n                }\n            }\n        } // This is a constructor function, rather than a POJO constructor, still\n        // please ensure we do the following:\n        // 1) Nobody should add any instance methods on this. Instance methods can be\n        //    more difficult to predict when they get optimized and they are almost\n        //    never inlined properly in static compilers.\n        // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n        //    always know when it is a fiber.\n        // 3) We might want to experiment with using numeric keys since they are easier\n        //    to optimize in a non-JIT environment.\n        // 4) We can easily go from a constructor to a createFiber object literal if that\n        //    is faster.\n        // 5) It should be easy to port this to a C struct and keep a C implementation\n        //    compatible.\n        var createFiber = function(tag, pendingProps, key, mode) {\n            // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n            return new FiberNode(tag, pendingProps, key, mode);\n        };\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n            return typeof type === \"function\" && !shouldConstruct$1(type) && type.defaultProps === undefined;\n        }\n        function resolveLazyComponentTag(Component) {\n            if (typeof Component === \"function\") {\n                return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n            } else if (Component !== undefined && Component !== null) {\n                var $$typeof = Component.$$typeof;\n                if ($$typeof === REACT_FORWARD_REF_TYPE) {\n                    return ForwardRef;\n                }\n                if ($$typeof === REACT_MEMO_TYPE) {\n                    return MemoComponent;\n                }\n            }\n            return IndeterminateComponent;\n        } // This is used to create an alternate fiber to do work on.\n        function createWorkInProgress(current, pendingProps) {\n            var workInProgress = current.alternate;\n            if (workInProgress === null) {\n                // We use a double buffering pooling technique because we know that we'll\n                // only ever need at most two versions of a tree. We pool the \"other\" unused\n                // node that we're free to reuse. This is lazily created to avoid allocating\n                // extra objects for things that are never updated. It also allow us to\n                // reclaim the extra memory if needed.\n                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n                workInProgress.elementType = current.elementType;\n                workInProgress.type = current.type;\n                workInProgress.stateNode = current.stateNode;\n                {\n                    // DEV-only fields\n                    workInProgress._debugSource = current._debugSource;\n                    workInProgress._debugOwner = current._debugOwner;\n                    workInProgress._debugHookTypes = current._debugHookTypes;\n                }\n                workInProgress.alternate = current;\n                current.alternate = workInProgress;\n            } else {\n                workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // We already have an alternate.\n                // Reset the effect tag.\n                workInProgress.flags = NoFlags; // The effects are no longer valid.\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.deletions = null;\n                {\n                    // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n                    // This prevents time from endlessly accumulating in new commits.\n                    // This has the downside of resetting values for different priority renders,\n                    // But works for yielding (the common case) and should support resuming.\n                    workInProgress.actualDuration = 0;\n                    workInProgress.actualStartTime = -1;\n                }\n            } // Reset all effects except static ones.\n            // Static effects are not specific to a render.\n            workInProgress.flags = current.flags & StaticMask;\n            workInProgress.childLanes = current.childLanes;\n            workInProgress.lanes = current.lanes;\n            workInProgress.child = current.child;\n            workInProgress.memoizedProps = current.memoizedProps;\n            workInProgress.memoizedState = current.memoizedState;\n            workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n            // it cannot be shared with the current fiber.\n            var currentDependencies = current.dependencies;\n            workInProgress.dependencies = currentDependencies === null ? null : {\n                lanes: currentDependencies.lanes,\n                firstContext: currentDependencies.firstContext\n            }; // These will be overridden during the parent's reconciliation\n            workInProgress.sibling = current.sibling;\n            workInProgress.index = current.index;\n            workInProgress.ref = current.ref;\n            {\n                workInProgress.selfBaseDuration = current.selfBaseDuration;\n                workInProgress.treeBaseDuration = current.treeBaseDuration;\n            }\n            {\n                workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n                switch(workInProgress.tag){\n                    case IndeterminateComponent:\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                        workInProgress.type = resolveFunctionForHotReloading(current.type);\n                        break;\n                    case ClassComponent:\n                        workInProgress.type = resolveClassForHotReloading(current.type);\n                        break;\n                    case ForwardRef:\n                        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n                        break;\n                }\n            }\n            return workInProgress;\n        } // Used to reuse a Fiber for a second pass.\n        function resetWorkInProgress(workInProgress, renderLanes) {\n            // This resets the Fiber to what createFiber or createWorkInProgress would\n            // have set the values to before during the first pass. Ideally this wouldn't\n            // be necessary but unfortunately many code paths reads from the workInProgress\n            // when they should be reading from current and writing to workInProgress.\n            // We assume pendingProps, index, key, ref, return are still untouched to\n            // avoid doing another reconciliation.\n            // Reset the effect flags but keep any Placement tags, since that's something\n            // that child fiber is setting, not the reconciliation.\n            workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n            var current = workInProgress.alternate;\n            if (current === null) {\n                // Reset to createFiber's initial values.\n                workInProgress.childLanes = NoLanes;\n                workInProgress.lanes = renderLanes;\n                workInProgress.child = null;\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.memoizedProps = null;\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null;\n                workInProgress.dependencies = null;\n                workInProgress.stateNode = null;\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = 0;\n                    workInProgress.treeBaseDuration = 0;\n                }\n            } else {\n                // Reset to the cloned values that createWorkInProgress would've.\n                workInProgress.childLanes = current.childLanes;\n                workInProgress.lanes = current.lanes;\n                workInProgress.child = current.child;\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.deletions = null;\n                workInProgress.memoizedProps = current.memoizedProps;\n                workInProgress.memoizedState = current.memoizedState;\n                workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n                // it cannot be shared with the current fiber.\n                var currentDependencies = current.dependencies;\n                workInProgress.dependencies = currentDependencies === null ? null : {\n                    lanes: currentDependencies.lanes,\n                    firstContext: currentDependencies.firstContext\n                };\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = current.selfBaseDuration;\n                    workInProgress.treeBaseDuration = current.treeBaseDuration;\n                }\n            }\n            return workInProgress;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n            var mode;\n            if (tag === ConcurrentRoot) {\n                mode = ConcurrentMode;\n                if (isStrictMode === true) {\n                    mode |= StrictLegacyMode;\n                    {\n                        mode |= StrictEffectsMode;\n                    }\n                }\n            } else {\n                mode = NoMode;\n            }\n            if (isDevToolsPresent) {\n                // Always collect profile timings when DevTools are present.\n                // This enables DevTools to start capturing timing at any point–\n                // Without some nodes in the tree having empty base times.\n                mode |= ProfileMode;\n            }\n            return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n            var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n            var resolvedType = type;\n            if (typeof type === \"function\") {\n                if (shouldConstruct$1(type)) {\n                    fiberTag = ClassComponent;\n                    {\n                        resolvedType = resolveClassForHotReloading(resolvedType);\n                    }\n                } else {\n                    {\n                        resolvedType = resolveFunctionForHotReloading(resolvedType);\n                    }\n                }\n            } else if (typeof type === \"string\") {\n                fiberTag = HostComponent;\n            } else {\n                getTag: switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n                    case REACT_STRICT_MODE_TYPE:\n                        fiberTag = Mode;\n                        mode |= StrictLegacyMode;\n                        if ((mode & ConcurrentMode) !== NoMode) {\n                            // Strict effects should never run on legacy roots\n                            mode |= StrictEffectsMode;\n                        }\n                        break;\n                    case REACT_PROFILER_TYPE:\n                        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_TYPE:\n                        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n                    case REACT_OFFSCREEN_TYPE:\n                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n                    case REACT_LEGACY_HIDDEN_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_SCOPE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_CACHE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_TRACING_MARKER_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_DEBUG_TRACING_MODE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    default:\n                        {\n                            if (typeof type === \"object\" && type !== null) {\n                                switch(type.$$typeof){\n                                    case REACT_PROVIDER_TYPE:\n                                        fiberTag = ContextProvider;\n                                        break getTag;\n                                    case REACT_CONTEXT_TYPE:\n                                        // This is a consumer\n                                        fiberTag = ContextConsumer;\n                                        break getTag;\n                                    case REACT_FORWARD_REF_TYPE:\n                                        fiberTag = ForwardRef;\n                                        {\n                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                                        }\n                                        break getTag;\n                                    case REACT_MEMO_TYPE:\n                                        fiberTag = MemoComponent;\n                                        break getTag;\n                                    case REACT_LAZY_TYPE:\n                                        fiberTag = LazyComponent;\n                                        resolvedType = null;\n                                        break getTag;\n                                }\n                            }\n                            var info = \"\";\n                            {\n                                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                                }\n                                var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n                                if (ownerName) {\n                                    info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                                }\n                            }\n                            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n                        }\n                }\n            }\n            var fiber = createFiber(fiberTag, pendingProps, key, mode);\n            fiber.elementType = type;\n            fiber.type = resolvedType;\n            fiber.lanes = lanes;\n            {\n                fiber._debugOwner = owner;\n            }\n            return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n            var owner = null;\n            {\n                owner = element._owner;\n            }\n            var type = element.type;\n            var key = element.key;\n            var pendingProps = element.props;\n            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n            {\n                fiber._debugSource = element._source;\n                fiber._debugOwner = element._owner;\n            }\n            return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n            var fiber = createFiber(Fragment, elements, key, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n            {\n                if (typeof pendingProps.id !== \"string\") {\n                    error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n                }\n            }\n            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n            fiber.elementType = REACT_PROFILER_TYPE;\n            fiber.lanes = lanes;\n            {\n                fiber.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                };\n            }\n            return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_OFFSCREEN_TYPE;\n            fiber.lanes = lanes;\n            var primaryChildInstance = {};\n            fiber.stateNode = primaryChildInstance;\n            return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n            var fiber = createFiber(HostText, content, null, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromHostInstanceForDeletion() {\n            var fiber = createFiber(HostComponent, null, null, NoMode);\n            fiber.elementType = \"DELETED\";\n            return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n            var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n            fiber.stateNode = dehydratedNode;\n            return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n            var pendingProps = portal.children !== null ? portal.children : [];\n            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n            fiber.lanes = lanes;\n            fiber.stateNode = {\n                containerInfo: portal.containerInfo,\n                pendingChildren: null,\n                // Used by persistent updates\n                implementation: portal.implementation\n            };\n            return fiber;\n        } // Used for stashing WIP properties to replay failed work in DEV.\n        function assignFiberPropertiesInDEV(target, source) {\n            if (target === null) {\n                // This Fiber's initial properties will always be overwritten.\n                // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n                target = createFiber(IndeterminateComponent, null, null, NoMode);\n            } // This is intentionally written as a list of all properties.\n            // We tried to use Object.assign() instead but this is called in\n            // the hottest path, and Object.assign() was too slow:\n            // https://github.com/facebook/react/issues/12502\n            // This code is DEV-only so size is not a concern.\n            target.tag = source.tag;\n            target.key = source.key;\n            target.elementType = source.elementType;\n            target.type = source.type;\n            target.stateNode = source.stateNode;\n            target.return = source.return;\n            target.child = source.child;\n            target.sibling = source.sibling;\n            target.index = source.index;\n            target.ref = source.ref;\n            target.pendingProps = source.pendingProps;\n            target.memoizedProps = source.memoizedProps;\n            target.updateQueue = source.updateQueue;\n            target.memoizedState = source.memoizedState;\n            target.dependencies = source.dependencies;\n            target.mode = source.mode;\n            target.flags = source.flags;\n            target.subtreeFlags = source.subtreeFlags;\n            target.deletions = source.deletions;\n            target.lanes = source.lanes;\n            target.childLanes = source.childLanes;\n            target.alternate = source.alternate;\n            {\n                target.actualDuration = source.actualDuration;\n                target.actualStartTime = source.actualStartTime;\n                target.selfBaseDuration = source.selfBaseDuration;\n                target.treeBaseDuration = source.treeBaseDuration;\n            }\n            target._debugSource = source._debugSource;\n            target._debugOwner = source._debugOwner;\n            target._debugNeedsRemount = source._debugNeedsRemount;\n            target._debugHookTypes = source._debugHookTypes;\n            return target;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n            this.tag = tag;\n            this.containerInfo = containerInfo;\n            this.pendingChildren = null;\n            this.current = null;\n            this.pingCache = null;\n            this.finishedWork = null;\n            this.timeoutHandle = noTimeout;\n            this.context = null;\n            this.pendingContext = null;\n            this.callbackNode = null;\n            this.callbackPriority = NoLane;\n            this.eventTimes = createLaneMap(NoLanes);\n            this.expirationTimes = createLaneMap(NoTimestamp);\n            this.pendingLanes = NoLanes;\n            this.suspendedLanes = NoLanes;\n            this.pingedLanes = NoLanes;\n            this.expiredLanes = NoLanes;\n            this.mutableReadLanes = NoLanes;\n            this.finishedLanes = NoLanes;\n            this.entangledLanes = NoLanes;\n            this.entanglements = createLaneMap(NoLanes);\n            this.identifierPrefix = identifierPrefix;\n            this.onRecoverableError = onRecoverableError;\n            if (supportsHydration) {\n                this.mutableSourceEagerHydrationData = null;\n            }\n            {\n                this.effectDuration = 0;\n                this.passiveEffectDuration = 0;\n            }\n            {\n                this.memoizedUpdaters = new Set();\n                var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n                for(var _i = 0; _i < TotalLanes; _i++){\n                    pendingUpdatersLaneMap.push(new Set());\n                }\n            }\n            {\n                switch(tag){\n                    case ConcurrentRoot:\n                        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n                        break;\n                    case LegacyRoot:\n                        this._debugRootType = hydrate ? \"hydrate()\" : \"render()\";\n                        break;\n                }\n            }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // host config, but because they are passed in at runtime, we have to thread\n        // them through the root constructor. Perhaps we should put them all into a\n        // single type, like a DynamicHostConfig that is defined by the renderer.\n        identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n            // stateNode is any.\n            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n            root.current = uninitializedFiber;\n            uninitializedFiber.stateNode = root;\n            {\n                var _initialState = {\n                    element: initialChildren,\n                    isDehydrated: hydrate,\n                    cache: null,\n                    // not enabled yet\n                    transitions: null\n                };\n                uninitializedFiber.memoizedState = _initialState;\n            }\n            initializeUpdateQueue(uninitializedFiber);\n            return root;\n        }\n        var ReactVersion = \"18.0.0-fc46dba67-20220329\";\n        function createPortal(children, containerInfo, implementation) {\n            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            {\n                checkKeyStringCoercion(key);\n            }\n            return {\n                // This tag allow us to uniquely identify this as a React Portal\n                $$typeof: REACT_PORTAL_TYPE,\n                key: key == null ? null : \"\" + key,\n                children: children,\n                containerInfo: containerInfo,\n                implementation: implementation\n            };\n        }\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n            didWarnAboutNestedUpdates = false;\n            didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n            if (!parentComponent) {\n                return emptyContextObject;\n            }\n            var fiber = get(parentComponent);\n            var parentContext = findCurrentUnmaskedContext(fiber);\n            if (fiber.tag === ClassComponent) {\n                var Component = fiber.type;\n                if (isContextProvider(Component)) {\n                    return processChildContext(fiber, Component, parentContext);\n                }\n            }\n            return parentContext;\n        }\n        function findHostInstance(component) {\n            var fiber = get(component);\n            if (fiber === undefined) {\n                if (typeof component.render === \"function\") {\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                } else {\n                    var keys = Object.keys(component).join(\",\");\n                    throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n            {\n                var fiber = get(component);\n                if (fiber === undefined) {\n                    if (typeof component.render === \"function\") {\n                        throw new Error(\"Unable to find node on an unmounted component.\");\n                    } else {\n                        var keys = Object.keys(component).join(\",\");\n                        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                    }\n                }\n                var hostFiber = findCurrentHostFiber(fiber);\n                if (hostFiber === null) {\n                    return null;\n                }\n                if (hostFiber.mode & StrictLegacyMode) {\n                    var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                        didWarnAboutFindNodeInStrictMode[componentName] = true;\n                        var previousFiber = current;\n                        try {\n                            setCurrentFiber(hostFiber);\n                            if (fiber.mode & StrictLegacyMode) {\n                                error(\"%s is deprecated in StrictMode. \" + \"%s was passed an instance of %s which is inside StrictMode. \" + \"Instead, add a ref directly to the element you want to reference. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                            } else {\n                                error(\"%s is deprecated in StrictMode. \" + \"%s was passed an instance of %s which renders StrictMode children. \" + \"Instead, add a ref directly to the element you want to reference. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                            }\n                        } finally{\n                            // Ideally this should reset to previous but this shouldn't be called in\n                            // render and there's another warning for that anyway.\n                            if (previousFiber) {\n                                setCurrentFiber(previousFiber);\n                            } else {\n                                resetCurrentFiber();\n                            }\n                        }\n                    }\n                }\n                return hostFiber.stateNode;\n            }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var hydrate = false;\n            var initialChildren = null;\n            return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var hydrate = true;\n            var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError); // TODO: Move this to FiberRoot constructor\n            root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n            // a regular update because the initial render must match was was rendered\n            // on the server.\n            // NOTE: This update intentionally doesn't have a payload. We're only using\n            // the update to schedule work on the root fiber (and, for legacy roots, to\n            // enqueue the callback if one is provided).\n            var current = root.current;\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(current);\n            var update = createUpdate(eventTime, lane);\n            update.callback = callback !== undefined && callback !== null ? callback : null;\n            enqueueUpdate(current, update);\n            scheduleInitialHydrationOnRoot(root, lane, eventTime);\n            return root;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n            {\n                onScheduleRoot(container, element);\n            }\n            var current$1 = container.current;\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(current$1);\n            {\n                markRenderScheduled(lane);\n            }\n            var context = getContextForSubtree(parentComponent);\n            if (container.context === null) {\n                container.context = context;\n            } else {\n                container.pendingContext = context;\n            }\n            {\n                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n                    didWarnAboutNestedUpdates = true;\n                    error(\"Render methods should be a pure function of props and state; \" + \"triggering nested component updates from render is not allowed. \" + \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" + \"Check the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\");\n                }\n            }\n            var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: element\n            };\n            callback = callback === undefined ? null : callback;\n            if (callback !== null) {\n                {\n                    if (typeof callback !== \"function\") {\n                        error(\"render(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callback);\n                    }\n                }\n                update.callback = callback;\n            }\n            enqueueUpdate(current$1, update);\n            var root = scheduleUpdateOnFiber(current$1, lane, eventTime);\n            if (root !== null) {\n                entangleTransitions(root, current$1, lane);\n            }\n            return lane;\n        }\n        function getPublicRootInstance(container) {\n            var containerFiber = container.current;\n            if (!containerFiber.child) {\n                return null;\n            }\n            switch(containerFiber.child.tag){\n                case HostComponent:\n                    return getPublicInstance(containerFiber.child.stateNode);\n                default:\n                    return containerFiber.child.stateNode;\n            }\n        }\n        function attemptSynchronousHydration(fiber) {\n            switch(fiber.tag){\n                case HostRoot:\n                    var root = fiber.stateNode;\n                    if (isRootDehydrated(root)) {\n                        // Flush the first scheduled \"update\".\n                        var lanes = getHighestPriorityPendingLanes(root);\n                        flushRoot(root, lanes);\n                    }\n                    break;\n                case SuspenseComponent:\n                    var eventTime = requestEventTime();\n                    flushSync(function() {\n                        return scheduleUpdateOnFiber(fiber, SyncLane, eventTime);\n                    }); // If we're still blocked after this, we need to increase\n                    // the priority of any promises resolving within this\n                    // boundary so that they next attempt also has higher pri.\n                    var retryLane = SyncLane;\n                    markRetryLaneIfNotHydrated(fiber, retryLane);\n                    break;\n            }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n            }\n        } // Increases the priority of thenables when they resolve within this boundary.\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n            markRetryLaneImpl(fiber, retryLane);\n            var alternate = fiber.alternate;\n            if (alternate) {\n                markRetryLaneImpl(alternate, retryLane);\n            }\n        }\n        function attemptContinuousHydration(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority and they should not suspend on I/O,\n                // since you have to wrap anything that might suspend in\n                // Suspense.\n                return;\n            }\n            var eventTime = requestEventTime();\n            var lane = SelectiveHydrationLane;\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority other than synchronously flush it.\n                return;\n            }\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        var shouldErrorImpl = function(fiber) {\n            return null;\n        };\n        function shouldError(fiber) {\n            return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n            return false;\n        };\n        function shouldSuspend(fiber) {\n            return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n            var copyWithDeleteImpl = function(obj, path, index) {\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === path.length) {\n                    if (isArray(updated)) {\n                        updated.splice(key, 1);\n                    } else {\n                        delete updated[key];\n                    }\n                    return updated;\n                } // $FlowFixMe number or string is fine here\n                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n                return updated;\n            };\n            var copyWithDelete = function(obj, path) {\n                return copyWithDeleteImpl(obj, path, 0);\n            };\n            var copyWithRenameImpl = function(obj, oldPath, newPath, index) {\n                var oldKey = oldPath[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === oldPath.length) {\n                    var newKey = newPath[index]; // $FlowFixMe number or string is fine here\n                    updated[newKey] = updated[oldKey];\n                    if (isArray(updated)) {\n                        updated.splice(oldKey, 1);\n                    } else {\n                        delete updated[oldKey];\n                    }\n                } else {\n                    // $FlowFixMe number or string is fine here\n                    updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n                }\n                return updated;\n            };\n            var copyWithRename = function(obj, oldPath, newPath) {\n                if (oldPath.length !== newPath.length) {\n                    warn(\"copyWithRename() expects paths of the same length\");\n                    return;\n                } else {\n                    for(var i = 0; i < newPath.length - 1; i++){\n                        if (oldPath[i] !== newPath[i]) {\n                            warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                            return;\n                        }\n                    }\n                }\n                return copyWithRenameImpl(obj, oldPath, newPath, 0);\n            };\n            var copyWithSetImpl = function(obj, path, index, value) {\n                if (index >= path.length) {\n                    return value;\n                }\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe number or string is fine here\n                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n                return updated;\n            };\n            var copyWithSet = function(obj, path, value) {\n                return copyWithSetImpl(obj, path, 0, value);\n            };\n            var findHook = function(fiber, id) {\n                // For now, the \"id\" of stateful hooks is just the stateful hook index.\n                // This may change in the future with e.g. nested hooks.\n                var currentHook = fiber.memoizedState;\n                while(currentHook !== null && id > 0){\n                    currentHook = currentHook.next;\n                    id--;\n                }\n                return currentHook;\n            }; // Support DevTools editable values for useState and useReducer.\n            overrideHookState = function(fiber, id, path, value) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithSet(hook.memoizedState, path, value);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            };\n            overrideHookStateDeletePath = function(fiber, id, path) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithDelete(hook.memoizedState, path);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            };\n            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n            overrideProps = function(fiber, path, value) {\n                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            overridePropsDeletePath = function(fiber, path) {\n                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            overridePropsRenamePath = function(fiber, oldPath, newPath) {\n                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            scheduleUpdate = function(fiber) {\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            setErrorHandler = function(newShouldErrorImpl) {\n                shouldErrorImpl = newShouldErrorImpl;\n            };\n            setSuspenseHandler = function(newShouldSuspendImpl) {\n                shouldSuspendImpl = newShouldSuspendImpl;\n            };\n        }\n        function findHostInstanceByFiber(fiber) {\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n            return null;\n        }\n        function getCurrentFiberForDevTools() {\n            return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n            return injectInternals({\n                bundleType: devToolsConfig.bundleType,\n                version: devToolsConfig.version,\n                rendererPackageName: devToolsConfig.rendererPackageName,\n                rendererConfig: devToolsConfig.rendererConfig,\n                overrideHookState: overrideHookState,\n                overrideHookStateDeletePath: overrideHookStateDeletePath,\n                overrideHookStateRenamePath: overrideHookStateRenamePath,\n                overrideProps: overrideProps,\n                overridePropsDeletePath: overridePropsDeletePath,\n                overridePropsRenamePath: overridePropsRenamePath,\n                setErrorHandler: setErrorHandler,\n                setSuspenseHandler: setSuspenseHandler,\n                scheduleUpdate: scheduleUpdate,\n                currentDispatcherRef: ReactCurrentDispatcher,\n                findHostInstanceByFiber: findHostInstanceByFiber,\n                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n                // React Refresh\n                findHostInstancesForRefresh: findHostInstancesForRefresh,\n                scheduleRefresh: scheduleRefresh,\n                scheduleRoot: scheduleRoot,\n                setRefreshHandler: setRefreshHandler,\n                // Enables DevTools to append owner stacks to error messages in DEV mode.\n                getCurrentFiber: getCurrentFiberForDevTools,\n                // Enables DevTools to detect reconciler version rather than renderer version\n                // which may not match for third party renderers.\n                reconcilerVersion: ReactVersion\n            });\n        }\n        exports.attemptContinuousHydration = attemptContinuousHydration;\n        exports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\n        exports.attemptSynchronousHydration = attemptSynchronousHydration;\n        exports.batchedUpdates = batchedUpdates;\n        exports.createComponentSelector = createComponentSelector;\n        exports.createContainer = createContainer;\n        exports.createHasPseudoClassSelector = createHasPseudoClassSelector;\n        exports.createHydrationContainer = createHydrationContainer;\n        exports.createPortal = createPortal;\n        exports.createRoleSelector = createRoleSelector;\n        exports.createTestNameSelector = createTestNameSelector;\n        exports.createTextSelector = createTextSelector;\n        exports.deferredUpdates = deferredUpdates;\n        exports.discreteUpdates = discreteUpdates;\n        exports.findAllNodes = findAllNodes;\n        exports.findBoundingRects = findBoundingRects;\n        exports.findHostInstance = findHostInstance;\n        exports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\n        exports.findHostInstanceWithWarning = findHostInstanceWithWarning;\n        exports.flushControlled = flushControlled;\n        exports.flushPassiveEffects = flushPassiveEffects;\n        exports.flushSync = flushSync;\n        exports.focusWithin = focusWithin;\n        exports.getCurrentUpdatePriority = getCurrentUpdatePriority;\n        exports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\n        exports.getPublicRootInstance = getPublicRootInstance;\n        exports.injectIntoDevTools = injectIntoDevTools;\n        exports.isAlreadyRendering = isAlreadyRendering;\n        exports.observeVisibleRects = observeVisibleRects;\n        exports.registerMutableSourceForHydration = registerMutableSourceForHydration;\n        exports.runWithPriority = runWithPriority;\n        exports.shouldError = shouldError;\n        exports.shouldSuspend = shouldSuspend;\n        exports.updateContainer = updateContainer;\n        return exports;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN6Q0MsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGNBQWNDLGFBQWE7UUFDbkQsSUFBSUYsVUFBVSxDQUFDO1FBQ25CO1FBRUEsSUFBSUcsUUFBUUMsbUJBQU9BLENBQUM7UUFDcEIsSUFBSUMsWUFBWUQsbUJBQU9BLENBQUM7UUFFeEIsSUFBSUUsdUJBQXVCSCxNQUFNSSxrREFBa0Q7UUFFbkYsSUFBSUMsa0JBQWtCO1FBQ3RCLFNBQVNDLG1CQUFtQkMsa0JBQWtCO1lBQzVDO2dCQUNFRixrQkFBa0JFO1lBQ3BCO1FBQ0YsRUFBRSwrREFBK0Q7UUFDakUsK0NBQStDO1FBQy9DLEVBQUU7UUFDRiw4REFBOEQ7UUFDOUQscUNBQXFDO1FBRXJDLFNBQVNDLEtBQUtDLE1BQU07WUFDbEI7Z0JBQ0UsSUFBSSxDQUFDSixpQkFBaUI7b0JBQ3BCLElBQUssSUFBSUssT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlLLE9BQU8sR0FBR0EsT0FBT0wsTUFBTUssT0FBUTt3QkFDMUdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztvQkFDbEM7b0JBRUFDLGFBQWEsUUFBUVAsUUFBUUk7Z0JBQy9CO1lBQ0Y7UUFDRjtRQUNBLFNBQVNJLE1BQU1SLE1BQU07WUFDbkI7Z0JBQ0UsSUFBSSxDQUFDSixpQkFBaUI7b0JBQ3BCLElBQUssSUFBSWEsUUFBUVAsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1JLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlDLFFBQVEsR0FBR0EsUUFBUUQsT0FBT0MsUUFBUzt3QkFDakhOLElBQUksQ0FBQ00s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QUM3QmpqRSxRQUFRbzdELG1CQUFtQixHQUFHQTtRQUM5QnA3RCxRQUFRZ3FDLGlDQUFpQyxHQUFHQTtRQUM1Q2hxQyxRQUFRb2pCLGVBQWUsR0FBR0E7UUFDMUJwakIsUUFBUTJqRCxXQUFXLEdBQUdBO1FBQ3RCM2pELFFBQVFzbUQsYUFBYSxHQUFHQTtRQUN4QnRtRCxRQUFRd25FLGVBQWUsR0FBR0E7UUFDdEIsT0FBT3huRTtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW9ub3ZvLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanM/M2EwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gJCQkcmVjb25jaWxlcigkJCRob3N0Q29uZmlnKSB7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBTY2hlZHVsZXIgPSByZXF1aXJlKCdzY2hlZHVsZXInKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBzdXBwcmVzc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpIHtcbiAge1xuICAgIHN1cHByZXNzV2FybmluZyA9IG5ld1N1cHByZXNzV2FybmluZztcbiAgfVxufSAvLyBJbiBERVYsIGNhbGxzIHRvIGNvbnNvbGUud2FybiBhbmQgY29uc29sZS5lcnJvciBnZXQgcmVwbGFjZWRcbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGlmICghc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBlbmFibGVQZXJzaXN0ZW50T2Zmc2NyZWVuSG9zdENvbnRhaW5lciA9IGZhbHNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdGhlIHJlYWN0LXJlY29uY2lsZXIgcGFja2FnZS5cblxudmFyIGVuYWJsZU5ld1JlY29uY2lsZXIgPSBmYWxzZTsgLy8gU3VwcG9ydCBsZWdhY3kgUHJpbWVyIHN1cHBvcnQgb24gaW50ZXJuYWwgRkIgd3d3XG5cbnZhciBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uID0gZmFsc2U7IC8vIEZCLW9ubHkgdXNhZ2UuIFRoZSBuZXcgQVBJIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzLlxuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuXG52YXIgZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjayA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRml6elxudmFyIHdhcm5BYm91dFN0cmluZ1JlZnMgPSBmYWxzZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlYnVnZ2luZyBhbmQgRGV2VG9vbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuLy8gZm9yIGFuIGV4cGVyaW1lbnRhbCB0aW1lbGluZSB0b29sLlxuXG52YXIgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyID0gdHJ1ZTsgLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIHJlbmRlci1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlXG5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyA9IHRydWU7IC8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAyOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG5cbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgRnJhZ21lbnQgPSA3O1xudmFyIE1vZGUgPSA4O1xudmFyIENvbnRleHRDb25zdW1lciA9IDk7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG52YXIgRm9yd2FyZFJlZiA9IDExO1xudmFyIFByb2ZpbGVyID0gMTI7XG52YXIgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbnZhciBNZW1vQ29tcG9uZW50ID0gMTQ7XG52YXIgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xudmFyIExhenlDb21wb25lbnQgPSAxNjtcbnZhciBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbnZhciBEZWh5ZHJhdGVkRnJhZ21lbnQgPSAxODtcbnZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIE9mZnNjcmVlbkNvbXBvbmVudCA9IDIyO1xudmFyIExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IDIzO1xudmFyIENhY2hlQ29tcG9uZW50ID0gMjQ7XG52YXIgVHJhY2luZ01hcmtlckNvbXBvbmVudCA9IDI1O1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKTtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QudHJhY2luZ19tYXJrZXInKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUkMShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lJDEodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgdmFyIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnQ2FjaGUnO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lJDEocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRGVoeWRyYXRlZEZyYWdtZW50JztcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSQxKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgLy8gSG9zdCBjb21wb25lbnQgdHlwZSBpcyB0aGUgZGlzcGxheSBuYW1lIChlLmcuIFwiZGl2XCIsIFwiVmlld1wiKVxuICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuICdSb290JztcblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gJ1RleHQnO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgLy8gTmFtZSBjb21lcyBmcm9tIHRoZSB0eXBlIGluIHRoaXMgY2FzZTsgd2UgZG9uJ3QgaGF2ZSBhIHRhZy5cbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSkge1xuICAgICAgICAvLyBEb24ndCBiZSBsZXNzIHNwZWNpZmljIHRoYW4gc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuICAgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ01vZGUnO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTY29wZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnVHJhY2luZ01hcmtlcic7XG4gICAgLy8gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhpcyB0YWdzIGNvbWUgZnJvbSB0aGUgdXNlci1wcm92aWRlZCB0eXBlOlxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuUGxhY2VtZW50IHwgVXBkYXRlO1xudmFyIENoaWxkRGVsZXRpb24gPVxuLyogICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENvbnRlbnRSZXNldCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIENhbGxiYWNrID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjY0O1xudmFyIERpZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBGb3JjZUNsaWVudFJlbmRlciA9XG4vKiAgICAgICAgICAgICovXG4yNTY7XG52YXIgUmVmID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyO1xudmFyIFNuYXBzaG90ID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgUGFzc2l2ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBIeWRyYXRpbmcgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIEh5ZHJhdGluZ0FuZFVwZGF0ZSA9XG4vKiAgICAgICAgICAgKi9cbkh5ZHJhdGluZyB8IFVwZGF0ZTtcbnZhciBWaXNpYmlsaXR5ID1cbi8qICAgICAgICAgICAgICAgICAgICovXG44MTkyO1xudmFyIFN0b3JlQ29uc2lzdGVuY3kgPVxuLyogICAgICAgICAgICAgKi9cbjE2Mzg0O1xudmFyIExpZmVjeWNsZUVmZmVjdE1hc2sgPSBQYXNzaXZlIHwgVXBkYXRlIHwgQ2FsbGJhY2sgfCBSZWYgfCBTbmFwc2hvdCB8IFN0b3JlQ29uc2lzdGVuY3k7IC8vIFVuaW9uIG9mIGFsbCBjb21taXQgZmxhZ3MgKGZsYWdzIHdpdGggdGhlIGxpZmV0aW1lIG9mIGEgcGFydGljdWxhciBjb21taXQpXG5cbnZhciBIb3N0RWZmZWN0TWFzayA9XG4vKiAgICAgICAgICAgICAgICovXG4zMjc2NzsgLy8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cblxudmFyIEluY29tcGxldGUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFNob3VsZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgKi9cbjY1NTM2O1xudmFyIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UgPVxuLyogKi9cbjEzMTA3MjtcbnZhciBGb3JrZWQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4xMDQ4NTc2OyAvLyBTdGF0aWMgdGFncyBkZXNjcmliZSBhc3BlY3RzIG9mIGEgZmliZXIgdGhhdCBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLFxuLy8gZS5nLiBhIGZpYmVyIHVzZXMgYSBwYXNzaXZlIGVmZmVjdCAoZXZlbiBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlcyBvbiB0aGlzIHBhcnRpY3VsYXIgcmVuZGVyKS5cbi8vIFRoaXMgZW5hYmxlcyB1cyB0byBkZWZlciBtb3JlIHdvcmsgaW4gdGhlIHVubW91bnQgY2FzZSxcbi8vIHNpbmNlIHdlIGNhbiBkZWZlciB0cmF2ZXJzaW5nIHRoZSB0cmVlIGR1cmluZyBsYXlvdXQgdG8gbG9vayBmb3IgUGFzc2l2ZSBlZmZlY3RzLFxuLy8gYW5kIGluc3RlYWQgcmVseSBvbiB0aGUgc3RhdGljIGZsYWcgYXMgYSBzaWduYWwgdGhhdCB0aGVyZSBtYXkgYmUgY2xlYW51cCB3b3JrLlxuXG52YXIgUmVmU3RhdGljID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBMYXlvdXRTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgICovXG40MTk0MzA0O1xudmFyIFBhc3NpdmVTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7IC8vIFRoZXNlIGZsYWdzIGFsbG93IHVzIHRvIHRyYXZlcnNlIHRvIGZpYmVycyB0aGF0IGhhdmUgZWZmZWN0cyBvbiBtb3VudFxuLy8gd2l0aG91dCB0cmF2ZXJzaW5nIHRoZSBlbnRpcmUgdHJlZSBhZnRlciBldmVyeSBjb21taXQgZm9yXG4vLyBkb3VibGUgaW52b2tpbmdcblxudmFyIE1vdW50TGF5b3V0RGV2ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIE1vdW50UGFzc2l2ZURldiA9XG4vKiAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyOyAvLyBHcm91cHMgb2YgZmxhZ3MgdGhhdCBhcmUgdXNlZCBpbiB0aGUgY29tbWl0IHBoYXNlIHRvIHNraXAgb3ZlciB0cmVlcyB0aGF0XG4vLyBkb24ndCBjb250YWluIGVmZmVjdHMsIGJ5IGNoZWNraW5nIHN1YnRyZWVGbGFncy5cblxudmFyIEJlZm9yZU11dGF0aW9uTWFzayA9IC8vIFRPRE86IFJlbW92ZSBVcGRhdGUgZmxhZyBmcm9tIGJlZm9yZSBtdXRhdGlvbiBwaGFzZSBieSByZS1sYW5kaW5nIFZpc2liaWxpdHlcbi8vIGZsYWcgbG9naWMgKHNlZSAjMjAwNDMpXG5VcGRhdGUgfCBTbmFwc2hvdCB8ICggMCk7XG52YXIgTXV0YXRpb25NYXNrID0gUGxhY2VtZW50IHwgVXBkYXRlIHwgQ2hpbGREZWxldGlvbiB8IENvbnRlbnRSZXNldCB8IFJlZiB8IEh5ZHJhdGluZyB8IFZpc2liaWxpdHk7XG52YXIgTGF5b3V0TWFzayA9IFVwZGF0ZSB8IENhbGxiYWNrIHwgUmVmIHwgVmlzaWJpbGl0eTsgLy8gVE9ETzogU3BsaXQgaW50byBQYXNzaXZlTW91bnRNYXNrIGFuZCBQYXNzaXZlVW5tb3VudE1hc2tcblxudmFyIFBhc3NpdmVNYXNrID0gUGFzc2l2ZSB8IENoaWxkRGVsZXRpb247IC8vIFVuaW9uIG9mIHRhZ3MgdGhhdCBkb24ndCBnZXQgcmVzZXQgb24gY2xvbmVzLlxuLy8gVGhpcyBhbGxvd3MgY2VydGFpbiBjb25jZXB0cyB0byBwZXJzaXN0IHdpdGhvdXQgcmVjYWxjdWxhdGluZyB0aGVtLFxuLy8gZS5nLiB3aGV0aGVyIGEgc3VidHJlZSBjb250YWlucyBwYXNzaXZlIGVmZmVjdHMgb3IgcG9ydGFscy5cblxudmFyIFN0YXRpY01hc2sgPSBMYXlvdXRTdGF0aWMgfCBQYXNzaXZlU3RhdGljIHwgUmVmU3RhdGljO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmV4dE5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG5cbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcblxuICAgIGlmIChwYXJlbnRBID09PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cbiAgICBpZiAocGFyZW50QiA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4gICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgLy8gaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiB0aGUgU3VzcGVuc2UgZmliZXIgYW5kIGl0cyBjaGlsZHJlbi4gU2tpcFxuICAgICAgLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbiAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cbiAgICAgIGlmIChuZXh0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGEgPSBiID0gbmV4dFBhcmVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSdyZSBhdCB0aGUgcm9vdC5cblxuXG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cblxuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH0gLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyAnICsgJ2luIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhLmFsdGVybmF0ZSAhPT0gYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIiArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG5cblxuICBpZiAoYS50YWcgIT09IEhvc3RSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gIH1cblxuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuXG5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGN1cnJlbnRQYXJlbnQpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY2hpbGQpO1xuXG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICByZXR1cm4gY3VycmVudFBhcmVudCAhPT0gbnVsbCA/IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY3VycmVudFBhcmVudCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoY2hpbGQudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGNoaWxkKTtcblxuICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGlzIGlzIGEgaG9zdCBjb25maWcgdGhhdCdzIHVzZWQgZm9yIHRoZSBgcmVhY3QtcmVjb25jaWxlcmAgcGFja2FnZSBvbiBucG0uXG4vLyBJdCBpcyBvbmx5IHVzZWQgYnkgdGhpcmQtcGFydHkgcmVuZGVyZXJzLlxuLy9cbi8vIEl0cyBBUEkgbGV0cyB5b3UgcGFzcyB0aGUgaG9zdCBjb25maWcgYXMgYW4gYXJndW1lbnQuXG4vLyBIb3dldmVyLCBpbnNpZGUgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCB3ZSB0cmVhdCBob3N0IGNvbmZpZyBhcyBhIG1vZHVsZS5cbi8vIFRoaXMgZmlsZSBpcyBhIHNoaW0gYmV0d2VlbiB0d28gd29ybGRzLlxuLy9cbi8vIEl0IHdvcmtzIGJlY2F1c2UgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCBidW5kbGUgaXMgd3JhcHBlZCBpbiBzb21ldGhpbmcgbGlrZTpcbi8vXG4vLyBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkJCRjb25maWcpIHtcbi8vICAgLyogcmVjb25jaWxlciBjb2RlICovXG4vLyB9XG4vL1xuLy8gU28gYCQkJGNvbmZpZ2AgbG9va3MgbGlrZSBhIGdsb2JhbCB2YXJpYWJsZSwgYnV0IGl0J3Ncbi8vIHJlYWxseSBhbiBhcmd1bWVudCB0byBhIHRvcC1sZXZlbCB3cmFwcGluZyBmdW5jdGlvbi5cbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbnZhciBnZXRQdWJsaWNJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZ2V0UHVibGljSW5zdGFuY2U7XG52YXIgZ2V0Um9vdEhvc3RDb250ZXh0ID0gJCQkaG9zdENvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG52YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9ICQkJGhvc3RDb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dDtcbnZhciBwcmVwYXJlRm9yQ29tbWl0ID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlRm9yQ29tbWl0O1xudmFyIHJlc2V0QWZ0ZXJDb21taXQgPSAkJCRob3N0Q29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG52YXIgY3JlYXRlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNyZWF0ZUluc3RhbmNlO1xudmFyIGFwcGVuZEluaXRpYWxDaGlsZCA9ICQkJGhvc3RDb25maWcuYXBwZW5kSW5pdGlhbENoaWxkO1xudmFyIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gJCQkaG9zdENvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbjtcbnZhciBwcmVwYXJlVXBkYXRlID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlVXBkYXRlO1xudmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gJCQkaG9zdENvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudDtcbnZhciBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZTtcbnZhciBzY2hlZHVsZVRpbWVvdXQgPSAkJCRob3N0Q29uZmlnLnNjaGVkdWxlVGltZW91dDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gJCQkaG9zdENvbmZpZy5jYW5jZWxUaW1lb3V0O1xudmFyIG5vVGltZW91dCA9ICQkJGhvc3RDb25maWcubm9UaW1lb3V0O1xudmFyIG5vdyA9ICQkJGhvc3RDb25maWcubm93O1xudmFyIGlzUHJpbWFyeVJlbmRlcmVyID0gJCQkaG9zdENvbmZpZy5pc1ByaW1hcnlSZW5kZXJlcjtcbnZhciB3YXJuc0lmTm90QWN0aW5nID0gJCQkaG9zdENvbmZpZy53YXJuc0lmTm90QWN0aW5nO1xudmFyIHN1cHBvcnRzTXV0YXRpb24gPSAkJCRob3N0Q29uZmlnLnN1cHBvcnRzTXV0YXRpb247XG52YXIgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGhvc3RDb25maWcuc3VwcG9ydHNQZXJzaXN0ZW5jZTtcbnZhciBzdXBwb3J0c0h5ZHJhdGlvbiA9ICQkJGhvc3RDb25maWcuc3VwcG9ydHNIeWRyYXRpb247XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9ICQkJGhvc3RDb25maWcuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbnZhciBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIgPSAkJCRob3N0Q29uZmlnLmJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjtcbnZhciBhZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICQkJGhvc3RDb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG52YXIgcHJlcGFyZVBvcnRhbE1vdW50ID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG52YXIgcHJlcGFyZVNjb3BlVXBkYXRlID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG52YXIgZ2V0SW5zdGFuY2VGcm9tU2NvcGUgPSAkJCRob3N0Q29uZmlnLmdldEluc3RhbmNlRnJvbVNjb3BlO1xudmFyIGdldEN1cnJlbnRFdmVudFByaW9yaXR5ID0gJCQkaG9zdENvbmZpZy5nZXRDdXJyZW50RXZlbnRQcmlvcml0eTtcbnZhciBkZXRhY2hEZWxldGVkSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRldGFjaERlbGV0ZWRJbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgICBNaWNyb3Rhc2tzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNNaWNyb3Rhc2tzID0gJCQkaG9zdENvbmZpZy5zdXBwb3J0c01pY3JvdGFza3M7XG52YXIgc2NoZWR1bGVNaWNyb3Rhc2sgPSAkJCRob3N0Q29uZmlnLnNjaGVkdWxlTWljcm90YXNrOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgIFRlc3Qgc2VsZWN0b3JzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNUZXN0U2VsZWN0b3JzID0gJCQkaG9zdENvbmZpZy5zdXBwb3J0c1Rlc3RTZWxlY3RvcnM7XG52YXIgZmluZEZpYmVyUm9vdCA9ICQkJGhvc3RDb25maWcuZmluZEZpYmVyUm9vdDtcbnZhciBnZXRCb3VuZGluZ1JlY3QgPSAkJCRob3N0Q29uZmlnLmdldEJvdW5kaW5nUmVjdDtcbnZhciBnZXRUZXh0Q29udGVudCA9ICQkJGhvc3RDb25maWcuZ2V0VGV4dENvbnRlbnQ7XG52YXIgaXNIaWRkZW5TdWJ0cmVlID0gJCQkaG9zdENvbmZpZy5pc0hpZGRlblN1YnRyZWU7XG52YXIgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSA9ICQkJGhvc3RDb25maWcubWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZTtcbnZhciBzZXRGb2N1c0lmRm9jdXNhYmxlID0gJCQkaG9zdENvbmZpZy5zZXRGb2N1c0lmRm9jdXNhYmxlO1xudmFyIHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAkJCRob3N0Q29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgTXV0YXRpb25cbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBhcHBlbmRDaGlsZCA9ICQkJGhvc3RDb25maWcuYXBwZW5kQ2hpbGQ7XG52YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjtcbnZhciBjb21taXRUZXh0VXBkYXRlID0gJCQkaG9zdENvbmZpZy5jb21taXRUZXh0VXBkYXRlO1xudmFyIGNvbW1pdE1vdW50ID0gJCQkaG9zdENvbmZpZy5jb21taXRNb3VudDtcbnZhciBjb21taXRVcGRhdGUgPSAkJCRob3N0Q29uZmlnLmNvbW1pdFVwZGF0ZTtcbnZhciBpbnNlcnRCZWZvcmUgPSAkJCRob3N0Q29uZmlnLmluc2VydEJlZm9yZTtcbnZhciBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9ICQkJGhvc3RDb25maWcuaW5zZXJ0SW5Db250YWluZXJCZWZvcmU7XG52YXIgcmVtb3ZlQ2hpbGQgPSAkJCRob3N0Q29uZmlnLnJlbW92ZUNoaWxkO1xudmFyIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xudmFyIHJlc2V0VGV4dENvbnRlbnQgPSAkJCRob3N0Q29uZmlnLnJlc2V0VGV4dENvbnRlbnQ7XG52YXIgaGlkZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oaWRlSW5zdGFuY2U7XG52YXIgaGlkZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaGlkZVRleHRJbnN0YW5jZTtcbnZhciB1bmhpZGVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcudW5oaWRlSW5zdGFuY2U7XG52YXIgdW5oaWRlVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy51bmhpZGVUZXh0SW5zdGFuY2U7XG52YXIgY2xlYXJDb250YWluZXIgPSAkJCRob3N0Q29uZmlnLmNsZWFyQ29udGFpbmVyOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgUGVyc2lzdGVuY2Vcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBjbG9uZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jbG9uZUluc3RhbmNlO1xudmFyIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gJCQkaG9zdENvbmZpZy5jcmVhdGVDb250YWluZXJDaGlsZFNldDtcbnZhciBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRob3N0Q29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldDtcbnZhciBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkaG9zdENvbmZpZy5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuO1xudmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9ICQkJGhvc3RDb25maWcucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuO1xudmFyIGdldE9mZnNjcmVlbkNvbnRhaW5lclR5cGUgPSAkJCRob3N0Q29uZmlnLmdldE9mZnNjcmVlbkNvbnRhaW5lclR5cGU7XG52YXIgZ2V0T2Zmc2NyZWVuQ29udGFpbmVyUHJvcHMgPSAkJCRob3N0Q29uZmlnLmdldE9mZnNjcmVlbkNvbnRhaW5lclByb3BzO1xudmFyIGNsb25lSGlkZGVuSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNsb25lSGlkZGVuSW5zdGFuY2U7XG52YXIgY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNsb25lSGlkZGVuVGV4dEluc3RhbmNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgSHlkcmF0aW9uXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jYW5IeWRyYXRlSW5zdGFuY2U7XG52YXIgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyA9ICQkJGhvc3RDb25maWcuaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZztcbnZhciBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayA9ICQkJGhvc3RDb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2s7XG52YXIgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkgPSAkJCRob3N0Q29uZmlnLnJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5O1xudmFyIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9ICQkJGhvc3RDb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nO1xudmFyIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gJCQkaG9zdENvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDtcbnZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXI7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgaHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oeWRyYXRlSW5zdGFuY2U7XG52YXIgaHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBjb21taXRIeWRyYXRlZENvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXI7XG52YXIgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2U7XG52YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5ID0gJCQkaG9zdENvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnk7XG52YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcjtcbnZhciBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyA9ICQkJGhvc3RDb25maWcuc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXM7XG52YXIgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTtcbnZhciBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlO1xudmFyIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyO1xudmFyIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RIeWRyYXRlSW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcjtcbnZhciBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXI7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlV2l0aGluQ29udGFpbmVyID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXI7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlO1xudmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlO1xudmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTtcbnZhciBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZXJyb3JIeWRyYXRpbmdDb250YWluZXIgPSAkJCRob3N0Q29uZmlnLmVycm9ySHlkcmF0aW5nQ29udGFpbmVyO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xudmFyIGZpYmVyU3RhY2s7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG52YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O1xuXG57XG4gIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufSAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlDb250ZXh0T2JqZWN0KTsgLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cblxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIpIHtcbiAge1xuICAgIGlmIChkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIgJiYgaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgICAgLy8gd2UgbWF5IGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9IC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gICAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuXG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICB7XG4gICAgaWYgKGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzOyAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gICAgLy8gSWYgdGhlIGluc3RhbmNlIGRvZXMgbm90IGV4aXN0IHlldCwgd2Ugd2lsbCBwdXNoIG51bGwgYXQgZmlyc3QsXG4gICAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuXG4gICAgdmFyIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgfHwgZW1wdHlDb250ZXh0T2JqZWN0OyAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gICAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG5cbiAgICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHR5cGUsIGRpZENoYW5nZSkge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuICAgICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7IC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG5cbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7IC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuXG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICAvLyBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgd2l0aCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsgbm90IHN1cmUgaWYgaXRcbiAgICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgICBpZiAoIWlzRmliZXJNb3VudGVkKGZpYmVyKSB8fCBmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IG5vZGUudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHBhcmVudC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbnZhciBMZWdhY3lSb290ID0gMDtcbnZhciBDb25jdXJyZW50Um9vdCA9IDE7XG5cbnZhciBOb01vZGUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7IC8vIFRPRE86IFJlbW92ZSBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3QgdGFnIGluc3RlYWRcblxudmFyIENvbmN1cnJlbnRNb2RlID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBQcm9maWxlTW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgU3RyaWN0TGVnYWN5TW9kZSA9XG4vKiAgICAgICAgICAgICAgICovXG44O1xudmFyIFN0cmljdEVmZmVjdHNNb2RlID1cbi8qICAgICAgICAgICAgICAqL1xuMTY7XG5cbi8vIFRPRE86IFRoaXMgaXMgcHJldHR5IHdlbGwgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzLiBNYXliZSB3ZSBjYW4gZHJvcCBpdC5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbmZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICB2YXIgYXNVaW50ID0geCA+Pj4gMDtcblxuICBpZiAoYXNVaW50ID09PSAwKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9XG5cbiAgcmV0dXJuIDMxIC0gKGxvZyhhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBJZiB0aG9zZSB2YWx1ZXMgYXJlIGNoYW5nZWQgdGhhdCBwYWNrYWdlIHNob3VsZCBiZSByZWJ1aWx0IGFuZCByZWRlcGxveWVkLlxuXG52YXIgVG90YWxMYW5lcyA9IDMxO1xudmFyIE5vTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBOb0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIFN5bmNMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAqL1xuMjtcbnZhciBJbnB1dENvbnRpbnVvdXNMYW5lID1cbi8qICAgICAgICAgICAgKi9cbjQ7XG52YXIgRGVmYXVsdEh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAqL1xuODtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBUcmFuc2l0aW9uTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG40MTk0MjQwO1xudmFyIFRyYW5zaXRpb25MYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG42NDtcbnZhciBUcmFuc2l0aW9uTGFuZTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFRyYW5zaXRpb25MYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgVHJhbnNpdGlvbkxhbmU0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBUcmFuc2l0aW9uTGFuZTUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBUcmFuc2l0aW9uTGFuZTYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBUcmFuc2l0aW9uTGFuZTcgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBUcmFuc2l0aW9uTGFuZTggPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBUcmFuc2l0aW9uTGFuZTkgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTYzODQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxMCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFRyYW5zaXRpb25MYW5lMTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBUcmFuc2l0aW9uTGFuZTEyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTMxMDcyO1xudmFyIFRyYW5zaXRpb25MYW5lMTMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4yNjIxNDQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUyNDI4ODtcbnZhciBUcmFuc2l0aW9uTGFuZTE1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTE2ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMzAwMjM0MjQ7XG52YXIgUmV0cnlMYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxOTQzMDQ7XG52YXIgUmV0cnlMYW5lMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7XG52YXIgUmV0cnlMYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIFJldHJ5TGFuZTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBSZXRyeUxhbmU1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjcxMDg4NjQ7XG52YXIgU29tZVJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAqL1xuMTM0MjE3NzI4O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNjg0MzU0NTU7XG52YXIgSWRsZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAqL1xuMjY4NDM1NDU2O1xudmFyIElkbGVMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xudmFyIE9mZnNjcmVlbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEwNzM3NDE4MjQ7IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgdGhlIGV4cGVyaW1lbnRhbCB0aW1lbGluZSAocmVhY3QtZGV2dG9vbHMtdGltZWxpbmUpXG4vLyBJdCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIExhbmVzIHZhbHVlcyBhYm92ZS5cblxuZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpIHtcbiAge1xuICAgIGlmIChsYW5lICYgU3luY0xhbmUpIHtcbiAgICAgIHJldHVybiAnU3luYyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91c0h5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNMYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91cyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZhdWx0SHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZhdWx0SHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIERlZmF1bHRMYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmF1bHQnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbkh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBSZXRyeUxhbmVzKSB7XG4gICAgICByZXR1cm4gJ1JldHJ5JztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnU2VsZWN0aXZlSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElkbGVIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lkbGVIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSWRsZUxhbmUpIHtcbiAgICAgIHJldHVybiAnSWRsZSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG4gICAgfVxuICB9XG59XG52YXIgTm9UaW1lc3RhbXAgPSAtMTtcbnZhciBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG52YXIgbmV4dFJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIHN3aXRjaCAoZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykpIHtcbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgICAgcmV0dXJuIFN5bmNMYW5lO1xuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgcmV0dXJuIERlZmF1bHRMYW5lO1xuXG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNjpcbiAgICAgIHJldHVybiBsYW5lcyAmIFRyYW5zaXRpb25MYW5lcztcblxuICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICBjYXNlIFJldHJ5TGFuZTI6XG4gICAgY2FzZSBSZXRyeUxhbmUzOlxuICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICBjYXNlIFJldHJ5TGFuZTU6XG4gICAgICByZXR1cm4gbGFuZXMgJiBSZXRyeUxhbmVzO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElkbGVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIHJldHVybiBJZGxlTGFuZTtcblxuICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcbiAgICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgICAgIHJldHVybiBsYW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybiBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIG5leHRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7IC8vIERvIG5vdCB3b3JrIG9uIGFueSBpZGxlIHdvcmsgdW50aWwgYWxsIHRoZSBub24taWRsZSB3b3JrIGhhcyBmaW5pc2hlZCxcbiAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG5cbiAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiBOb25JZGxlTGFuZXM7XG5cbiAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbm9uSWRsZVVuYmxvY2tlZExhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgIGlmIChub25JZGxlVW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgIGlmIChub25JZGxlUGluZ2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbiAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICBpZiAodW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cblxuICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4gIC8vIGJvdGhlciB3YWl0aW5nIHVudGlsIHRoZSByb290IGlzIGNvbXBsZXRlLlxuICAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbmV4dExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7XG4gICAgdmFyIHdpcExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHdpcExhbmVzKTtcblxuICAgIGlmICggLy8gVGVzdHMgd2hldGhlciB0aGUgbmV4dCBsYW5lIGlzIGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5IHRoYW4gdGhlIHdpcFxuICAgIC8vIG9uZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXRzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICAgIG5leHRMYW5lID49IHdpcExhbmUgfHwgLy8gRGVmYXVsdCBwcmlvcml0eSB1cGRhdGVzIHNob3VsZCBub3QgaW50ZXJydXB0IHRyYW5zaXRpb24gdXBkYXRlcy4gVGhlXG4gICAgLy8gb25seSBkaWZmZXJlbmNlIGJldHdlZW4gZGVmYXVsdCB1cGRhdGVzIGFuZCB0cmFuc2l0aW9uIHVwZGF0ZXMgaXMgdGhhdFxuICAgIC8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxuICAgIG5leHRMYW5lID09PSBEZWZhdWx0TGFuZSAmJiAod2lwTGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICAgIC8vIEtlZXAgd29ya2luZyBvbiB0aGUgZXhpc3RpbmcgaW4tcHJvZ3Jlc3MgdHJlZS4gRG8gbm90IGludGVycnVwdC5cbiAgICAgIHJldHVybiB3aXBMYW5lcztcbiAgICB9XG4gIH1cblxuICBpZiAoKG5leHRMYW5lcyAmIElucHV0Q29udGludW91c0xhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gV2hlbiB1cGRhdGVzIGFyZSBzeW5jIGJ5IGRlZmF1bHQsIHdlIGVudGFuZ2xlIGNvbnRpbnVvdXMgcHJpb3JpdHkgdXBkYXRlc1xuICAgIC8vIGFuZCBkZWZhdWx0IHVwZGF0ZXMsIHNvIHRoZXkgcmVuZGVyIGluIHRoZSBzYW1lIGJhdGNoLiBUaGUgb25seSByZWFzb25cbiAgICAvLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG4gICAgLy8gdHJhbnNpdGlvbnMsIGJ1dCBkZWZhdWx0IHVwZGF0ZXMgc2hvdWxkIG5vdC5cbiAgICBuZXh0TGFuZXMgfD0gcGVuZGluZ0xhbmVzICYgRGVmYXVsdExhbmU7XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcy4gVGhlIGNvdW50ZXItYXJndW1lbnQgaXMgdGhhdCB0aGUgcGFydGlhbCB3b3JrXG4gIC8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gIC8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG4gIC8vIHRpbWUgaXQgdGFrZXMgdG8gc2hvdyB0aGUgZmluYWwgc3RhdGUsIHdoaWNoIGlzIHdoYXQgdGhleSBhcmUgYWN0dWFsbHlcbiAgLy8gd2FpdGluZyBmb3IuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LCBsaWtlXG4gIC8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4gIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG4gIHZhciBlbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG5cbiAgaWYgKGVudGFuZ2xlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gICAgdmFyIGxhbmVzID0gbmV4dExhbmVzICYgZW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIG5leHRMYW5lcyB8PSBlbnRhbmdsZW1lbnRzW2luZGV4XTtcbiAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV2ZW50VGltZSA9IGV2ZW50VGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV2ZW50VGltZSA+IG1vc3RSZWNlbnRFdmVudFRpbWUpIHtcbiAgICAgIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBldmVudFRpbWU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICByZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIHN3aXRjaCAobGFuZSkge1xuICAgIGNhc2UgU3luY0xhbmU6XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgc2V0IHRvIHRoZSBjb3JyZXNwb25kaW5nIGNvbnN0YW50IGFzIGluIFNjaGVkdWxlci5qcy5cbiAgICAgIC8vIFdoZW4gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZ1xuICAgICAgLy8gdGhlcmUncyBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCdzIGJlaW5nIHN0YXJ2ZWQgYnkgYSBzZXJpZXMgb2ZcbiAgICAgIC8vIHN5bmNocm9ub3VzIHVwZGF0ZXMuIElmIHRoYXQgdGhlb3J5IGlzIGNvcnJlY3QsIHRoZSBwcm9wZXIgc29sdXRpb24gaXNcbiAgICAgIC8vIHRvIGZpeCB0aGUgc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0XG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzIGFyZSBhbiBpbXBvcnRhbnQgc2FmZWd1YXJkIHdoZW4gc3RhcnZhdGlvblxuICAgICAgLy8gZG9lcyBoYXBwZW4uXG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyAyNTA7XG5cbiAgICBjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgIGNhc2UgUmV0cnlMYW5lNTpcbiAgICAgIC8vIFRPRE86IFJldHJpZXMgc2hvdWxkIGJlIGFsbG93ZWQgdG8gZXhwaXJlIGlmIHRoZXkgYXJlIENQVSBib3VuZCBmb3JcbiAgICAgIC8vIHRvbyBsb25nLCBidXQgd2hlbiBJIG1hZGUgdGhpcyBjaGFuZ2UgaXQgY2F1c2VkIGEgc3Bpa2UgaW4gYnJvd3NlclxuICAgICAgLy8gY3Jhc2hlcy4gVGhlcmUgbXVzdCBiZSBzb21lIG90aGVyIHVuZGVybHlpbmcgYnVnOyBub3Qgc3VwZXIgdXJnZW50IGJ1dFxuICAgICAgLy8gaWRlYWxseSBzaG91bGQgZmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gVW5mb3J0dW5hdGVseSB3ZSBkb24ndCBoYXZlXG4gICAgICAvLyBhIHJlcHJvIGZvciB0aGUgY3Jhc2hlcywgb25seSBkZXRlY3RlZCB2aWEgcHJvZHVjdGlvbiBtZXRyaWNzLlxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICBjYXNlIE9mZnNjcmVlbkxhbmU6XG4gICAgICAvLyBBbnl0aGluZyBpZGxlIHByaW9yaXR5IG9yIGxvd2VyIHNob3VsZCBuZXZlciBleHBpcmUuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3JpbmdcbiAgLy8gdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZSBvbiB0aGUgcm9vdC4gVGhlbiB1c2UgdGhhdCB0byBxdWlja2x5IGJhaWwgb3V0XG4gIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbiAgLy8gZXhwaXJhdGlvbiB0aW1lLiBJZiBzbywgd2UnbGwgYXNzdW1lIHRoZSB1cGRhdGUgaXMgYmVpbmcgc3RhcnZlZCBhbmQgbWFya1xuICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuICAgICAgLy8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3JcbiAgICAgIC8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgaWYgKChsYW5lICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzIHx8IChsYW5lICYgcGluZ2VkTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIC8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufSAvLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuLy8gYXJlIHN1c3BlbmRlZC5cblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpIHtcbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHJvb3QucGVuZGluZ0xhbmVzKTtcbn1cbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNTeW5jTGFuZShsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgU3luY0xhbmUpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSB7XG5cbiAgdmFyIFN5bmNEZWZhdWx0TGFuZXMgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRIeWRyYXRpb25MYW5lIHwgRGVmYXVsdExhbmU7XG4gIHJldHVybiAobGFuZXMgJiBTeW5jRGVmYXVsdExhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCwgbGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhIHNlcGFyYXRlIGNoZWNrIGZyb20gaW5jbHVkZXNCbG9ja2luZ0xhbmUgYmVjYXVzZSBhIGxhbmUgY2FuXG4gIC8vIGV4cGlyZSBhZnRlciBhIHJlbmRlciBoYXMgYWxyZWFkeSBzdGFydGVkLlxuICByZXR1cm4gKGxhbmVzICYgcm9vdC5leHBpcmVkTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uTGFuZShsYW5lKSB7XG4gIHJldHVybiAobGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IDA7XG59XG5mdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpIHtcbiAgLy8gQ3ljbGUgdGhyb3VnaCB0aGUgbGFuZXMsIGFzc2lnbmluZyBlYWNoIG5ldyB0cmFuc2l0aW9uIHRvIHRoZSBuZXh0IGxhbmUuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgbWVhbnMgZXZlcnkgdHJhbnNpdGlvbiBnZXRzIGl0cyBvd24gbGFuZSwgdW50aWwgd2VcbiAgLy8gcnVuIG91dCBvZiBsYW5lcyBhbmQgY3ljbGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLlxuICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuXG4gIGlmICgobmV4dFRyYW5zaXRpb25MYW5lICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gMCkge1xuICAgIG5leHRUcmFuc2l0aW9uTGFuZSA9IFRyYW5zaXRpb25MYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gIG5leHRSZXRyeUxhbmUgPDw9IDE7XG5cbiAgaWYgKChuZXh0UmV0cnlMYW5lICYgUmV0cnlMYW5lcykgPT09IDApIHtcbiAgICBuZXh0UmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykge1xuICByZXR1cm4gbGFuZXMgJiAtbGFuZXM7XG59XG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdExhbmVzKGEsIGIpIHtcbiAgcmV0dXJuIGEgJiBiO1xufSAvLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuXG5mdW5jdGlvbiBsYW5lVG9MYW5lcyhsYW5lKSB7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gaGlnaGVyUHJpb3JpdHlMYW5lKGEsIGIpIHtcbiAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXQgcmFuZ2VzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICByZXR1cm4gYSAhPT0gTm9MYW5lICYmIGEgPCBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgLy8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG4gIC8vIGh0dHBzOi8vdjguZGV2L2Jsb2cvZWxlbWVudHMta2luZHMjYXZvaWQtY3JlYXRpbmctaG9sZXNcbiAgdmFyIGxhbmVNYXAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFRvdGFsTGFuZXM7IGkrKykge1xuICAgIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHVwZGF0ZUxhbmUsIGV2ZW50VGltZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lOyAvLyBJZiB0aGVyZSBhcmUgYW55IHN1c3BlbmRlZCB0cmFuc2l0aW9ucywgaXQncyBwb3NzaWJsZSB0aGlzIG5ldyB1cGRhdGVcbiAgLy8gY291bGQgdW5ibG9jayB0aGVtLiBDbGVhciB0aGUgc3VzcGVuZGVkIGxhbmVzIHNvIHRoYXQgd2UgY2FuIHRyeSByZW5kZXJpbmdcbiAgLy8gdGhlbSBhZ2Fpbi5cbiAgLy9cbiAgLy8gVE9ETzogV2UgcmVhbGx5IG9ubHkgbmVlZCB0byB1bnN1c3BlbmQgb25seSBsYW5lcyB0aGF0IGFyZSBpbiB0aGVcbiAgLy8gYHN1YnRyZWVMYW5lc2Agb2YgdGhlIHVwZGF0ZWQgZmliZXIsIG9yIHRoZSB1cGRhdGUgbGFuZXMgb2YgdGhlIHJldHVyblxuICAvLyBwYXRoLiBUaGlzIHdvdWxkIGV4Y2x1ZGUgc3VzcGVuZGVkIHVwZGF0ZXMgaW4gYW4gdW5yZWxhdGVkIHNpYmxpbmcgdHJlZSxcbiAgLy8gc2luY2UgdGhlcmUncyBubyB3YXkgZm9yIHRoaXMgdXBkYXRlIHRvIHVuYmxvY2sgaXQuXG4gIC8vXG4gIC8vIFdlIGRvbid0IGRvIHRoaXMgaWYgdGhlIGluY29taW5nIHVwZGF0ZSBpcyBpZGxlLCBiZWNhdXNlIHdlIG5ldmVyIHByb2Nlc3NcbiAgLy8gaWRsZSB1cGRhdGVzIHVudGlsIGFmdGVyIGFsbCB0aGUgcmVndWxhciB1cGRhdGVzIGhhdmUgZmluaXNoZWQ7IHRoZXJlJ3Mgbm9cbiAgLy8gd2F5IGl0IGNvdWxkIHVuYmxvY2sgYSB0cmFuc2l0aW9uLlxuXG4gIGlmICh1cGRhdGVMYW5lICE9PSBJZGxlTGFuZSkge1xuICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHJvb3QucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KHVwZGF0ZUxhbmUpOyAvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3RcbiAgLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuXG4gIGV2ZW50VGltZXNbaW5kZXhdID0gZXZlbnRUaW1lO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7IC8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMsIGV2ZW50VGltZSkge1xuICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgdmFyIG5vTG9uZ2VyUGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7IC8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5cbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IDA7XG4gIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5tdXRhYmxlUmVhZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gQ2xlYXIgdGhlIGxhbmVzIHRoYXQgbm8gbG9uZ2VyIGhhdmUgcGVuZGluZyB3b3JrXG5cbiAgdmFyIGxhbmVzID0gbm9Mb25nZXJQZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IE5vTGFuZXM7XG4gICAgZXZlbnRUaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gIC8vIEluIGFkZGl0aW9uIHRvIGVudGFuZ2xpbmcgZWFjaCBvZiB0aGUgZ2l2ZW4gbGFuZXMgd2l0aCBlYWNoIG90aGVyLCB3ZSBhbHNvXG4gIC8vIGhhdmUgdG8gY29uc2lkZXIgX3RyYW5zaXRpdmVfIGVudGFuZ2xlbWVudHMuIEZvciBlYWNoIGxhbmUgdGhhdCBpcyBhbHJlYWR5XG4gIC8vIGVudGFuZ2xlZCB3aXRoICphbnkqIG9mIHRoZSBnaXZlbiBsYW5lcywgdGhhdCBsYW5lIGlzIG5vdyB0cmFuc2l0aXZlbHlcbiAgLy8gZW50YW5nbGVkIHdpdGggKmFsbCogdGhlIGdpdmVuIGxhbmVzLlxuICAvL1xuICAvLyBUcmFuc2xhdGVkOiBJZiBDIGlzIGVudGFuZ2xlZCB3aXRoIEEsIHRoZW4gZW50YW5nbGluZyBBIHdpdGggQiBhbHNvXG4gIC8vIGVudGFuZ2xlcyBDIHdpdGggQi5cbiAgLy9cbiAgLy8gSWYgdGhpcyBpcyBoYXJkIHRvIGdyYXNwLCBpdCBtaWdodCBoZWxwIHRvIGludGVudGlvbmFsbHkgYnJlYWsgdGhpc1xuICAvLyBmdW5jdGlvbiBhbmQgbG9vayBhdCB0aGUgdGVzdHMgdGhhdCBmYWlsIGluIFJlYWN0VHJhbnNpdGlvbi10ZXN0LmpzLiBUcnlcbiAgLy8gY29tbWVudGluZyBvdXQgb25lIG9mIHRoZSBjb25kaXRpb25zIGJlbG93LlxuICB2YXIgcm9vdEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcztcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBsYW5lcyA9IHJvb3RFbnRhbmdsZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMpIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG5cbiAgICBpZiAoIC8vIElzIHRoaXMgb25lIG9mIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG4gICAgbGFuZSAmIGVudGFuZ2xlZExhbmVzIHwgLy8gSXMgdGhpcyBsYW5lIHRyYW5zaXRpdmVseSBlbnRhbmdsZWQgd2l0aCB0aGUgbmV3bHkgZW50YW5nbGVkIGxhbmVzP1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdICYgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gIHZhciByZW5kZXJMYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShyZW5kZXJMYW5lcyk7XG4gIHZhciBsYW5lO1xuXG4gIHN3aXRjaCAocmVuZGVyTGFuZSkge1xuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIGxhbmUgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgbGFuZSA9IERlZmF1bHRIeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgIGNhc2UgUmV0cnlMYW5lNTpcbiAgICAgIGxhbmUgPSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIGxhbmUgPSBJZGxlSHlkcmF0aW9uTGFuZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBhbHJlYWR5IGVpdGhlciBhIGh5ZHJhdGlvbiBsYW5lLCBvciBzaG91bGRuJ3RcbiAgICAgIC8vIGJlIHJldHJpZWQgYXQgYSBoeWRyYXRpb24gbGFuZS5cbiAgICAgIGxhbmUgPSBOb0xhbmU7XG4gICAgICBicmVhaztcbiAgfSAvLyBDaGVjayBpZiB0aGUgbGFuZSB3ZSBjaG9zZSBpcyBzdXNwZW5kZWQuIElmIHNvLCB0aGF0IGluZGljYXRlcyB0aGF0IHdlXG4gIC8vIGFscmVhZHkgYXR0ZW1wdGVkIGFuZCBmYWlsZWQgdG8gaHlkcmF0ZSBhdCB0aGF0IGxldmVsLiBBbHNvIGNoZWNrIGlmIHdlJ3JlXG4gIC8vIGFscmVhZHkgcmVuZGVyaW5nIHRoYXQgbGFuZSwgd2hpY2ggaXMgcmFyZSBidXQgY291bGQgaGFwcGVuLlxuXG5cbiAgaWYgKChsYW5lICYgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfCByZW5kZXJMYW5lcykpICE9PSBOb0xhbmUpIHtcbiAgICAvLyBHaXZlIHVwIHRyeWluZyB0byBoeWRyYXRlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlci5cbiAgICByZXR1cm4gTm9MYW5lO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmVzKSB7XG5cbiAgaWYgKCFpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciB1cGRhdGVycyA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuICAgIHVwZGF0ZXJzLmFkZChmaWJlcik7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcykge1xuXG4gIGlmICghaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDtcbiAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIHVwZGF0ZXJzID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG5cbiAgICBpZiAodXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgIHVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCAhbWVtb2l6ZWRVcGRhdGVycy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1cGRhdGVycy5jbGVhcigpO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBTeW5jTGFuZTtcbnZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmU7XG52YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0TGFuZTtcbnZhciBJZGxlRXZlbnRQcmlvcml0eSA9IElkbGVMYW5lO1xudmFyIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IE5vTGFuZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSwgZm4pIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG5cbiAgdHJ5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmV2aW91c1ByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBoaWdoZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IDAgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGxvd2VyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSAwIHx8IGEgPiBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYjtcbn1cbmZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG4gIHZhciBsYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7XG5cbiAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5LCBsYW5lKSkge1xuICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoIWlzSGlnaGVyRXZlbnRQcmlvcml0eShDb250aW51b3VzRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcbiAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoaW5jbHVkZXNOb25JZGxlV29yayhsYW5lKSkge1xuICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIHJldHVybiBJZGxlRXZlbnRQcmlvcml0eTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgb25seSBleGlzdHMgYXMgYW4gRVNNIHdyYXBwZXIgYXJvdW5kIHRoZSBleHRlcm5hbCBDb21tb25KU1xudmFyIHNjaGVkdWxlQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaztcbnZhciBjYW5jZWxDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaztcbnZhciBzaG91bGRZaWVsZCA9IFNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZDtcbnZhciByZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50O1xudmFyIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eTtcbnZhciBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eTtcbnZhciBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5O1xuLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IG9uIHRoZSBzY2hlZHVsZXIsIGJ1dCBpdCAqZG9lcypcbi8vIG9uIHNjaGVkdWxlci91bnN0YWJsZV9tb2NrLCB3aGljaCB3ZSdsbCBuZWVkIGZvciBpbnRlcm5hbCB0ZXN0aW5nXG52YXIgdW5zdGFibGVfeWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV95aWVsZFZhbHVlO1xudmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcikge1xuICAgICAgLy8gQ29uZGl0aW9uYWxseSBpbmplY3QgdGhlc2UgaG9va3Mgb25seSBpZiBUaW1lbGluZSBwcm9maWxlciBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBidWlsZC5cbiAgICAgIC8vIFRoaXMgZ2l2ZXMgRGV2VG9vbHMgYSB3YXkgdG8gZmVhdHVyZSBkZXRlY3QgdGhhdCBpc24ndCB0aWVkIHRvIHZlcnNpb24gbnVtYmVyXG4gICAgICAvLyAoc2luY2UgcHJvZmlsaW5nIGFuZCB0aW1lbGluZSBhcmUgY29udHJvbGxlZCBieSBkaWZmZXJlbnQgZmVhdHVyZSBmbGFncykuXG4gICAgICBpbnRlcm5hbHMgPSBhc3NpZ24oe30sIGludGVybmFscywge1xuICAgICAgICBnZXRMYW5lTGFiZWxNYXA6IGdldExhbmVMYWJlbE1hcCxcbiAgICAgICAgaW5qZWN0UHJvZmlsaW5nSG9va3M6IGluamVjdFByb2ZpbGluZ0hvb2tzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTsgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cblxuICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhvb2suY2hlY2tEQ0UpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSByZWFsIERldlRvb2xzLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgaG9vayBpbnN0YWxsZWQgYnkgRmFzdCBSZWZyZXNoIHJ1bnRpbWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuICB7XG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QsIGV2ZW50UHJpb3JpdHkpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkaWRFcnJvciA9IChyb290LmN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gRGlkQ2FwdHVyZTtcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5O1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgICAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgc2NoZWR1bGVyUHJpb3JpdHksIGRpZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCB1bmRlZmluZWQsIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Qb3N0Q29tbWl0Um9vdChyb290KSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgdW5zdGFibGVfeWllbGRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UncmUgaW4gYSB0ZXN0IGJlY2F1c2UgU2NoZWR1bGVyLnVuc3RhYmxlX3lpZWxkVmFsdWUgb25seSBleGlzdHNcbiAgICAgIC8vIGluIFNjaGVkdWxlck1vY2suIFRvIHJlZHVjZSB0aGUgbm9pc2UgaW4gc3RyaWN0IG1vZGUgdGVzdHMsXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBhbmQgZGlzYWJsZSBzY2hlZHVsZXIgeWllbGRpbmcgZHVyaW5nIHRoZSBkb3VibGUgcmVuZGVyXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgc2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBQcm9maWxlciBBUEkgaG9va3NcblxuZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xufVxuXG5mdW5jdGlvbiBnZXRMYW5lTGFiZWxNYXAoKSB7XG4gIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciBsYW5lID0gMTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBUb3RhbExhbmVzOyBpbmRleCsrKSB7XG4gICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICBtYXAuc2V0KGxhbmUsIGxhYmVsKTtcbiAgICAgIGxhbmUgKj0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlciwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyWWllbGRlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgc3luY1F1ZXVlID0gbnVsbDtcbnZhciBpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MgPSBmYWxzZTtcbnZhciBpc0ZsdXNoaW5nU3luY1F1ZXVlID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZVN5bmNDYWxsYmFjayhjYWxsYmFjaykge1xuICAvLyBQdXNoIHRoaXMgY2FsbGJhY2sgaW50byBhbiBpbnRlcm5hbCBxdWV1ZS4gV2UnbGwgZmx1c2ggdGhlc2UgZWl0aGVyIGluXG4gIC8vIHRoZSBuZXh0IHRpY2ssIG9yIGVhcmxpZXIgaWYgc29tZXRoaW5nIGNhbGxzIGBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlYC5cbiAgaWYgKHN5bmNRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHN5bmNRdWV1ZSA9IFtjYWxsYmFja107XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuICAgIC8vIHdlIGFscmVhZHkgc2NoZWR1bGVkIG9uZSB3aGVuIHdlIGNyZWF0ZWQgdGhlIHF1ZXVlLlxuICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgc2NoZWR1bGVTeW5jQ2FsbGJhY2soY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpIHtcbiAgLy8gT25seSBmbHVzaGVzIHRoZSBxdWV1ZSBpZiB0aGVyZSdzIGEgbGVnYWN5IHN5bmMgY2FsbGJhY2sgc2NoZWR1bGVkLlxuICAvLyBUT0RPOiBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgdHlwZSBvZiBjYWxsYmFjazogcGVyZm9ybVN5bmNPbldvcmtPblJvb3QuIFNvXG4gIC8vIGl0IG1pZ2h0IG1ha2UgbW9yZSBzZW5zZSBmb3IgdGhlIHF1ZXVlIHRvIGJlIGEgbGlzdCBvZiByb290cyBpbnN0ZWFkIG9mIGFcbiAgLy8gbGlzdCBvZiBnZW5lcmljIGNhbGxiYWNrcy4gVGhlbiB3ZSBjYW4gaGF2ZSB0d286IG9uZSBmb3IgbGVnYWN5IHJvb3RzLCBvbmVcbiAgLy8gZm9yIGNvbmN1cnJlbnQgcm9vdHMuIEFuZCB0aGlzIG1ldGhvZCB3b3VsZCBvbmx5IGZsdXNoIHRoZSBsZWdhY3kgb25lcy5cbiAgaWYgKGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcykge1xuICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3MoKSB7XG4gIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmNlLlxuICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSB0cnVlO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc1N5bmMgPSB0cnVlO1xuICAgICAgdmFyIHF1ZXVlID0gc3luY1F1ZXVlOyAvLyBUT0RPOiBJcyB0aGlzIG5lY2Vzc2FyeSBhbnltb3JlPyBUaGUgb25seSB1c2VyIGNvZGUgdGhhdCBydW5zIGluIHRoaXNcbiAgICAgIC8vIHF1ZXVlIGlzIGluIHRoZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlcy5cblxuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG5cbiAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaXNTeW5jKTtcbiAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBzeW5jUXVldWUgPSBudWxsO1xuICAgICAgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHNvbWV0aGluZyB0aHJvd3MsIGxlYXZlIHRoZSByZW1haW5pbmcgY2FsbGJhY2tzIG9uIHRoZSBxdWV1ZS5cbiAgICAgIGlmIChzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgc3luY1F1ZXVlID0gc3luY1F1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgIH0gLy8gUmVzdW1lIGZsdXNoaW5nIGluIHRoZSBuZXh0IHRpY2tcblxuXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5LCBmbHVzaFN5bmNDYWxsYmFja3MpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZVByaW9yaXR5KTtcbiAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVGhpcyBpcyBpbXBvcnRlZCBieSB0aGUgZXZlbnQgcmVwbGF5aW5nIGltcGxlbWVudGF0aW9uIGluIFJlYWN0IERPTS4gSXQnc1xuLy8gaW4gYSBzZXBhcmF0ZSBmaWxlIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSByZW5kZXJlciBhbmRcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gaXNSb290RGVoeWRyYXRlZChyb290KSB7XG4gIHZhciBjdXJyZW50U3RhdGUgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG59XG5cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xudmFyIE5vVHJhbnNpdGlvbiA9IG51bGw7XG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iamVjdElzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtpXTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBjdXJyZW50S2V5KSB8fCAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICB2YXIgb3duZXIgPSAgZmliZXIuX2RlYnVnT3duZXIgPyBmaWJlci5fZGVidWdPd25lci50eXBlIDogbnVsbCA7XG4gIHZhciBzb3VyY2UgPSAgZmliZXIuX2RlYnVnU291cmNlIDtcblxuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICBkbyB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBjdXJyZW50ID0gbnVsbDtcbnZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG93bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cblxuXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgIGN1cnJlbnQgPSBudWxsO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICB7XG4gICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gIH1cbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXBlIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIGRvIGFuIGluaXRpYWwgcGFzcyB0byBnYXRoZXIgY29tcG9uZW50IG5hbWVzXG4gICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9IC8vIEZpbmFsbHksIHdlIGZsdXNoIGFsbCB0aGUgd2FybmluZ3NcbiAgICAvLyBVTlNBRkVfIG9uZXMgYmVmb3JlIHRoZSBkZXByZWNhdGVkIG9uZXMsIHNpbmNlIHRoZXknbGwgYmUgJ2xvdWRlcidcblxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIHNvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIFwiICsgJ3JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMyID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMik7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczMpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM0ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIFwiICsgJ2NvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kZXJpdmVkLXN0YXRlXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM0KTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzNSA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxVcGRhdGUgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgdmFyIHN0cmljdFJvb3QgPSBmaW5kU3RyaWN0Um9vdChmaWJlcik7XG5cbiAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuXG5cbiAgICBpZiAoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KTtcblxuICAgIGlmIChmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290ID0gW107XG4gICAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICAgIH1cblxuICAgICAgd2FybmluZ3NGb3JSb290LnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlckFycmF5LCBzdHJpY3RSb290KSB7XG4gICAgICBpZiAoZmliZXJBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF07XG4gICAgICB2YXIgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaXJzdEZpYmVyKTtcblxuICAgICAgICBlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJyArICdcXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyAnICsgJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2xlZ2FjeS1jb250ZXh0Jywgc29ydGVkTmFtZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gIH07XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIHByb3AgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xudmFyIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbmZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG5cbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlcik7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQsIHByb3ZpZGVyRmliZXIpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG5cbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAge1xuICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgLy8gVXBkYXRlIHRoZSBjaGlsZCBsYW5lcyBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nIHRoZSBhbHRlcm5hdGVzLlxuICB2YXIgbm9kZSA9IHBhcmVudDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcblxuICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBub2RlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmICFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChub2RlICE9PSBwcm9wYWdhdGlvblJvb3QpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcblxuICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7IC8vIFZpc2l0IHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBNYXRjaCEgU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoaXMgZmliZXIuXG4gICAgICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZm9yY2UgdXBkYXRlIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTsgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgLy8gSW5saW5lZCBgZW5xdWV1ZVVwZGF0ZWAgdG8gcmVtb3ZlIGludGVybGVhdmVkIHVwZGF0ZSBjaGVja1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICAgICAgICAgIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSBpZiAoIGZpYmVyLnRhZyA9PT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgaXMgaW4gdGhpcyBzdWJ0cmVlLCB3ZSBkb24ndCBrbm93XG4gICAgICAvLyBpZiBpdCB3aWxsIGhhdmUgYW55IGNvbnRleHQgY29uc3VtZXJzIGluIGl0LiBUaGUgYmVzdCB3ZSBjYW4gZG8gaXNcbiAgICAgIC8vIG1hcmsgaXQgYXMgaGF2aW5nIHVwZGF0ZXMuXG4gICAgICB2YXIgcGFyZW50U3VzcGVuc2UgPSBmaWJlci5yZXR1cm47XG5cbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudFN1c3BlbnNlLmxhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnRTdXNwZW5zZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIF9hbHRlcm5hdGUgPSBwYXJlbnRTdXNwZW5zZS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIF9hbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKF9hbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHBhc3NpbmcgdGhpcyBmaWJlciBhcyB0aGUgcGFyZW50XG4gICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gc2NoZWR1bGUgdGhpcyBmaWJlciBhcyBoYXZpbmcgd29ya1xuICAgICAgLy8gb24gaXRzIGNoaWxkcmVuLiBXZSdsbCB1c2UgdGhlIGNoaWxkTGFuZXMgb25cbiAgICAgIC8vIHRoaXMgZmliZXIgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cblxuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnRTdXNwZW5zZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuXG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuXG5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHZhciBmaXJzdENvbnRleHQgPSBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuXG4gICAgICBpZiAoZmlyc3RDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICAgICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICAgIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbHVlID0gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuXG4gIGlmIChsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPT09IGNvbnRleHQpIDsgZWxzZSB7XG4gICAgdmFyIGNvbnRleHRJdGVtID0ge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG1lbW9pemVkVmFsdWU6IHZhbHVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuXG5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0SXRlbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBBbiBhcnJheSBvZiBhbGwgdXBkYXRlIHF1ZXVlcyB0aGF0IHJlY2VpdmVkIHVwZGF0ZXMgZHVyaW5nIHRoZSBjdXJyZW50XG4vLyByZW5kZXIuIFdoZW4gdGhpcyByZW5kZXIgZXhpdHMsIGVpdGhlciBiZWNhdXNlIGl0IGZpbmlzaGVzIG9yIGJlY2F1c2UgaXQgaXNcbi8vIGludGVycnVwdGVkLCB0aGUgaW50ZXJsZWF2ZWQgdXBkYXRlcyB3aWxsIGJlIHRyYW5zZmVycmVkIG9udG8gdGhlIG1haW4gcGFydFxuLy8gb2YgdGhlIHF1ZXVlLlxudmFyIGludGVybGVhdmVkUXVldWVzID0gbnVsbDtcbmZ1bmN0aW9uIHB1c2hJbnRlcmxlYXZlZFF1ZXVlKHF1ZXVlKSB7XG4gIGlmIChpbnRlcmxlYXZlZFF1ZXVlcyA9PT0gbnVsbCkge1xuICAgIGludGVybGVhdmVkUXVldWVzID0gW3F1ZXVlXTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcmxlYXZlZFF1ZXVlcy5wdXNoKHF1ZXVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUludGVybGVhdmVkVXBkYXRlcygpIHtcbiAgLy8gVHJhbnNmZXIgdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgb250byB0aGUgbWFpbiBxdWV1ZS4gRWFjaCBxdWV1ZSBoYXMgYVxuICAvLyBgcGVuZGluZ2AgZmllbGQgYW5kIGFuIGBpbnRlcmxlYXZlZGAgZmllbGQuIFdoZW4gdGhleSBhcmUgbm90IG51bGwsIHRoZXlcbiAgLy8gcG9pbnQgdG8gdGhlIGxhc3Qgbm9kZSBpbiBhIGNpcmN1bGFyIGxpbmtlZCBsaXN0LiBXZSBuZWVkIHRvIGFwcGVuZCB0aGVcbiAgLy8gaW50ZXJsZWF2ZWQgbGlzdCB0byB0aGUgZW5kIG9mIHRoZSBwZW5kaW5nIGxpc3QgYnkgam9pbmluZyB0aGVtIGludG8gYVxuICAvLyBzaW5nbGUsIGNpcmN1bGFyIGxpc3QuXG4gIGlmIChpbnRlcmxlYXZlZFF1ZXVlcyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJsZWF2ZWRRdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZSA9IGludGVybGVhdmVkUXVldWVzW2ldO1xuICAgICAgdmFyIGxhc3RJbnRlcmxlYXZlZFVwZGF0ZSA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgICBpZiAobGFzdEludGVybGVhdmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmludGVybGVhdmVkID0gbnVsbDtcbiAgICAgICAgdmFyIGZpcnN0SW50ZXJsZWF2ZWRVcGRhdGUgPSBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dDtcbiAgICAgICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcXVldWUucGVuZGluZztcblxuICAgICAgICBpZiAobGFzdFBlbmRpbmdVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICAgICAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gZmlyc3RJbnRlcmxlYXZlZFVwZGF0ZTtcbiAgICAgICAgICBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBsYXN0SW50ZXJsZWF2ZWRVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW50ZXJsZWF2ZWRRdWV1ZXMgPSBudWxsO1xuICB9XG59XG5cbnZhciBVcGRhdGVTdGF0ZSA9IDA7XG52YXIgUmVwbGFjZVN0YXRlID0gMTtcbnZhciBGb3JjZVVwZGF0ZSA9IDI7XG52YXIgQ2FwdHVyZVVwZGF0ZSA9IDM7IC8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG52YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO1xuXG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDoge1xuICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgIGludGVybGVhdmVkOiBudWxsLFxuICAgICAgbGFuZXM6IE5vTGFuZXNcbiAgICB9LFxuICAgIGVmZmVjdHM6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgZXZlbnRUaW1lOiBldmVudFRpbWUsXG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG4gIGlmIChpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyKSkge1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IHNoYXJlZFF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG4gICAgICBwdXNoSW50ZXJsZWF2ZWRRdWV1ZShzaGFyZWRRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgc2hhcmVkUXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBlbmRpbmcgPSBzaGFyZWRRdWV1ZS5wZW5kaW5nO1xuXG4gICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB9XG5cbiAge1xuICAgIGlmIChjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHNoYXJlZFF1ZXVlICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICBlcnJvcignQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuXG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG5cbiAgaWYgKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpIHtcbiAgICB2YXIgcXVldWVMYW5lcyA9IHNoYXJlZFF1ZXVlLmxhbmVzOyAvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5IG11c3RcbiAgICAvLyBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaCByZXByZXNlbnRzXG4gICAgLy8gYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZSBtYXkgZW50YW5nbGVcbiAgICAvLyBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmIHdlICpkb24ndCpcbiAgICAvLyBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cblxuICAgIHF1ZXVlTGFuZXMgPSBpbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLCByb290LnBlbmRpbmdMYW5lcyk7IC8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG5cbiAgICB2YXIgbmV3UXVldWVMYW5lcyA9IG1lcmdlTGFuZXMocXVldWVMYW5lcywgbGFuZSk7XG4gICAgc2hhcmVkUXVldWUubGFuZXMgPSBuZXdRdWV1ZUxhbmVzOyAvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG4gICAgLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbiAgICAvLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxuXG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbmV3UXVldWVMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY2FwdHVyZWRVcGRhdGUpIHtcbiAgLy8gQ2FwdHVyZWQgdXBkYXRlcyBhcmUgdXBkYXRlcyB0aGF0IGFyZSB0aHJvd24gYnkgYSBjaGlsZCBkdXJpbmcgdGhlIHJlbmRlclxuICAvLyBwaGFzZS4gVGhleSBzaG91bGQgYmUgZGlzY2FyZGVkIGlmIHRoZSByZW5kZXIgaXMgYWJvcnRlZC4gVGhlcmVmb3JlLFxuICAvLyB3ZSBzaG91bGQgb25seSBwdXQgdGhlbSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgbm90IHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIENoZWNrIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGEgY2xvbmUuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAgIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlblxuICAgICAgLy8gd2UgYmFpbCBvdXQgb24gYSBwYXJlbnQgZmliZXIgdGhhdCB0aGVuIGNhcHR1cmVzIGFuIGVycm9yIHRocm93biBieVxuICAgICAgLy8gYSBjaGlsZC4gU2luY2Ugd2Ugd2FudCB0byBhcHBlbmQgdGhlIHVwZGF0ZSBvbmx5IHRvIHRoZSB3b3JrLWluXG4gICAgICAvLyAtcHJvZ3Jlc3MgcXVldWUsIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHVwZGF0ZXMuIFdlIHVzdWFsbHkgY2xvbmUgZHVyaW5nXG4gICAgICAvLyBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCB0aGF0IGRpZG4ndCBoYXBwZW4gaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2VcbiAgICAgIC8vIHNraXBwZWQgb3ZlciB0aGUgcGFyZW50IHdoZW4gd2UgYmFpbGVkIG91dC5cbiAgICAgIHZhciBuZXdGaXJzdCA9IG51bGw7XG4gICAgICB2YXIgbmV3TGFzdCA9IG51bGw7XG4gICAgICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgdXBkYXRlcyBhbmQgY2xvbmUgdGhlbS5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGUuZXZlbnRUaW1lLFxuICAgICAgICAgICAgbGFuZTogdXBkYXRlLmxhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2xvbmU7XG4gICAgICAgICAgICBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vIEFwcGVuZCB0aGUgY2FwdHVyZWQgdXBkYXRlIHRoZSBlbmQgb2YgdGhlIGNsb25lZCBsaXN0LlxuXG5cbiAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgICBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBubyBiYXNlIHVwZGF0ZXMuXG4gICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG5ld0ZpcnN0LFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgICBlZmZlY3RzOiBjdXJyZW50UXVldWUuZWZmZWN0c1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cblxuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gIH1cblxuICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcblxuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gICAgICAgIHJldHVybiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgcHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG4gIH1cblxuICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gSWYgc28sIHRyYW5zZmVyIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgdmFyIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7IC8vIFRoZSBwZW5kaW5nIHF1ZXVlIGlzIGNpcmN1bGFyLiBEaXNjb25uZWN0IHRoZSBwb2ludGVyIGJldHdlZW4gZmlyc3RcbiAgICAvLyBhbmQgbGFzdCBzbyB0aGF0IGl0J3Mgbm9uLWNpcmN1bGFyLlxuXG4gICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHZhciBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgIGxhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsOyAvLyBBcHBlbmQgcGVuZGluZyB1cGRhdGVzIHRvIGJhc2UgcXVldWVcblxuICAgIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH1cblxuICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7IC8vIElmIHRoZXJlJ3MgYSBjdXJyZW50IHF1ZXVlLCBhbmQgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgYmFzZSBxdWV1ZSwgdGhlblxuICAgIC8vIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlIHVwZGF0ZXMgdG8gdGhhdCBxdWV1ZSwgdG9vLiBCZWNhdXNlIHRoZSBiYXNlXG4gICAgLy8gcXVldWUgaXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgd2l0aCBubyBjeWNsZXMsIHdlIGNhbiBhcHBlbmQgdG8gYm90aFxuICAgIC8vIGxpc3RzIGFuZCB0YWtlIGFkdmFudGFnZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuXG4gICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnRcblxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgdmFyIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSAhPT0gbGFzdEJhc2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG5cblxuICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIHVwZGF0ZXMgdG8gY29tcHV0ZSB0aGUgcmVzdWx0LlxuICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTsgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmUgcmVuZGVyTGFuZXNcbiAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuICAgIHZhciBuZXdMYW5lcyA9IE5vTGFuZXM7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0xhc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSB1cGRhdGUubGFuZTtcbiAgICAgIHZhciB1cGRhdGVFdmVudFRpbWUgPSB1cGRhdGUuZXZlbnRUaW1lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGVFdmVudFRpbWUsXG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUgPSBjbG9uZTtcbiAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5cblxuICAgICAgICBuZXdMYW5lcyA9IG1lcmdlTGFuZXMobmV3TGFuZXMsIHVwZGF0ZUxhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZUV2ZW50VGltZSxcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4gICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBfY2xvbmU7XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIG5ld1N0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBuZXdTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuXG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCAmJiAvLyBJZiB0aGUgdXBkYXRlIHdhcyBhbHJlYWR5IGNvbW1pdHRlZCwgd2Ugc2hvdWxkIG5vdCBxdWV1ZSBpdHNcbiAgICAgICAgLy8gY2FsbGJhY2sgYWdhaW4uXG4gICAgICAgIHVwZGF0ZS5sYW5lICE9PSBOb0xhbmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDYWxsYmFjaztcbiAgICAgICAgICB2YXIgZWZmZWN0cyA9IHF1ZXVlLmVmZmVjdHM7XG5cbiAgICAgICAgICBpZiAoZWZmZWN0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUuZWZmZWN0cyA9IFt1cGRhdGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG5cbiAgICAgIGlmICh1cGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGEgcmVkdWNlci4gQWRkIHRoZSBuZXdcbiAgICAgICAgICAvLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxuICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2VcbiAgICAgICAgICAvLyB1bnJhdmVsIHRoZW0gd2hlbiB0cmFuc2ZlcnJpbmcgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICAgICAgICAgIHZhciBfZmlyc3RQZW5kaW5nVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZSA9IF9maXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBuZXdGaXJzdEJhc2VVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTsgLy8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuICAgIC8vIHByb2Nlc3MgdGhlbSBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCB3ZSBkbyBuZWVkIHRvIHRyYWNrIHdoaWNoIGxhbmVzXG4gICAgLy8gYXJlIHJlbWFpbmluZy5cblxuICAgIHZhciBsYXN0SW50ZXJsZWF2ZWQgPSBxdWV1ZS5zaGFyZWQuaW50ZXJsZWF2ZWQ7XG5cbiAgICBpZiAobGFzdEludGVybGVhdmVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJsZWF2ZWQgPSBsYXN0SW50ZXJsZWF2ZWQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmV3TGFuZXMgPSBtZXJnZUxhbmVzKG5ld0xhbmVzLCBpbnRlcmxlYXZlZC5sYW5lKTtcbiAgICAgICAgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuICAgICAgfSB3aGlsZSAoaW50ZXJsZWF2ZWQgIT09IGxhc3RJbnRlcmxlYXZlZCk7XG4gICAgfSBlbHNlIGlmIChmaXJzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAgcXVldWUuc2hhcmVkLmxhbmVzID0gTm9MYW5lcztcbiAgICB9IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cblxuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbmV3TGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkICcgKyAoXCJyZWNlaXZlZDogXCIgKyBjYWxsYmFjaykpO1xuICB9XG5cbiAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKSB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5mdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIGZpbmlzaGVkUXVldWUsIGluc3RhbmNlKSB7XG4gIC8vIENvbW1pdCB0aGUgZWZmZWN0c1xuICB2YXIgZWZmZWN0cyA9IGZpbmlzaGVkUXVldWUuZWZmZWN0cztcbiAgZmluaXNoZWRRdWV1ZS5lZmZlY3RzID0gbnVsbDtcblxuICBpZiAoZWZmZWN0cyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVmZmVjdCA9IGVmZmVjdHNbaV07XG4gICAgICB2YXIgY2FsbGJhY2sgPSBlZmZlY3QuY2FsbGJhY2s7XG5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBlZmZlY3QuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307IC8vIFJlYWN0LkNvbXBvbmVudCB1c2VzIGEgc2hhcmVkIGZyb3plbiBvYmplY3QgYnkgZGVmYXVsdC5cbi8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG5cbnZhciBlbXB0eVJlZnNPYmplY3QgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkucmVmcztcbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gY2FsbGVyTmFtZSArICdfJyArIGNhbGxiYWNrO1xuXG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcblxuICAgICAgZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgJyArICdtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgJyArICdhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyAnICsgXCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgXCIgKyAndG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggJyArICd0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXh0UHJvcHMpIHtcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7IC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFF1ZXVlIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgY2xhc3Nlc1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgdmFyIHJvb3QgPSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgKyAnVGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSB1bmRlZmluZWQgJiYgaGFzTXV0YXRlZFByb3BzKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGVycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3RvcikpIHtcbiAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7XG5cbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiAnICsgJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGNvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0ID0gaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cbiAge1xuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cblxuXG4gIGlmIChpc0xlZ2FjeUNvbnRleHRDb25zdW1lcikge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgIHtcbiAgICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgIH1cblxuICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBmaWJlckZsYWdzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG4gICAgICB7XG4gICAgICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBfZmliZXJGbGFncyB8PSBMYXlvdXRTdGF0aWM7XG4gICAgICB9XG5cbiAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICBfZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gX2ZpYmVyRmxhZ3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9maWJlckZsYWdzMiA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBfZmliZXJGbGFnczIgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX2ZpYmVyRmxhZ3MyIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgICAgfVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBfZmliZXJGbGFnczI7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyB1bnJlc29sdmVkT2xkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSAmJiAhKGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gICApKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkgfHwgLy8gVE9ETzogSW4gc29tZSBjYXNlcywgd2UnbGwgZW5kIHVwIGNoZWNraW5nIGlmIGNvbnRleHQgaGFzIGNoYW5nZWQgdHdpY2UsXG4gIC8vIGJvdGggYmVmb3JlIGFuZCBhZnRlciBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBoYXMgYmVlbiBjYWxsZWQuIE5vdCBpZGVhbCxcbiAgLy8gYnV0IEknbSBsb2F0aCB0byByZWZhY3RvciB0aGlzIGZ1bmN0aW9uLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgbWVtb2l6ZWRcbiAgLy8gY29tcG9uZW50cyBzbyBpdCdzIG5vdCB0aGF0IGNvbW1vbi5cbiAgZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiAgIDtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbi8vIFRPRE86IFVzZSB0aGUgdW5pZmllZCBmaWJlciBzdGFjayBtb2R1bGUgaW5zdGVhZCBvZiB0aGlzIGxvY2FsIG9uZT9cbi8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGl0IHlldCB0byBkZXJpc2sgdGhlIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIGJlY2F1c2Vcbi8vIHRoZSB3YXkgd2UgcHVzaC9wb3AgdGhlc2UgdmFsdWVzIGlzIGEgYml0IHVudXN1YWwuIElmIHRoZXJlJ3MgYSBtaXN0YWtlLCBJJ2Rcbi8vIHJhdGhlciB0aGUgaWRzIGJlIHdyb25nIHRoYW4gY3Jhc2ggdGhlIHdob2xlIHJlY29uY2lsZXIuXG52YXIgZm9ya1N0YWNrID0gW107XG52YXIgZm9ya1N0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVGb3JrQ291bnQgPSAwO1xudmFyIGlkU3RhY2sgPSBbXTtcbnZhciBpZFN0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVDb250ZXh0SWQgPSAxO1xudmFyIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSAnJztcbmZ1bmN0aW9uIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JrZWQpICE9PSBOb0ZsYWdzO1xufVxuZnVuY3Rpb24gZ2V0Rm9ya3NBdExldmVsKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICByZXR1cm4gdHJlZUZvcmtDb3VudDtcbn1cbmZ1bmN0aW9uIGdldFRyZWVJZCgpIHtcbiAgdmFyIG92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciB3ZSByZWNvbmNpbGUgYW4gYXJyYXkgKG9yIGl0ZXJhdG9yKSBvZiBjaGlsZFxuICAvLyBmaWJlcnMsIGJlY2F1c2UgdGhhdCdzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHdlIGtub3cgaG93IG1hbnkgY2hpbGRyZW4gaW5cbiAgLy8gdGhlIHdob2xlIHNldCB3aXRob3V0IGRvaW5nIGV4dHJhIHdvcmsgbGF0ZXIsIG9yIHN0b3JpbmcgYWRkdGlvbmFsXG4gIC8vIGluZm9ybWF0aW9uIG9uIHRoZSBmaWJlci5cbiAgLy9cbiAgLy8gVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGlzIHNlcGFyYXRlIGZyb20gcHVzaFRyZWVJZCDigJQgaXQncyBjYWxsZWQgZHVyaW5nXG4gIC8vIHRoZSByZW5kZXIgcGhhc2Ugb2YgdGhlIGZvcmsgcGFyZW50LCBub3QgdGhlIGNoaWxkLCB3aGljaCBpcyB3aGVyZSB3ZSBwdXNoXG4gIC8vIHRoZSBvdGhlciBjb250ZXh0IHZhbHVlcy5cbiAgLy9cbiAgLy8gSW4gdGhlIEZpenogaW1wbGVtZW50YXRpb24gdGhpcyBpcyBtdWNoIHNpbXBsZXIgYmVjYXVzZSB0aGUgY2hpbGQgaXNcbiAgLy8gcmVuZGVyZWQgaW4gdGhlIHNhbWUgY2FsbHN0YWNrIGFzIHRoZSBwYXJlbnQuXG4gIC8vXG4gIC8vIEl0IG1pZ2h0IGJlIGJldHRlciB0byBqdXN0IGFkZCBhIGBmb3Jrc2AgZmllbGQgdG8gdGhlIEZpYmVyIHR5cGUuIEl0IHdvdWxkXG4gIC8vIG1ha2UgdGhpcyBtb2R1bGUgc2ltcGxlci5cbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrQ291bnQ7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdHJlZUZvcmtDb3VudCA9IHRvdGFsQ2hpbGRyZW47XG59XG5mdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgYmFzZU92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IHJlc3RPZkxlbmd0aCB8IGlkO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3JtYWwgcGF0aFxuICAgIHZhciBuZXdCaXRzID0gc2xvdCA8PCBiYXNlTGVuZ3RoO1xuXG4gICAgdmFyIF9pZCA9IG5ld0JpdHMgfCBiYXNlSWQ7XG5cbiAgICB2YXIgX292ZXJmbG93ID0gYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IGxlbmd0aCB8IF9pZDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gX292ZXJmbG93O1xuICB9XG59XG5mdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpOyAvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFRoaXMgd2lsbCBhZmZlY3QgYW55IGlkcyB0aGF0IGFwcGVhclxuICAvLyBpbiBpdHMgY2hpbGRyZW4uXG5cbiAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBudW1iZXJPZkZvcmtzID0gMTtcbiAgICB2YXIgc2xvdEluZGV4ID0gMDtcbiAgICBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MpO1xuICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MsIHNsb3RJbmRleCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufVxuXG5mdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZXMuXG4gIC8vIFRoaXMgaXMgYSBiaXQgbW9yZSBjb21wbGljYXRlZCB0aGFuIG90aGVyIGNvbnRleHQtbGlrZSBtb2R1bGVzIGluIEZpYmVyXG4gIC8vIGJlY2F1c2UgdGhlIHNhbWUgRmliZXIgbWF5IGFwcGVhciBvbiB0aGUgc3RhY2sgbXVsdGlwbGUgdGltZXMgYW5kIGZvclxuICAvLyBkaWZmZXJlbnQgcmVhc29ucy4gV2UgaGF2ZSB0byBrZWVwIHBvcHBpbmcgdW50aWwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaXNcbiAgLy8gbm8gbG9uZ2VyIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVGb3JrUHJvdmlkZXIpIHtcbiAgICB0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO1xuICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVGb3JrQ291bnQgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG4gICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGw7XG4gIH1cblxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXIpIHtcbiAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dElkID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuXG4gIGlmICh0cmVlQ29udGV4dFByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0cmVlQ29udGV4dElkLFxuICAgICAgb3ZlcmZsb3c6IHRyZWVDb250ZXh0T3ZlcmZsb3dcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbmRlZENvbnRleHQpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0SWQgPSBzdXNwZW5kZWRDb250ZXh0LmlkO1xuICB0cmVlQ29udGV4dE92ZXJmbG93ID0gc3VzcGVuZGVkQ29udGV4dC5vdmVyZmxvdztcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKSB7XG4gIHtcbiAgICBpZiAoIWdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlICcgKyAnYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG52YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbnZhciBkaWRTdXNwZW5kID0gZmFsc2U7IC8vIEh5ZHJhdGlvbiBlcnJvcnMgdGhhdCB3ZXJlIHRocm93biBpbnNpZGUgdGhpcyBib3VuZGFyeVxuXG52YXIgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcblxuZnVuY3Rpb24gd2FybklmSHlkcmF0aW5nKCkge1xuICB7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICBlcnJvcignV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtEaWRTdXNwZW5kV2hpbGVIeWRyYXRpbmdERVYoKSB7XG4gIHtcbiAgICBkaWRTdXNwZW5kID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICBkaWRTdXNwZW5kID0gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIsIHN1c3BlbnNlSW5zdGFuY2UsIHRyZWVDb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmQgPSBmYWxzZTtcblxuICBpZiAodHJlZUNvbnRleHQgIT09IG51bGwpIHtcbiAgICByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQoZmliZXIsIHRyZWVDb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHJldHVybkZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGlmIChzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHdhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKTtcbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV07XG4gICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAge1xuICAgIGlmIChkaWRTdXNwZW5kKSB7XG4gICAgICAvLyBJbnNpZGUgYSBib3VuZGFyeSB0aGF0IGFscmVhZHkgc3VzcGVuZGVkLiBXZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHRoZVxuICAgICAgLy8gc2libGluZ3Mgb2YgYSBzdXNwZW5kZWQgbm9kZS4gVGhlIG1pc21hdGNoIG1heSBiZSBkdWUgdG8gdGhlIG1pc3NpbmdcbiAgICAgIC8vIGRhdGEsIHNvIGl0J3MgcHJvYmFibHkgYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIF9wcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSByZXR1cm5GaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgICAgICAgaWYgKF9wYXJlbnRJbnN0YW5jZSAhPT0gbnVsbCkgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlMiA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHMyID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UsIF90eXBlMiwgX3Byb3BzMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgX3RleHQyID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UoX3BhcmVudEluc3RhbmNlLCBfdGV4dDIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcikge1xuICBmaWJlci5mbGFncyA9IGZpYmVyLmZsYWdzICYgfkh5ZHJhdGluZyB8IFBsYWNlbWVudDtcbiAgd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuXG4gICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjsgLy8gVGV4dCBJbnN0YW5jZXMgZG9uJ3QgaGF2ZSBjaGlsZHJlbiBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gaHlkcmF0ZS5cblxuICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dEluc3RhbmNlKTtcblxuICAgICAgICAgIGlmIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgZGVoeWRyYXRlZDogc3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgICAgICAgICAgdHJlZUNvbnRleHQ6IGdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCksXG4gICAgICAgICAgICAgIHJldHJ5TGFuZTogT2Zmc2NyZWVuTGFuZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBzdXNwZW5zZVN0YXRlOyAvLyBTdG9yZSB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudCBhcyBhIGNoaWxkIGZpYmVyLlxuICAgICAgICAgICAgLy8gVGhpcyBzaW1wbGlmaWVzIHRoZSBjb2RlIGZvciBnZXRIb3N0U2libGluZyBhbmQgZGVsZXRpbmcgbm9kZXMsXG4gICAgICAgICAgICAvLyBzaW5jZSBpdCBkb2Vzbid0IGhhdmUgdG8gY29uc2lkZXIgYWxsIFN1c3BlbnNlIGJvdW5kYXJpZXMgYW5kXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGV5J3JlIGRlaHlkcmF0ZWQgb25lcyBvciBub3QuXG5cbiAgICAgICAgICAgIHZhciBkZWh5ZHJhdGVkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgICAgICBkZWh5ZHJhdGVkRnJhZ21lbnQucmV0dXJuID0gZmliZXI7XG4gICAgICAgICAgICBmaWJlci5jaGlsZCA9IGRlaHlkcmF0ZWRGcmFnbWVudDtcbiAgICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFdoaWxlIGEgU3VzcGVuc2UgSW5zdGFuY2UgZG9lcyBoYXZlIGNoaWxkcmVuLCB3ZSB3b24ndCBzdGVwIGludG9cbiAgICAgICAgICAgIC8vIGl0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSW5zdGVhZCwgd2UnbGwgcmVlbnRlciBpdCBsYXRlci5cblxuICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpIHtcbiAgcmV0dXJuICAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlICYmIChmaWJlci5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgJyArICdyZW5kZXJlZCBvbiB0aGUgc2VydmVyLicpO1xufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgaWYgKCFuZXh0SW5zdGFuY2UpIHtcbiAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcbiAgICAgIHdhcm5Ob25oeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTtcbiAgICB9IC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG5cblxuICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UgPSBuZXh0SW5zdGFuY2U7XG5cbiAgaWYgKCF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgaWYgKHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpKSB7XG4gICAgICB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKCk7XG4gICAgfSAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuXG5cbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gICAgdmFyIHByZXZIeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuXG4gICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZDtcbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyLCBzaG91bGRXYXJuSWZNaXNtYXRjaERldik7IC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuXG4gIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZDtcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIsIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKHJldHVybkZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcblxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbiAgICAgICAgICAgIGlzQ29uY3VycmVudE1vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG4gICAgICAgICAgICBpc0NvbmN1cnJlbnRNb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgLy8gc2lkZSBvZiB0aGVtLiBXZSBhbHNvIGRvbid0IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgdGhlIHJvb3QgY29udGFpbmVyLlxuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QgJiYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICBpZiAobmV4dEluc3RhbmNlKSB7XG4gICAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcbiAgICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcik7XG4gICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpO1xuICB9IGVsc2Uge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXNVbmh5ZHJhdGVkVGFpbE5vZGVzKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmcgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcikge1xuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgd2FyblVuaHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgZGlkU3VzcGVuZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyAhPT0gbnVsbCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgYSBmb3JjZWQgY2xpZW50IHJlbmRlci4gVGhlIGVycm9ycyB0aGF0IG9jY3VycmVkXG4gICAgLy8gZHVyaW5nIHRoZSBoeWRyYXRpb24gYXR0ZW1wdCBhcmUgbm93IHJlY292ZXJlZC4gV2Ugd2lsbCBsb2cgdGhlbSBpblxuICAgIC8vIGNvbW1pdCBwaGFzZSwgb25jZSB0aGUgZW50aXJlIHRyZWUgaGFzIGZpbmlzaGVkLlxuICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKTtcbiAgICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldElzSHlkcmF0aW5nKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmc7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyA9PT0gbnVsbCkge1xuICAgIGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnM7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7XG52YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nO1xuXG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7fTtcblxue1xuICBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5fc3RvcmUgfHwgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQuX3N0b3JlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCkge1xuICB2YXIgbWl4ZWRSZWYgPSBlbGVtZW50LnJlZjtcblxuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICAvLyBUT0RPOiBDbGVhbiB0aGlzIHVwIG9uY2Ugd2UgdHVybiBvbiB0aGUgc3RyaW5nIHJlZiB3YXJuaW5nIGZvclxuICAgICAgLy8gZXZlcnlvbmUsIGJlY2F1c2UgdGhlIHN0cmljdCBtb2RlIGNhc2Ugd2lsbCBubyBsb25nZXIgYmUgcmVsZXZhbnRcbiAgICAgIGlmICgocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgfHwgd2FybkFib3V0U3RyaW5nUmVmcykgJiYgLy8gV2Ugd2FybiBpbiBSZWFjdEVsZW1lbnQuanMgaWYgb3duZXIgYW5kIHNlbGYgYXJlIGVxdWFsIGZvciBzdHJpbmcgcmVmc1xuICAgICAgLy8gYmVjYXVzZSB0aGVzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb25cbiAgICAgIC8vIHVzaW5nIGEgY29kZW1vZC4gVGhlcmVmb3JlLCB3ZSBkb24ndCBoYXZlIHRvIHdhcm4gYWJvdXQgc3RyaW5nIHJlZnMgYWdhaW4uXG4gICAgICAhKGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX3NlbGYgJiYgZWxlbWVudC5fb3duZXIuc3RhdGVOb2RlICE9PSBlbGVtZW50Ll9zZWxmKSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCdBIHN0cmluZyByZWYsIFwiJXNcIiwgaGFzIGJlZW4gZm91bmQgd2l0aGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdTdHJpbmcgcmVmcyBhcmUgYSBzb3VyY2Ugb2YgcG90ZW50aWFsIGJ1Z3MgYW5kIHNob3VsZCBiZSBhdm9pZGVkLiAnICsgJ1dlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIG1peGVkUmVmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdDtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG5cbiAgICAgICAgaWYgKG93bmVyRmliZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSBzdHJpbmcgcmVmcy4gJyArICdXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbnN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIgKyBtaXhlZFJlZiArIFwiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBcIiArICdidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0IHNvIEZsb3cga25vd3MgaXQgd29uJ3QgY2hhbmdlIGluIHRoZSBjbG9zdXJlXG5cblxuICAgICAgdmFyIHJlc29sdmVkSW5zdCA9IGluc3Q7XG5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tQcm9wU3RyaW5nQ29lcmNpb24obWl4ZWRSZWYsICdyZWYnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7IC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudC5yZWYgPT09ICdmdW5jdGlvbicgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IHJlc29sdmVkSW5zdC5yZWZzO1xuXG4gICAgICAgIGlmIChyZWZzID09PSBlbXB0eVJlZnNPYmplY3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbGF6eSBwb29sZWQgZnJvemVuIG9iamVjdCwgc28gd2UgbmVlZCB0byBpbml0aWFsaXplLlxuICAgICAgICAgIHJlZnMgPSByZXNvbHZlZEluc3QucmVmcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG1peGVkUmVmICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhIHN0cmluZywgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciBudWxsLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKFwiICsgbWl4ZWRSZWYgKyBcIikgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2ZcIiArICcgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbiBjb21wb25lbnRcXG4nICsgXCIyLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnQncyByZW5kZXIgbWV0aG9kXFxuXCIgKyAnMy4gWW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgdmFyIGNoaWxkU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZFN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRTdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxhenkobGF6eVR5cGUpIHtcbiAgdmFyIHBheWxvYWQgPSBsYXp5VHlwZS5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5VHlwZS5faW5pdDtcbiAgcmV0dXJuIGluaXQocGF5bG9hZCk7XG59IC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5cblxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcblxuICAgIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXTtcbiAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cblxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICAvLyBpbnN0ZWFkLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIER1cmluZyBoeWRyYXRpb24sIHRoZSB1c2VJZCBhbGdvcml0aG0gbmVlZHMgdG8ga25vdyB3aGljaCBmaWJlcnMgYXJlXG4gICAgICAvLyBwYXJ0IG9mIGEgbGlzdCBvZiBjaGlsZHJlbiAoYXJyYXlzLCBpdGVyYXRvcnMpLlxuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gRm9ya2VkO1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuXG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQsIGxhbmVzKSB7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIGxhbmVzLCBlbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSApIHx8IC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuICAgICAgLy8gYmVjYXVzZSBob3QgcmVsb2FkaW5nIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gcHJvZCBiZWNhdXNlXG4gICAgICAvLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG4gICAgICAgdHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCAmJiBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmIHJlc29sdmVMYXp5KGVsZW1lbnRUeXBlKSA9PT0gY3VycmVudC50eXBlKSB7XG4gICAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIF9jcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZDIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIG51bGwpO1xuXG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicsIGtleSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBjaGlsZC5faW5pdDtcbiAgICAgICAgICAgIHdhcm5PbkludmFsaWRLZXkoaW5pdChwYXlsb2FkKSwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgICAgaWYgKF9uZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgdmFyIF9udW1iZXJPZkZvcmtzMiA9IG5ld0lkeDtcbiAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBsYW5lcykge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCB0b1N0cmluZ1RhZ1xuICAgICAgbmV3Q2hpbGRyZW5JdGVyYWJsZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnR2VuZXJhdG9yJykge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICAgIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9IC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuXG5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKG5ld0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgX251bWJlck9mRm9ya3MzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzMyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczQgPSBuZXdJZHg7XG4gICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG5cblxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCkge1xuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHwgKCAvLyBLZWVwIHRoaXMgY2hlY2sgaW5saW5lIHNvIGl0IG9ubHkgcnVucyBvbiB0aGUgZmFsc2UgcGF0aDpcbiAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLCBlbGVtZW50KSApIHx8IC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBhZnRlciB0aGUgSG90IFJlbG9hZGluZyBjaGVjayBhYm92ZSxcbiAgICAgICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2VcbiAgICAgICAgICAvLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG4gICAgICAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGNoaWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcblxuICAgICAgICAgICAgdmFyIF9leGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnByb3BzKTtcblxuICAgICAgICAgICAgX2V4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgX2V4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEaWRuJ3QgbWF0Y2guXG5cblxuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgX2NyZWF0ZWQ0LnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH0gLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuXG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWN1cnNpdmUuXG4gICAgLy8gSWYgdGhlIHRvcCBsZXZlbCBpdGVtIGlzIGFuIGFycmF5LCB3ZSB0cmVhdCBpdCBhcyBhIHNldCBvZiBjaGlsZHJlbixcbiAgICAvLyBub3QgYXMgYSBmcmFnbWVudC4gTmVzdGVkIGFycmF5cyBvbiB0aGUgb3RoZXIgaGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBmcmFnbWVudCBub2Rlcy4gUmVjdXJzaW9uIGhhcHBlbnMgYXQgdGhlIG5vcm1hbCBmbG93LlxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICB2YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGw7XG5cbiAgICBpZiAoaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9IC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcblxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7IC8vIFRPRE86IFRoaXMgZnVuY3Rpb24gaXMgc3VwcG9zZWQgdG8gYmUgbm9uLXJlY3Vyc2l2ZS5cblxuICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gICAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn0gLy8gUmVzZXQgYSB3b3JrSW5Qcm9ncmVzcyBjaGlsZCBzZXQgdG8gcHJlcGFyZSBpdCBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyhjaGlsZCwgbGFuZXMpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xudmFyIGNvbnRleHRTdGFja0N1cnNvciQxID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG5mdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICBpZiAoYyA9PT0gTk9fQ09OVEVYVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7IC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgTk9fQ09OVEVYVCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUsIHJvb3RJbnN0YW5jZSk7IC8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuXG4gIGlmIChjb250ZXh0ID09PSBuZXh0Q29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxudmFyIERlZmF1bHRTdXNwZW5zZUNvbnRleHQgPSAwOyAvLyBUaGUgU3VzcGVuc2UgQ29udGV4dCBpcyBzcGxpdCBpbnRvIHR3byBwYXJ0cy4gVGhlIGxvd2VyIGJpdHMgaXNcbi8vIGluaGVyaXRlZCBkZWVwbHkgZG93biB0aGUgc3VidHJlZS4gVGhlIHVwcGVyIGJpdHMgb25seSBhZmZlY3Rcbi8vIHRoaXMgaW1tZWRpYXRlIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBnZXRzIHJlc2V0IGVhY2ggbmV3XG4vLyBib3VuZGFyeSBvciBzdXNwZW5zZSBsaXN0LlxuXG52YXIgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgPSAxOyAvLyBTdWJ0cmVlIEZsYWdzOlxuLy8gSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0IGluZGljYXRlcyB0aGF0IG9uZSBvZiBvdXIgcGFyZW50IFN1c3BlbnNlXG4vLyBib3VuZGFyaWVzIGlzIG5vdCBjdXJyZW50bHkgc2hvd2luZyB2aXNpYmxlIG1haW4gY29udGVudC5cbi8vIEVpdGhlciBiZWNhdXNlIGl0IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIG9yIGlzIG5vdCBtb3VudGVkIGF0IGFsbC5cbi8vIFdlIGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgaXQgaXMgZGVzaXJhYmxlIHRvIHRyaWdnZXIgYSBmYWxsYmFjayBhdFxuLy8gdGhlIHBhcmVudC4gSWYgbm90LCB0aGVuIHdlIG1pZ2h0IG5lZWQgdG8gdHJpZ2dlciB1bmRlc2lyYWJsZSBib3VuZGFyaWVzXG4vLyBhbmQvb3Igc3VzcGVuZCB0aGUgY29tbWl0IHRvIGF2b2lkIGhpZGluZyB0aGUgcGFyZW50IGNvbnRlbnQuXG5cbnZhciBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgPSAxOyAvLyBTaGFsbG93IEZsYWdzOlxuLy8gRm9yY2VTdXNwZW5zZUZhbGxiYWNrIGNhbiBiZSB1c2VkIGJ5IFN1c3BlbnNlTGlzdCB0byBmb3JjZSBuZXdseSBhZGRlZFxuLy8gaXRlbXMgaW50byB0aGVpciBmYWxsYmFjayBzdGF0ZSBkdXJpbmcgb25lIG9mIHRoZSByZW5kZXIgcGFzc2VzLlxuXG52YXIgRm9yY2VTdXNwZW5zZUZhbGxiYWNrID0gMjtcbnZhciBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKERlZmF1bHRTdXNwZW5zZUNvbnRleHQpO1xuZnVuY3Rpb24gaGFzU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIGZsYWcpIHtcbiAgcmV0dXJuIChwYXJlbnRDb250ZXh0ICYgZmxhZykgIT09IDA7XG59XG5mdW5jdGlvbiBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG59XG5mdW5jdGlvbiBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIHNoYWxsb3dDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgfCBzaGFsbG93Q29udGV4dDtcbn1cbmZ1bmN0aW9uIGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc3VidHJlZUNvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgfCBzdWJ0cmVlQ29udGV4dDtcbn1cbmZ1bmN0aW9uIHB1c2hTdXNwZW5zZUNvbnRleHQoZmliZXIsIG5ld0NvbnRleHQpIHtcbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXdDb250ZXh0LCBmaWJlcik7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUNvbnRleHQoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKHdvcmtJblByb2dyZXNzLCBoYXNJbnZpc2libGVQYXJlbnQpIHtcbiAgLy8gSWYgaXQgd2FzIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHRoYXQganVzdCBzdXNwZW5kZWQsIGNhcHR1cmUgYW5kIHJlbmRlciB0aGVcbiAgLy8gZmFsbGJhY2suIE90aGVyd2lzZSwgZG9uJ3QgY2FwdHVyZSBhbmQgYnViYmxlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobmV4dFN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5leHRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGRlaHlkcmF0ZWQgYm91bmRhcnkgYWx3YXlzIGNhcHR1cmVzLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczsgLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG4gIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYm91bmRhcnkgd2Ugc2hvdWxkIGF2b2lkLCB0aGVuIHdlIHByZWZlciB0byBidWJibGUgdXAgdG8gdGhlXG59XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgICovXG4wOyAvLyBSZXByZXNlbnRzIHdoZXRoZXIgZWZmZWN0IHNob3VsZCBmaXJlLlxuXG52YXIgSGFzRWZmZWN0ID1cbi8qICovXG4xOyAvLyBSZXByZXNlbnRzIHRoZSBwaGFzZSBpbiB3aGljaCB0aGUgZWZmZWN0IChub3QgdGhlIGNsZWFuLXVwKSBmaXJlcy5cblxudmFyIEluc2VydGlvbiA9XG4vKiAgKi9cbjI7XG52YXIgTGF5b3V0ID1cbi8qICAgICovXG40O1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICovXG44O1xuXG4vLyBhbmQgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyByZW5kZXIuXG4vLyBUaGlzIHRyYWNrcyB3aGljaCBtdXRhYmxlIHNvdXJjZXMgbmVlZCB0byBiZSByZXNldCBhZnRlciBhIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzU291cmNlcyA9IFtdO1xuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtdXRhYmxlU291cmNlID0gd29ya0luUHJvZ3Jlc3NTb3VyY2VzW2ldO1xuXG4gICAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgICBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uU2Vjb25kYXJ5ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoID0gMDtcbn1cbi8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSB2ZXJzaW9uIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcgbWF0Y2hlcyB0aGUgb25lXG4vLyB0aGF0IGlzIGV2ZW50dWFsbHkgcmVhZCBkdXJpbmcgaHlkcmF0aW9uLlxuLy8gSWYgdGhleSBkb24ndCBtYXRjaCB0aGVyZSdzIGEgcG90ZW50aWFsIHRlYXIgYW5kIGEgZnVsbCBkZW9wdCByZW5kZXIgaXMgcmVxdWlyZWQuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LCBtdXRhYmxlU291cmNlKSB7XG4gIHZhciBnZXRWZXJzaW9uID0gbXV0YWJsZVNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKG11dGFibGVTb3VyY2UuX3NvdXJjZSk7IC8vIFRPRE8gQ2xlYXIgdGhpcyBkYXRhIG9uY2UgYWxsIHBlbmRpbmcgaHlkcmF0aW9uIHdvcmsgaXMgZmluaXNoZWQuXG4gIC8vIFJldGFpbmluZyBpdCBmb3JldmVyIG1heSBpbnRlcmZlcmUgd2l0aCBHQy5cblxuICBpZiAocm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID09IG51bGwpIHtcbiAgICByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSBbbXV0YWJsZVNvdXJjZSwgdmVyc2lvbl07XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2gobXV0YWJsZVNvdXJjZSwgdmVyc2lvbik7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xudmFyIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDtcblxue1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50LlxuXG52YXIgbG9jYWxJZENvdW50ZXIgPSAwOyAvLyBVc2VkIGZvciBpZHMgdGhhdCBhcmUgZ2VuZXJhdGVkIGNvbXBsZXRlbHkgY2xpZW50LXNpZGUgKGkuZS4gbm90IGR1cmluZ1xuLy8gaHlkcmF0aW9uKS4gVGhpcyBjb3VudGVyIGlzIGdsb2JhbCwgc28gY2xpZW50IGlkcyBhcmUgbm90IHN0YWJsZSBhY3Jvc3Ncbi8vIHJlbmRlciBhdHRlbXB0cy5cblxudmFyIGdsb2JhbENsaWVudElkQ291bnRlciA9IDA7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsOyAvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxuXG52YXIgaG9va1R5cGVzRGV2ID0gbnVsbDtcbnZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpIHtcbiAgICAgICAgd2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gIHtcbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIWlzQXJyYXkoZGVwcykpIHtcbiAgICAgIC8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cbiAgICBpZiAoIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gJyc7XG4gICAgICAgIHZhciBzZWNvbmRDb2x1bW5TdGFydCA9IDMwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2OyBpKyspIHtcbiAgICAgICAgICB2YXIgb2xkSG9va05hbWUgPSBob29rVHlwZXNEZXZbaV07XG4gICAgICAgICAgdmFyIG5ld0hvb2tOYW1lID0gaSA9PT0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPyBjdXJyZW50SG9va05hbWUgOiBvbGRIb29rTmFtZTtcbiAgICAgICAgICB2YXIgcm93ID0gaSArIDEgKyBcIi4gXCIgKyBvbGRIb29rTmFtZTsgLy8gRXh0cmEgc3BhY2Ugc28gc2Vjb25kIGNvbHVtbiBsaW5lcyB1cFxuICAgICAgICAgIC8vIGxvbCBAIElFIG5vdCBzdXBwb3J0aW5nIFN0cmluZyNyZXBlYXRcblxuICAgICAgICAgIHdoaWxlIChyb3cubGVuZ3RoIDwgc2Vjb25kQ29sdW1uU3RhcnQpIHtcbiAgICAgICAgICAgIHJvdyArPSAnICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ICs9IG5ld0hvb2tOYW1lICsgJ1xcbic7XG4gICAgICAgICAgdGFibGUgKz0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJ1JlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiAnICsgJ1RoaXMgd2lsbCBsZWFkIHRvIGJ1Z3MgYW5kIGVycm9ycyBpZiBub3QgZml4ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlIFJ1bGVzIG9mIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3NcXG5cXG4nICsgJyAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuJyArICcgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nICsgJyVzJyArICcgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG4nLCBjb21wb25lbnROYW1lLCB0YWJsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAge1xuICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykge1xuICAgICAgLy8gT25seSB0cnVlIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYmVpbmcgaG90IHJlbG9hZGVkLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArICd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcgKyAnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJywgY3VycmVudEhvb2tOYW1lSW5EZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZywgbmV4dFJlbmRlckxhbmVzKSB7XG4gIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gVXNlZCBmb3IgaG90IHJlbG9hZGluZzpcblxuICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4gIC8vIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBsb2NhbElkQ291bnRlciA9IDA7XG4gIC8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbiAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4gIC8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4gIC8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4gIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbiAgLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG5cbiAge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbiAgICAvLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbiAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG4gICAgICBsb2NhbElkQ291bnRlciA9IDA7XG5cbiAgICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJyArICdhbiBpbmZpbml0ZSBsb29wLicpO1xuICAgICAgfVxuXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAgICB7XG4gICAgICAgIC8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuICAgICAgfSAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG5cbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIH1cblxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIDtcbiAgICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gIH0gLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG5cblxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuICAvLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cblxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gQ29uZmlybSB0aGF0IGEgc3RhdGljIGZsYWcgd2FzIG5vdCBhZGRlZCBvciByZW1vdmVkIHNpbmNlIHRoZSBsYXN0XG4gICAgLy8gcmVuZGVyLiBJZiB0aGlzIGZpcmVzLCBpdCBzdWdnZXN0cyB0aGF0IHdlIGluY29ycmVjdGx5IHJlc2V0IHRoZSBzdGF0aWNcbiAgICAvLyBmbGFncyBpbiBzb21lIG90aGVyIHBhcnQgb2YgdGhlIGNvZGViYXNlLiBUaGlzIGhhcyBoYXBwZW5lZCBiZWZvcmUsIGZvclxuICAgIC8vIGV4YW1wbGUsIGluIHRoZSBTdXNwZW5zZUxpc3QgaW1wbGVtZW50YXRpb24uXG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAoY3VycmVudC5mbGFncyAmIFN0YXRpY01hc2spICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBTdGF0aWNNYXNrKSAmJiAvLyBEaXNhYmxlIHRoaXMgd2FybmluZyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBsZWdhY3kgU3VzcGVuc2UgaXMgd2VpcmRcbiAgICAvLyBhbmQgY3JlYXRlcyBmYWxzZSBwb3NpdGl2ZXMuIFRvIG1ha2UgdGhpcyB3b3JrIGluIGxlZ2FjeSBtb2RlLCB3ZSdkXG4gICAgLy8gbmVlZCB0byBtYXJrIGZpYmVycyB0aGF0IGNvbW1pdCBpbiBhbiBpbmNvbXBsZXRlIHN0YXRlLCBzb21laG93LiBGb3JcbiAgICAvLyBub3cgSSdsbCBkaXNhYmxlIHRoZSB3YXJuaW5nIHRoYXQgbW9zdCBvZiB0aGUgYnVncyB0aGF0IHdvdWxkIHRyaWdnZXJcbiAgICAvLyBpdCBhcmUgZWl0aGVyIGV4Y2x1c2l2ZSB0byBjb25jdXJyZW50IG1vZGUgb3IgZXhpc3QgaW4gYm90aC5cbiAgICAoY3VycmVudC5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSAnICsgJ25vdGlmeSB0aGUgUmVhY3QgdGVhbS4nKTtcbiAgICB9XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgaXMgcmVzZXQgYnkgY2hlY2tEaWRSZW5kZXJJZEhvb2tcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuXG4gIGlmIChkaWRSZW5kZXJUb29GZXdIb29rcykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgJyArICdlYXJseSByZXR1cm4gc3RhdGVtZW50LicpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSByZW5kZXJXaXRoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiByZW5kZXJXaXRoSG9va3M7IGl0J3Mgb25seSBhXG4gIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuICB2YXIgZGlkUmVuZGVySWRIb29rID0gbG9jYWxJZENvdW50ZXIgIT09IDA7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBmbGFncyBoZXJlLCBiZWNhdXNlIHRoZXkncmUgcmVzZXQgaW4gdGhlXG4gIC8vIGNvbXBsZXRlIHBoYXNlIChidWJibGVQcm9wZXJ0aWVzKS5cblxuICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KE1vdW50UGFzc2l2ZURldiB8IE1vdW50TGF5b3V0RGV2IHwgUGFzc2l2ZSB8IFVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihQYXNzaXZlIHwgVXBkYXRlKTtcbiAgfVxuXG4gIGN1cnJlbnQubGFuZXMgPSByZW1vdmVMYW5lcyhjdXJyZW50LmxhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzQWZ0ZXJUaHJvdygpIHtcbiAgLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVGhlcmUgd2VyZSByZW5kZXIgcGhhc2UgdXBkYXRlcy4gVGhlc2UgYXJlIG9ubHkgdmFsaWQgZm9yIHRoaXMgcmVuZGVyXG4gICAgLy8gcGhhc2UsIHdoaWNoIHdlIGFyZSBub3cgYWJvcnRpbmcuIFJlbW92ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZXMgc29cbiAgICAvLyB0aGV5IGRvIG5vdCBwZXJzaXN0IHRvIHRoZSBuZXh0IHJlbmRlci4gRG8gbm90IHJlbW92ZSB1cGRhdGVzIGZyb20gaG9va3NcbiAgICAvLyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkLlxuICAgIC8vXG4gICAgLy8gT25seSByZXNldCB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZSBpZiBpdCBoYXMgYSBjbG9uZS4gSWYgaXQgZG9lc1xuICAgIC8vIG5vdCBoYXZlIGEgY2xvbmUsIHRoYXQgbWVhbnMgaXQgd2Fzbid0IHByb2Nlc3NlZCwgYW5kIHRoZSB1cGRhdGVzIHdlcmVcbiAgICAvLyBzY2hlZHVsZWQgYmVmb3JlIHdlIGVudGVyZWQgdGhlIHJlbmRlciBwaGFzZS5cbiAgICB2YXIgaG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhvb2sgPSBob29rLm5leHQ7XG4gICAgfVxuXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgY3VycmVudEhvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xuICBsb2NhbElkQ291bnRlciA9IDA7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuICAvLyB0aGUgZGlzcGF0Y2hlciB1c2VkIGZvciBtb3VudHMuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAobmV4dEN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgICB2YXIgbmV3SG9vayA9IHtcbiAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0LlxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gbmV3SG9vaztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5ld0hvb2s7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgIHN0b3JlczogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICB9IGVsc2Uge1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgaW50ZXJsZWF2ZWQ6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogcmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50ID0gY3VycmVudEhvb2s7IC8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuICB2YXIgYmFzZVF1ZXVlID0gY3VycmVudC5iYXNlUXVldWU7IC8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuICAgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIHZhciBwZW5kaW5nRmlyc3QgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ0ZpcnN0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBjdXJyZW50LmJhc2VTdGF0ZTtcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cblxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBfY2xvbmU7XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIGlmICh1cGRhdGUuaGFzRWFnZXJTdGF0ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgdXBkYXRlIGlzIGEgc3RhdGUgdXBkYXRlIChub3QgYSByZWR1Y2VyKSBhbmQgd2FzIHByb2Nlc3NlZCBlYWdlcmx5LFxuICAgICAgICAgIC8vIHdlIGNhbiB1c2UgdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGVcbiAgICAgICAgICBuZXdTdGF0ZSA9IHVwZGF0ZS5lYWdlclN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBmaXJzdCk7XG5cbiAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuICAgIH0gLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIEludGVybGVhdmVkIHVwZGF0ZXMgYXJlIHN0b3JlZCBvbiBhIHNlcGFyYXRlIHF1ZXVlLiBXZSBhcmVuJ3QgZ29pbmcgdG9cbiAgLy8gcHJvY2VzcyB0aGVtIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHdlIGRvIG5lZWQgdG8gdHJhY2sgd2hpY2ggbGFuZXNcbiAgLy8gYXJlIHJlbWFpbmluZy5cblxuXG4gIHZhciBsYXN0SW50ZXJsZWF2ZWQgPSBxdWV1ZS5pbnRlcmxlYXZlZDtcblxuICBpZiAobGFzdEludGVybGVhdmVkICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVybGVhdmVkID0gbGFzdEludGVybGVhdmVkO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIGludGVybGVhdmVkTGFuZSA9IGludGVybGVhdmVkLmxhbmU7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCBpbnRlcmxlYXZlZExhbmUpO1xuICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhpbnRlcmxlYXZlZExhbmUpO1xuICAgICAgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuICAgIH0gd2hpbGUgKGludGVybGVhdmVkICE9PSBsYXN0SW50ZXJsZWF2ZWQpO1xuICB9IGVsc2UgaWYgKGJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICBxdWV1ZS5sYW5lcyA9IE5vTGFuZXM7XG4gIH1cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyOyAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAvLyB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBxdWV1ZS5wZW5kaW5nO1xuICB2YXIgbmV3U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBxdWV1ZSBkb2Vzbid0IHBlcnNpc3QgcGFzdCB0aGlzIHJlbmRlciBwYXNzLlxuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgIC8vIHJlbmRlcidzLlxuICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpOyAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuICAgIGlmICghb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7IC8vIERvbid0IHBlcnNpc3QgdGhlIHN0YXRlIGFjY3VtdWxhdGVkIGZyb20gdGhlIHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvXG4gICAgLy8gdGhlIGJhc2Ugc3RhdGUgdW5sZXNzIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAvLyBUT0RPOiBOb3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBkZXNpcmVkIHNlbWFudGljcywgYnV0IGl0J3Mgd2hhdCB3ZVxuICAgIC8vIGRvIGZvciBnRFNGUC4gSSBjYW4ndCByZW1lbWJlciB3aHkuXG5cbiAgICBpZiAoaG9vay5iYXNlUXVldWUgPT09IG51bGwpIHtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHRTbmFwc2hvdDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZ2V0SXNIeWRyYXRpbmcoKTtcblxuICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICBpZiAoZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICB9XG5cbiAgICBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICBpZiAobmV4dFNuYXBzaG90ICE9PSBnZXRTZXJ2ZXJTbmFwc2hvdCgpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U2VydmVyU25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgICBpZiAoIW9iamVjdElzKG5leHRTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuICAgIC8vXG4gICAgLy8gV2Ugd29uJ3QgZG8gdGhpcyBpZiB3ZSdyZSBoeWRyYXRpbmcgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQsIGJlY2F1c2UgaWZcbiAgICAvLyB0aGUgY29udGVudCBpcyBzdGFsZSwgaXQncyBhbHJlYWR5IHZpc2libGUgYW55d2F5LiBJbnN0ZWFkIHdlJ2xsIHBhdGNoXG4gICAgLy8gaXQgdXAgaW4gYSBwYXNzaXZlIGVmZmVjdC5cblxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIHJlbmRlckxhbmVzKSkge1xuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbiAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgdmFyIGluc3QgPSB7XG4gICAgdmFsdWU6IG5leHRTbmFwc2hvdCxcbiAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IGluc3Q7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBzdWJzY3JpYmUgdG8gdGhlIHN0b3JlLlxuXG4gIG1vdW50RWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSwgW3N1YnNjcmliZV0pOyAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gdXBkYXRlIHRoZSBtdXRhYmxlIGluc3RhbmNlIGZpZWxkcy4gV2Ugd2lsbCB1cGRhdGVcbiAgLy8gdGhpcyB3aGVuZXZlciBzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBvciB2YWx1ZSBjaGFuZ2VzLiBCZWNhdXNlIHRoZXJlJ3Mgbm9cbiAgLy8gY2xlYW4tdXAgZnVuY3Rpb24sIGFuZCB3ZSB0cmFjayB0aGUgZGVwcyBjb3JyZWN0bHksIHdlIGNhbiBjYWxsIHB1c2hFZmZlY3RcbiAgLy8gZGlyZWN0bHksIHdpdGhvdXQgc3RvcmluZyBhbnkgYWRkaXRpb25hbCBzdGF0ZS4gRm9yIHRoZSBzYW1lIHJlYXNvbiwgd2VcbiAgLy8gZG9uJ3QgbmVlZCB0byBzZXQgYSBzdGF0aWMgZmxhZywgZWl0aGVyLlxuICAvLyBUT0RPOiBXZSBjYW4gbW92ZSB0aGlzIHRvIHRoZSBwYXNzaXZlIHBoYXNlIG9uY2Ugd2UgYWRkIGEgcHJlLWNvbW1pdFxuICAvLyBjb25zaXN0ZW5jeSBjaGVjay4gU2VlIHRoZSBuZXh0IGNvbW1lbnQuXG5cbiAgZmliZXIuZmxhZ3MgfD0gUGFzc2l2ZTtcbiAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIHVuZGVmaW5lZCwgbnVsbCk7XG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbiAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuICB2YXIgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgaWYgKCFvYmplY3RJcyhuZXh0U25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZTbmFwc2hvdCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHNuYXBzaG90Q2hhbmdlZCA9ICFvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG5cbiAgaWYgKHNuYXBzaG90Q2hhbmdlZCkge1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIGluc3QgPSBob29rLnF1ZXVlO1xuICB1cGRhdGVFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbc3Vic2NyaWJlXSk7IC8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuICAvLyBjb21taXQgcGhhc2UgaWYgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIG11dGF0aW9uLiBJbiBjb25jdXJyZW50IG1vZGVcbiAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAvLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG5cbiAgaWYgKGluc3QuZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8IHNuYXBzaG90Q2hhbmdlZCB8fCAvLyBDaGVjayBpZiB0aGUgc3VzYmNyaWJlIGZ1bmN0aW9uIGNoYW5nZWQuIFdlIGNhbiBzYXZlIHNvbWUgbWVtb3J5IGJ5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgd2Ugc2NoZWR1bGVkIGEgc3Vic2NyaXB0aW9uIGVmZmVjdCBhYm92ZS5cbiAgd29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLnRhZyAmIEhhc0VmZmVjdCkge1xuICAgIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmU7XG4gICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIHVuZGVmaW5lZCwgbnVsbCk7IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIHJlbmRlckxhbmVzKSkge1xuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIHJlbmRlcmVkU25hcHNob3QpIHtcbiAgZmliZXIuZmxhZ3MgfD0gU3RvcmVDb25zaXN0ZW5jeTtcbiAgdmFyIGNoZWNrID0ge1xuICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCxcbiAgICB2YWx1ZTogcmVuZGVyZWRTbmFwc2hvdFxuICB9O1xuICB2YXIgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChjb21wb25lbnRVcGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjb21wb25lbnRVcGRhdGVRdWV1ZTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdG9yZXMgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXM7XG5cbiAgICBpZiAoc3RvcmVzID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZXMucHVzaChjaGVjayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHtcbiAgLy8gVGhlc2UgYXJlIHVwZGF0ZWQgaW4gdGhlIHBhc3NpdmUgcGhhc2VcbiAgaW5zdC52YWx1ZSA9IG5leHRTbmFwc2hvdDtcbiAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBTb21ldGhpbmcgbWF5IGhhdmUgYmVlbiBtdXRhdGVkIGluIGJldHdlZW4gcmVuZGVyIGFuZCBjb21taXQuIFRoaXMgY291bGRcbiAgLy8gaGF2ZSBiZWVuIGluIGFuIGV2ZW50IHRoYXQgZmlyZWQgYmVmb3JlIHRoZSBwYXNzaXZlIGVmZmVjdHMsIG9yIGl0IGNvdWxkXG4gIC8vIGhhdmUgYmVlbiBpbiBhIGxheW91dCBlZmZlY3QuIEluIHRoYXQgY2FzZSwgd2Ugd291bGQgaGF2ZSB1c2VkIHRoZSBvbGRcbiAgLy8gc25hcHNobyBhbmQgZ2V0U25hcHNob3QgdmFsdWVzIHRvIGJhaWwgb3V0LiBXZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIHRpbWUuXG5cbiAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuICB2YXIgaGFuZGxlU3RvcmVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2VcbiAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgfVxuICB9OyAvLyBTdWJzY3JpYmUgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gYSBjbGVhbi11cCBmdW5jdGlvbi5cblxuXG4gIHJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xufVxuXG5mdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZSgpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGludGVybGVhdmVkOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoRWZmZWN0KHRhZywgY3JlYXRlLCBkZXN0cm95LCBkZXBzKSB7XG4gIHZhciBlZmZlY3QgPSB7XG4gICAgdGFnOiB0YWcsXG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgZGVzdHJveTogZGVzdHJveSxcbiAgICBkZXBzOiBkZXBzLFxuICAgIC8vIENpcmN1bGFyXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICB2YXIgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChjb21wb25lbnRVcGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjb21wb25lbnRVcGRhdGVRdWV1ZTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhc3RFZmZlY3QgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKGxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgbGFzdEVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgICAgZWZmZWN0Lm5leHQgPSBmaXJzdEVmZmVjdDtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVmZmVjdDtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICB7XG4gICAgdmFyIF9yZWYyID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBfcmVmMjtcbiAgICByZXR1cm4gX3JlZjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gaG9vay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCB1bmRlZmluZWQsIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIGRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGN1cnJlbnRIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZFZmZlY3QgPSBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICAgIGRlc3Ryb3kgPSBwcmV2RWZmZWN0LmRlc3Ryb3k7XG5cbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZFZmZlY3QuZGVwcztcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0ZsYWdzLCBjcmVhdGUsIGRlc3Ryb3ksIG5leHREZXBzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgaWYgKCAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKE1vdW50UGFzc2l2ZURldiB8IFBhc3NpdmUgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChQYXNzaXZlIHwgUGFzc2l2ZVN0YXRpYywgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoUGFzc2l2ZSwgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG4gIHtcbiAgICBmaWJlckZsYWdzIHw9IExheW91dFN0YXRpYztcbiAgfVxuXG4gIGlmICggKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxuXG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZDYWxsYmFjayhfaW5zdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlZk9iamVjdCA9IHJlZjtcblxuICAgIHtcbiAgICAgIGlmICghcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnICsgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2luc3QyID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0MjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgdmFyIGZpYmVyRmxhZ3MgPSBVcGRhdGU7XG5cbiAge1xuICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICB9XG5cbiAgaWYgKCAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICB9XG5cbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudERlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7Ly8gVGhpcyBob29rIGlzIG5vcm1hbGx5IGEgbm8tb3AuXG4gIC8vIFRoZSByZWFjdC1kZWJ1Zy1ob29rcyBwYWNrYWdlIGluamVjdHMgaXRzIG93biBpbXBsZW1lbnRhdGlvblxuICAvLyBzbyB0aGF0IGUuZy4gRGV2VG9vbHMgY2FuIGRpc3BsYXkgY3VzdG9tIGhvb2sgdmFsdWVzLlxufVxuXG52YXIgdXBkYXRlRGVidWdWYWx1ZSA9IG1vdW50RGVidWdWYWx1ZTtcblxuZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIG1vdW50TWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAvLyBBc3N1bWUgdGhlc2UgYXJlIGRlZmluZWQuIElmIHRoZXkncmUgbm90LCBhcmVIb29rSW5wdXRzRXF1YWwgd2lsbCB3YXJuLlxuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgX21vdW50U3RhdGUgPSBtb3VudFN0YXRlKHZhbHVlKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9tb3VudFN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfbW91bnRTdGF0ZVsxXTtcblxuICBtb3VudEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgX3VwZGF0ZVN0YXRlID0gdXBkYXRlU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF91cGRhdGVTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX3VwZGF0ZVN0YXRlWzFdO1xuXG4gIHVwZGF0ZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfcmVyZW5kZXJTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSB7fTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBwcmV2VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzZXRQZW5kaW5nLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoaGlnaGVyRXZlbnRQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5LCBDb250aW51b3VzRXZlbnRQcmlvcml0eSkpO1xuICBzZXRQZW5kaW5nKHRydWUpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgc2V0UGVuZGluZyhmYWxzZSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICB7XG4gICAgICBpZiAocHJldlRyYW5zaXRpb24gPT09IG51bGwgJiYgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICB2YXIgX21vdW50U3RhdGUyID0gbW91bnRTdGF0ZShmYWxzZSksXG4gICAgICBpc1BlbmRpbmcgPSBfbW91bnRTdGF0ZTJbMF0sXG4gICAgICBzZXRQZW5kaW5nID0gX21vdW50U3RhdGUyWzFdOyAvLyBUaGUgYHN0YXJ0YCBtZXRob2QgbmV2ZXIgY2hhbmdlcy5cblxuXG4gIHZhciBzdGFydCA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKG51bGwsIHNldFBlbmRpbmcpO1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXJ0O1xuICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICB2YXIgX3VwZGF0ZVN0YXRlMiA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfdXBkYXRlU3RhdGUyWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUyID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3JlcmVuZGVyU3RhdGUyWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxudmFyIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbmZ1bmN0aW9uIGdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpIHtcbiAge1xuICAgIHJldHVybiBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SWQoKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTsgLy8gVE9ETzogSW4gRml6eiwgaWQgZ2VuZXJhdGlvbiBpcyBzcGVjaWZpYyB0byBlYWNoIHNlcnZlciBjb25maWcuIE1heWJlIHdlXG4gIC8vIHNob3VsZCBkbyB0aGlzIGluIEZpYmVyLCB0b28/IERlZmVycmluZyB0aGlzIGRlY2lzaW9uIGZvciBub3cgYmVjYXVzZVxuICAvLyB0aGVyZSdzIG5vIG90aGVyIHBsYWNlIHRvIHN0b3JlIHRoZSBwcmVmaXggZXhjZXB0IGZvciBhbiBpbnRlcm5hbCBmaWVsZCBvblxuICAvLyB0aGUgcHVibGljIGNyZWF0ZVJvb3Qgb2JqZWN0LCB3aGljaCB0aGUgZmliZXIgdHJlZSBkb2VzIG5vdCBjdXJyZW50bHkgaGF2ZVxuICAvLyBhIHJlZmVyZW5jZSB0by5cblxuICB2YXIgaWRlbnRpZmllclByZWZpeCA9IHJvb3QuaWRlbnRpZmllclByZWZpeDtcbiAgdmFyIGlkO1xuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCgpOyAvLyBVc2UgYSBjYXB0aWFsIFIgcHJlZml4IGZvciBzZXJ2ZXItZ2VuZXJhdGVkIGlkcy5cblxuICAgIGlkID0gJzonICsgaWRlbnRpZmllclByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gICAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuICAgIC8vIGhvb2tzIGZvciB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxvY2FsSWQgPSBsb2NhbElkQ291bnRlcisrO1xuXG4gICAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgICBpZCArPSAnSCcgKyBsb2NhbElkLnRvU3RyaW5nKDMyKTtcbiAgICB9XG5cbiAgICBpZCArPSAnOic7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIGEgbG93ZXJjYXNlIHIgcHJlZml4IGZvciBjbGllbnQtZ2VuZXJhdGVkIGlkcy5cbiAgICB2YXIgZ2xvYmFsQ2xpZW50SWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKztcbiAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAncicgKyBnbG9iYWxDbGllbnRJZC50b1N0cmluZygzMikgKyAnOic7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBpZDtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJZCgpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGlkID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoUmVkdWNlckFjdGlvbihmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlKTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSk7XG4gICAgfVxuICB9XG5cbiAgbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIiArICdzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnICsgJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBsYW5lOiBsYW5lLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6IGZhbHNlLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUpO1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoZmliZXIubGFuZXMgPT09IE5vTGFuZXMgJiYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCBhbHRlcm5hdGUubGFuZXMgPT09IE5vTGFuZXMpKSB7XG4gICAgICAvLyBUaGUgcXVldWUgaXMgY3VycmVudGx5IGVtcHR5LCB3aGljaCBtZWFucyB3ZSBjYW4gZWFnZXJseSBjb21wdXRlIHRoZVxuICAgICAgLy8gbmV4dCBzdGF0ZSBiZWZvcmUgZW50ZXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gSWYgdGhlIG5ldyBzdGF0ZSBpcyB0aGVcbiAgICAgIC8vIHNhbWUgYXMgdGhlIGN1cnJlbnQgc3RhdGUsIHdlIG1heSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVudGlyZWx5LlxuICAgICAgdmFyIGxhc3RSZW5kZXJlZFJlZHVjZXIgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyO1xuXG4gICAgICBpZiAobGFzdFJlbmRlcmVkUmVkdWNlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXI7XG5cbiAgICAgICAge1xuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlO1xuICAgICAgICAgIHZhciBlYWdlclN0YXRlID0gbGFzdFJlbmRlcmVkUmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7IC8vIFN0YXNoIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLCBhbmQgdGhlIHJlZHVjZXIgdXNlZCB0byBjb21wdXRlXG4gICAgICAgICAgLy8gaXQsIG9uIHRoZSB1cGRhdGUgb2JqZWN0LiBJZiB0aGUgcmVkdWNlciBoYXNuJ3QgY2hhbmdlZCBieSB0aGVcbiAgICAgICAgICAvLyB0aW1lIHdlIGVudGVyIHRoZSByZW5kZXIgcGhhc2UsIHRoZW4gdGhlIGVhZ2VyIHN0YXRlIGNhbiBiZSB1c2VkXG4gICAgICAgICAgLy8gd2l0aG91dCBjYWxsaW5nIHRoZSByZWR1Y2VyIGFnYWluLlxuXG4gICAgICAgICAgdXBkYXRlLmhhc0VhZ2VyU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcblxuICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKSB7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGguIFdlIGNhbiBiYWlsIG91dCB3aXRob3V0IHNjaGVkdWxpbmcgUmVhY3QgdG8gcmUtcmVuZGVyLlxuICAgICAgICAgICAgLy8gSXQncyBzdGlsbCBwb3NzaWJsZSB0aGF0IHdlJ2xsIG5lZWQgdG8gcmViYXNlIHRoaXMgdXBkYXRlIGxhdGVyLFxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcbiAgICAgICAgICAgIC8vIHRpbWUgdGhlIHJlZHVjZXIgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikgey8vIFN1cHByZXNzIHRoZSBlcnJvci4gSXQgd2lsbCB0aHJvdyBhZ2FpbiBpbiB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgcm9vdCA9IHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lKTtcbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICByZXR1cm4gZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIGlmIChpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyKSkge1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG4gICAgICBwdXNoSW50ZXJsZWF2ZWRRdWV1ZShxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgcXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSkge1xuICBpZiAoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7IC8vIElmIGFueSBlbnRhbmdsZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBwZW5kaW5nIG9uIHRoZSByb290LCB0aGVuIHRoZXlcbiAgICAvLyBtdXN0IGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoXG4gICAgLy8gcmVwcmVzZW50cyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlXG4gICAgLy8gbWF5IGVudGFuZ2xlIG1vcmUgdGhhbiB3ZSBuZWVkIHRvLCBidXQgdGhhdCdzIE9LLiBJbiBmYWN0IGl0J3Mgd29yc2UgaWZcbiAgICAvLyB3ZSAqZG9uJ3QqIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxuXG4gICAgcXVldWVMYW5lcyA9IGludGVyc2VjdExhbmVzKHF1ZXVlTGFuZXMsIHJvb3QucGVuZGluZ0xhbmVzKTsgLy8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cblxuICAgIHZhciBuZXdRdWV1ZUxhbmVzID0gbWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLCBsYW5lKTtcbiAgICBxdWV1ZS5sYW5lcyA9IG5ld1F1ZXVlTGFuZXM7IC8vIEV2ZW4gaWYgcXVldWUubGFuZXMgYWxyZWFkeSBpbmNsdWRlIGxhbmUsIHdlIGRvbid0IGtub3cgZm9yIGNlcnRhaW4gaWZcbiAgICAvLyB0aGUgbGFuZSBmaW5pc2hlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGVudGFuZ2xlZCBpdC4gU28gd2UgbmVlZCB0b1xuICAgIC8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5cbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBuZXdRdWV1ZUxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSwgYWN0aW9uKSB7XG5cbiAge1xuICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNdXRhYmxlU291cmNlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxufTtcblxudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG5cbntcbiAgdmFyIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gIH07XG5cbiAgdmFyIHdhcm5JbnZhbGlkSG9va0FjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG59XG5cbnZhciBub3ckMiA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbnZhciBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gLTE7XG4vKipcbiAqIFRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQvY2FzY2FkaW5nIHVwZGF0ZSAoc2NoZWR1bGVkIGZyb20gYSBsYXlvdXQgZWZmZWN0KS5cbiAqXG4gKiBUaGUgb3ZlcmFsbCBzZXF1ZW5jZSBpczpcbiAqICAgMS4gcmVuZGVyXG4gKiAgIDIuIGNvbW1pdCAoYW5kIGNhbGwgYG9uUmVuZGVyYCwgYG9uQ29tbWl0YClcbiAqICAgMy4gY2hlY2sgZm9yIG5lc3RlZCB1cGRhdGVzXG4gKiAgIDQuIGZsdXNoIHBhc3NpdmUgZWZmZWN0cyAoYW5kIGNhbGwgYG9uUG9zdENvbW1pdGApXG4gKlxuICogTmVzdGVkIHVwZGF0ZXMgYXJlIGlkZW50aWZpZWQgaW4gc3RlcCAzIGFib3ZlLFxuICogYnV0IHN0ZXAgNCBzdGlsbCBhcHBsaWVzIHRvIHRoZSB3b3JrIHRoYXQgd2FzIGp1c3QgY29tbWl0dGVkLlxuICogV2UgdXNlIHR3byBmbGFncyB0byB0cmFjayBuZXN0ZWQgdXBkYXRlcyB0aGVuOlxuICogb25lIHRyYWNrcyB3aGV0aGVyIHRoZSB1cGNvbWluZyB1cGRhdGUgaXMgYSBuZXN0ZWQgdXBkYXRlLFxuICogYW5kIHRoZSBvdGhlciB0cmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkIHVwZGF0ZS5cbiAqIFRoZSBmaXJzdCB2YWx1ZSBnZXRzIHN5bmNlZCB0byB0aGUgc2Vjb25kIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLlxuICovXG5cbnZhciBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbnZhciBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkge1xuICByZXR1cm4gY3VycmVudFVwZGF0ZUlzTmVzdGVkO1xufVxuXG5mdW5jdGlvbiBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCkge1xuICB7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKSB7XG4gIHtcbiAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jTmVzdGVkVXBkYXRlRmxhZygpIHtcbiAge1xuICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IG5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcblxuICBjb21taXRUaW1lID0gbm93JDIoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3ckMigpO1xuXG4gIGlmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPCAwKSB7XG4gICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gbm93JDIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuXG4gICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChsYXlvdXRFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBsYXlvdXRFZmZlY3RTdGFydFRpbWU7XG4gICAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7IC8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3JcbiAgICAvLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAgd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpYmVyKSB7XG5cbiAgaWYgKHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lO1xuICAgIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSAtMTsgLy8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuICAgIC8vIE9yIHRoZSByb290IChmb3IgdGhlIERldlRvb2xzIFByb2ZpbGVyIHRvIHJlYWQpXG5cbiAgICB2YXIgcGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgICB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGFjaGVkIGZpYmVycyBoYXZlIHRoZWlyIHN0YXRlIG5vZGUgY2xlYXJlZCBvdXQuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZXR1cm4gcG9pbnRlciBpcyBhbHNvIGNsZWFyZWQgb3V0LFxuICAgICAgICAgICAgLy8gc28gd2Ugd29uJ3QgYmUgYWJsZSB0byByZXBvcnQgdGhlIHRpbWUgc3BlbnQgaW4gdGhpcyBQcm9maWxlcidzIHN1YnRyZWUuXG4gICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKSB7XG5cbiAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gbm93JDIoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKSB7XG5cbiAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IG5vdyQyKCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpIHtcbiAgLy8gVHJhbnNmZXIgdGltZSBzcGVudCByZW5kZXJpbmcgdGhlc2UgY2hpbGRyZW4gc28gd2UgZG9uJ3QgbG9zZSBpdFxuICAvLyBhZnRlciB3ZSByZXJlbmRlci4gVGhpcyBpcyB1c2VkIGFzIGEgaGVscGVyIGluIHNwZWNpYWwgY2FzZXNcbiAgLy8gd2hlcmUgd2Ugc2hvdWxkIGNvdW50IHRoZSB3b3JrIG9mIG11bHRpcGxlIHBhc3Nlcy5cbiAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZSkge1xuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbiAgLy8gc28gdGhlIHN0YWNrIGlzIGFjY3VyYXRlLlxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgfTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgaXMgZm9ya2VkIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuXG4vLyBCeSBkZWZhdWx0LCByZXR1cm4gYHRydWVgIHRvIGxvZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUuXG4vLyBGb3JrcyBjYW4gcmV0dXJuIGBmYWxzZWAgaWYgdGhpcyBpc24ndCBkZXNpcmFibGUuXG5mdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksIGVycm9ySW5mbykge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgdmFyIGxvZ0Vycm9yID0gc2hvd0Vycm9yRGlhbG9nKGJvdW5kYXJ5LCBlcnJvckluZm8pOyAvLyBBbGxvdyBpbmplY3RlZCBzaG93RXJyb3JEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuICAgIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cblxuICAgIGlmIChsb2dFcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICBpZiAodHJ1ZSkge1xuICAgICAgdmFyIHNvdXJjZSA9IGVycm9ySW5mby5zb3VyY2U7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJyc7IC8vIEJyb3dzZXJzIHN1cHBvcnQgc2lsZW5jaW5nIHVuY2F1Z2h0IGVycm9ycyBieSBjYWxsaW5nXG4gICAgICAvLyBgcHJldmVudERlZmF1bHQoKWAgaW4gd2luZG93IGBlcnJvcmAgaGFuZGxlci5cbiAgICAgIC8vIFdlIHJlY29yZCB0aGlzIGluZm9ybWF0aW9uIGFzIGFuIGV4cGFuZG8gb24gdGhlIGVycm9yLlxuXG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCAmJiBlcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgIGlmIChib3VuZGFyeS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgLy8gVGhlIGVycm9yIGlzIHJlY292ZXJhYmxlIGFuZCB3YXMgc2lsZW5jZWQuXG4gICAgICAgICAgLy8gSWdub3JlIGl0IGFuZCBkb24ndCBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG4gICAgICAgICAgLy8gVGhpcyBpcyBoYW5keSBmb3IgdGVzdGluZyBlcnJvciBib3VuZGFyaWVzIHdpdGhvdXQgbm9pc2UuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFRoZSBlcnJvciBpcyBmYXRhbC4gU2luY2UgdGhlIHNpbGVuY2luZyBtaWdodCBoYXZlXG4gICAgICAgIC8vIGJlZW4gYWNjaWRlbnRhbCwgd2UnbGwgc3VyZmFjZSBpdCBhbnl3YXkuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBicm93c2VyIHdvdWxkIGhhdmUgc2lsZW5jZWQgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAgIC8vIHNvIHdlJ2xsIHByaW50IGl0IGZpcnN0LCBhbmQgdGhlbiBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG5cblxuICAgICAgICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgICAgIC8vIEZvciBhIG1vcmUgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhpcyBibG9jaywgc2VlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IHNvdXJjZSA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoc291cmNlKSA6IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50OlwiIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG4gICAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7XG5cbiAgICAgIGlmIChib3VuZGFyeS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGJvdW5kYXJ5KSB8fCAnQW5vbnltb3VzJztcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIFwiICsgKFwidXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIgKyBlcnJvckJvdW5kYXJ5TmFtZSArIFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9IGNvbXBvbmVudE5hbWVNZXNzYWdlICsgXCJcXG5cIiArIGNvbXBvbmVudFN0YWNrICsgXCJcXG5cXG5cIiArIChcIlwiICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpOyAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cblxuICAgICAgY29uc29sZVsnZXJyb3InXShjb21iaW5lZE1lc3NhZ2UpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgd2UgcHJpbnQgdGhlIGVycm9yIGRpcmVjdGx5LlxuICAgICAgLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIG1lc3NhZ2UsIHRoZSBKUyBzdGFjaywgYW5kIGFueXRoaW5nIHRoZSBicm93c2VyIHdhbnRzIHRvIHNob3cuXG4gICAgICAvLyBXZSBwYXNzIHRoZSBlcnJvciBvYmplY3QgaW5zdGVhZCBvZiBjdXN0b20gbWVzc2FnZSBzbyB0aGF0IHRoZSBicm93c2VyIGRpc3BsYXlzIHRoZSBlcnJvciBuYXRpdmVseS5cbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgUG9zc2libHlXZWFrTWFwJDEgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIGxhbmUpOyAvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxuXG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBudWxsXG4gIH07XG4gIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgb25VbmNhdWdodEVycm9yKGVycm9yKTtcbiAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICB9O1xuXG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgbGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBlcnJvciQxID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgdXBkYXRlLnBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuICAgIH07XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgaWYgKGluc3QgIT09IG51bGwgJiYgdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIHtcbiAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgfVxuXG4gICAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuXG4gICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbiAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvZiB3aGljaCBvbmVzIGFscmVhZHkgZmFpbGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgICAgICAvLyBUaGlzIGdldHMgcmVzZXQgYmVmb3JlIHdlIHlpZWxkIGJhY2sgdG8gdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzXG4gICAgICAgIC8vIG5vdCBkZWZpbmVkLlxuICAgICAgICBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudERpZENhdGNoIGlzIHRoZSBvbmx5IGVycm9yIGJvdW5kYXJ5IG1ldGhvZCBkZWZpbmVkLFxuICAgICAgICAgIC8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsIFN5bmNMYW5lKSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgKyAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAvLyBBdHRhY2ggYSBwaW5nIGxpc3RlbmVyXG4gIC8vXG4gIC8vIFRoZSBkYXRhIG1pZ2h0IHJlc29sdmUgYmVmb3JlIHdlIGhhdmUgYSBjaGFuY2UgdG8gY29tbWl0IHRoZSBmYWxsYmFjay4gT3IsXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgcmVmcmVzaCwgd2UnbGwgbmV2ZXIgY29tbWl0IGEgZmFsbGJhY2suIFNvIHdlIG5lZWQgdG9cbiAgLy8gYXR0YWNoIGEgbGlzdGVuZXIgbm93LiBXaGVuIGl0IHJlc29sdmVzIChcInBpbmdzXCIpLCB3ZSBjYW4gZGVjaWRlIHdoZXRoZXIgdG9cbiAgLy8gdHJ5IHJlbmRlcmluZyB0aGUgdHJlZSBhZ2Fpbi5cbiAgLy9cbiAgLy8gT25seSBhdHRhY2ggYSBsaXN0ZW5lciBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIGxhbmVzXG4gIC8vIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgKHdoaWNoIGFjdHMgbGlrZSBhIFwidGhyZWFkIElEXCIgaGVyZSkuXG4gIC8vXG4gIC8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuICAvLyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmUgbm8gcGluZ3MuXG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgdmFyIHRocmVhZElEcztcblxuICBpZiAocGluZ0NhY2hlID09PSBudWxsKSB7XG4gICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwJDEoKTtcbiAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtcblxuICAgIGlmICh0aHJlYWRJRHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRocmVhZElEcy5oYXMobGFuZXMpKSB7XG4gICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgdGhyZWFkIElEIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKTtcbiAgICB2YXIgcGluZyA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2FrZWFibGUudGhlbihwaW5nLCBwaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnksIHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAvLyBSZXRyeSBsaXN0ZW5lclxuICAvL1xuICAvLyBJZiB0aGUgZmFsbGJhY2sgZG9lcyBjb21taXQsIHdlIG5lZWQgdG8gYXR0YWNoIGEgZGlmZmVyZW50IHR5cGUgb2ZcbiAgLy8gbGlzdGVuZXIuIFRoaXMgb25lIHNjaGVkdWxlcyBhbiB1cGRhdGUgb24gdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IHRvIHR1cm5cbiAgLy8gdGhlIGZhbGxiYWNrIHN0YXRlIG9mZi5cbiAgLy9cbiAgLy8gU3Rhc2ggdGhlIHdha2VhYmxlIG9uIHRoZSBib3VuZGFyeSBmaWJlciBzbyB3ZSBjYW4gYWNjZXNzIGl0IGluIHRoZVxuICAvLyBjb21taXQgcGhhc2UuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIHdha2VhYmxlIHJlc29sdmVzLCB3ZSdsbCBhdHRlbXB0IHRvIHJlbmRlciB0aGUgYm91bmRhcnlcbiAgLy8gYWdhaW4gKFwicmV0cnlcIikuXG4gIHZhciB3YWtlYWJsZXMgPSBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh3YWtlYWJsZXMgPT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG4gICAgdXBkYXRlUXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWU7XG4gIH0gZWxzZSB7XG4gICAgd2FrZWFibGVzLmFkZCh3YWtlYWJsZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyBBIGxlZ2FjeSBtb2RlIFN1c3BlbnNlIHF1aXJrLCBvbmx5IHJlbGV2YW50IHRvIGhvb2sgY29tcG9uZW50cy5cblxuXG4gIHZhciB0YWcgPSBzb3VyY2VGaWJlci50YWc7XG5cbiAgaWYgKChzb3VyY2VGaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgKHRhZyA9PT0gRnVuY3Rpb25Db21wb25lbnQgfHwgdGFnID09PSBGb3J3YXJkUmVmIHx8IHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudCkpIHtcbiAgICB2YXIgY3VycmVudFNvdXJjZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50U291cmNlKSB7XG4gICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IGN1cnJlbnRTb3VyY2UudXBkYXRlUXVldWU7XG4gICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gY3VycmVudFNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICAgICAgc291cmNlRmliZXIubGFuZXMgPSBjdXJyZW50U291cmNlLmxhbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUocmV0dXJuRmliZXIpIHtcbiAgdmFyIG5vZGUgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gLy8gVGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGR1cmluZyB0aGlzIHJlbmRlci4gQ29udGludWUgdG8gdGhlIG5leHRcbiAgICAvLyBib3VuZGFyeS5cblxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgbWFya3MgYSBTdXNwZW5zZSBib3VuZGFyeSBzbyB0aGF0IHdoZW4gd2UncmUgdW53aW5kaW5nIHRoZSBzdGFjayxcbiAgLy8gaXQgY2FwdHVyZXMgdGhlIHN1c3BlbmRlZCBcImV4Y2VwdGlvblwiIGFuZCBkb2VzIGEgc2Vjb25kIChmYWxsYmFjaykgcGFzcy5cbiAgaWYgKChzdXNwZW5zZUJvdW5kYXJ5Lm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIC8vIExlZ2FjeSBNb2RlIFN1c3BlbnNlXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYm91bmRhcnkgaXMgaW4gbGVnYWN5IG1vZGUsIHdlIHNob3VsZCAqbm90KlxuICAgIC8vIHN1c3BlbmQgdGhlIGNvbW1pdC4gUHJldGVuZCBhcyBpZiB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCByZW5kZXJlZFxuICAgIC8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBXaGVuIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBjb21wbGV0ZXMsXG4gICAgLy8gd2UnbGwgZG8gYSBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLlxuICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5ID09PSByZXR1cm5GaWJlcikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZXJlIHdlIHN1c3BlbmRlZCB3aGlsZSByZWNvbmNpbGluZyB0aGUgY2hpbGRyZW4gb2ZcbiAgICAgIC8vIGEgU3VzcGVuc2UgYm91bmRhcnkncyBpbm5lciBPZmZzY3JlZW4gd3JhcHBlciBmaWJlci4gVGhpcyBoYXBwZW5zXG4gICAgICAvLyB3aGVuIGEgUmVhY3QubGF6eSBjb21wb25lbnQgaXMgYSBkaXJlY3QgY2hpbGQgb2YgYVxuICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcnkuXG4gICAgICAvL1xuICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcmllcyBhcmUgaW1wbGVtZW50ZWQgYXMgbXVsdGlwbGUgZmliZXJzLCBidXQgdGhleVxuICAgICAgLy8gYXJlIGEgc2luZ2xlIGNvbmNlcHR1YWwgdW5pdC4gVGhlIGxlZ2FjeSBtb2RlIGJlaGF2aW9yIHdoZXJlIHdlXG4gICAgICAvLyBwcmV0ZW5kIHRoZSBzdXNwZW5kZWQgZmliZXIgY29tbWl0dGVkIGFzIGBudWxsYCB3b24ndCB3b3JrLFxuICAgICAgLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UgdGhlIFwic3VzcGVuZGVkXCIgZmliZXIgaXMgdGhlIGlubmVyXG4gICAgICAvLyBPZmZzY3JlZW4gd3JhcHBlci5cbiAgICAgIC8vXG4gICAgICAvLyBCZWNhdXNlIHRoZSBjb250ZW50cyBvZiB0aGUgYm91bmRhcnkgaGF2ZW4ndCBzdGFydGVkIHJlbmRlcmluZ1xuICAgICAgLy8geWV0IChpLmUuIG5vdGhpbmcgaW4gdGhlIHRyZWUgaGFzIHBhcnRpYWxseSByZW5kZXJlZCkgd2UgY2FuXG4gICAgICAvLyBzd2l0Y2ggdG8gdGhlIHJlZ3VsYXIsIGNvbmN1cnJlbnQgbW9kZSBiZWhhdmlvcjogbWFyayB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHdpdGggU2hvdWxkQ2FwdHVyZSBhbmQgZW50ZXIgdGhlIHVud2luZCBwaGFzZS5cbiAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgc291cmNlRmliZXIuZmxhZ3MgfD0gRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZTsgLy8gV2UncmUgZ29pbmcgdG8gY29tbWl0IHRoaXMgZmliZXIgZXZlbiB0aG91Z2ggaXQgZGlkbid0IGNvbXBsZXRlLlxuICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuICAgICAgLy8gYWxsIGxpZmVjeWNsZSBlZmZlY3QgdGFncy5cblxuICAgICAgc291cmNlRmliZXIuZmxhZ3MgJj0gfihMaWZlY3ljbGVFZmZlY3RNYXNrIHwgSW5jb21wbGV0ZSk7XG5cbiAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlICYmIGVuYWJsZVBlcnNpc3RlbnRPZmZzY3JlZW5Ib3N0Q29udGFpbmVyKSB7XG4gICAgICAgIC8vIEFub3RoZXIgbGVnYWN5IFN1c3BlbnNlIHF1aXJrLiBJbiBwZXJzaXN0ZW50IG1vZGUsIGlmIHRoaXMgaXMgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgbW91bnQsIG92ZXJyaWRlIHRoZSBwcm9wcyBvZiB0aGUgaG9zdCBjb250YWluZXIgdG8gaGlkZVxuICAgICAgICAvLyBpdHMgY29udGVudHMuXG4gICAgICAgIHZhciBjdXJyZW50U3VzcGVuc2VCb3VuZGFyeSA9IHN1c3BlbnNlQm91bmRhcnkuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChjdXJyZW50U3VzcGVuc2VCb3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBvZmZzY3JlZW5GaWJlciA9IHN1c3BlbnNlQm91bmRhcnkuY2hpbGQ7XG4gICAgICAgICAgdmFyIG9mZnNjcmVlbkNvbnRhaW5lciA9IG9mZnNjcmVlbkZpYmVyLmNoaWxkO1xuXG4gICAgICAgICAgaWYgKG9mZnNjcmVlbkNvbnRhaW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gb2Zmc2NyZWVuQ29udGFpbmVyLm1lbW9pemVkUHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUHJvcHMgPSBnZXRPZmZzY3JlZW5Db250YWluZXJQcm9wcygnaGlkZGVuJywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGFpbmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRhaW5lclByb3BzO1xuICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGFpbmVyLm1lbW9pemVkUHJvcHMgPSBjb250YWluZXJQcm9wcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTb3VyY2VGaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICBpZiAoY3VycmVudFNvdXJjZUZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudC4gQ2hhbmdlIHRoZSB0YWcgc28gaXQncyBub3QgbWlzdGFrZW4gZm9yIGFcbiAgICAgICAgICAvLyBjb21wbGV0ZWQgY2xhc3MgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgd2Ugc2hvdWxkIG5vdCBjYWxsXG4gICAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgaWYgaXQgaXMgZGVsZXRlZC5cbiAgICAgICAgICBzb3VyY2VGaWJlci50YWcgPSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSB0cnkgcmVuZGVyaW5nIGFnYWluLCB3ZSBzaG91bGQgbm90IHJldXNlIHRoZSBjdXJyZW50IGZpYmVyLFxuICAgICAgICAgIC8vIHNpbmNlIGl0J3Mga25vd24gdG8gYmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBVc2UgYSBmb3JjZSB1cGRhdGUgdG9cbiAgICAgICAgICAvLyBwcmV2ZW50IGEgYmFpbCBvdXQuXG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgU3luY0xhbmUpO1xuICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcbiAgICAgICAgICBlbnF1ZXVlVXBkYXRlKHNvdXJjZUZpYmVyLCB1cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbiAgICAgIC8vIGluZGljYXRlIHRoYXQgaXQgc3RpbGwgaGFzIHBlbmRpbmcgd29yay5cblxuXG4gICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbiAgfSAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBjb25jdXJyZW50IG1vZGUgdHJlZS4gQ29udGludWVcbiAgLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbiAgLy9cbiAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gIC8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuICAvLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbiAgLy9cbiAgLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbiAgLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbiAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcbiAgLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbiAgLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbiAgLy9cbiAgLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbiAgLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG4gIC8vXG4gIC8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbiAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG4gIC8vXG4gIC8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgLy9cbiAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cbiAgLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbiAgLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4gIC8vXG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4gIC8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuICAvLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbiAgLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuICAvL1xuICAvLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG4gIC8vXG4gIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbiAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTaG91bGRDYXB0dXJlOyAvLyBUT0RPOiBJIHRoaW5rIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2Ugbm93IHVzZSBgRGlkQ2FwdHVyZWAgaW5cbiAgLy8gdGhlIGJlZ2luIHBoYXNlIHRvIHByZXZlbnQgYW4gZWFybHkgYmFpbG91dC5cblxuICBzdXNwZW5zZUJvdW5kYXJ5LmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZmxhZ3MgfD0gSW5jb21wbGV0ZTtcblxuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSB3YWtlYWJsZS4gVGhlIGNvbXBvbmVudCBzdXNwZW5kZWQuXG4gICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG4gICAgcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIpO1xuXG5cbiAgICB2YXIgc3VzcGVuc2VCb3VuZGFyeSA9IGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKTtcblxuICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIFdlIG9ubHkgYXR0YWNoIHBpbmcgbGlzdGVuZXJzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuICAgICAgLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuXG4gICAgICBpZiAoc3VzcGVuc2VCb3VuZGFyeS5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnksIHJvb3QsIHdha2VhYmxlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gYm91bmRhcnkgd2FzIGZvdW5kLiBVbmxlc3MgdGhpcyBpcyBhIHN5bmMgdXBkYXRlLCB0aGlzIGlzIE9LLlxuICAgICAgLy8gV2UgY2FuIHN1c3BlbmQgYW5kIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG4gICAgICBpZiAoIWluY2x1ZGVzU3luY0xhbmUocm9vdFJlbmRlckxhbmVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIG5vdCBhIHN5bmMgdXBkYXRlLiBTdXNwZW5kLiBTaW5jZSB3ZSdyZSBub3QgYWN0aXZhdGluZyBhXG4gICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGlzIHdpbGwgdW53aW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290IHdpdGhvdXRcbiAgICAgICAgLy8gcGVyZm9ybWluZyBhIHNlY29uZCBwYXNzIHRvIHJlbmRlciBhIGZhbGxiYWNrLiAoVGhpcyBpcyBhcmd1YWJseSBob3dcbiAgICAgICAgLy8gcmVmcmVzaCB0cmFuc2l0aW9ucyBzaG91bGQgd29yaywgdG9vLCBzaW5jZSB3ZSdyZSBub3QgZ29pbmcgdG8gY29tbWl0XG4gICAgICAgIC8vIHRoZSBmYWxsYmFja3MgYW55d2F5LilcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBjYXNlIGFsc28gYXBwbGllcyB0byBpbml0aWFsIGh5ZHJhdGlvbi5cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVGhpcyBpcyBhIHN5bmMvZGlzY3JldGUgdXBkYXRlLiBXZSB0cmVhdCB0aGlzIGNhc2UgbGlrZSBhbiBlcnJvclxuICAgICAgLy8gYmVjYXVzZSBkaXNjcmV0ZSByZW5kZXJzIGFyZSBleHBlY3RlZCB0byBwcm9kdWNlIGEgY29tcGxldGUgdHJlZVxuICAgICAgLy8gc3luY2hyb25vdXNseSB0byBtYWludGFpbiBjb25zaXN0ZW5jeSB3aXRoIGV4dGVybmFsIHN0YXRlLlxuXG5cbiAgICAgIHZhciB1bmNhdWdodFN1c3BlbnNlRXJyb3IgPSBuZXcgRXJyb3IoJ0EgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzICcgKyAnd2lsbCBjYXVzZSB0aGUgVUkgdG8gYmUgcmVwbGFjZWQgd2l0aCBhIGxvYWRpbmcgaW5kaWNhdG9yLiBUbyAnICsgJ2ZpeCwgdXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgJyArICd3aXRoIHN0YXJ0VHJhbnNpdGlvbi4nKTsgLy8gSWYgd2UncmUgb3V0c2lkZSBhIHRyYW5zaXRpb24sIGZhbGwgdGhyb3VnaCB0byB0aGUgcmVndWxhciBlcnJvciBwYXRoLlxuICAgICAgLy8gVGhlIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IHN1c3BlbnNlIGJvdW5kYXJ5LlxuXG4gICAgICB2YWx1ZSA9IHVuY2F1Z2h0U3VzcGVuc2VFcnJvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IsIG5vdCBhIFN1c3BlbnNlIHdha2VhYmxlLlxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIHNvdXJjZUZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgbWFya0RpZFN1c3BlbmRXaGlsZUh5ZHJhdGluZ0RFVigpO1xuXG4gICAgICB2YXIgX3N1c3BlbnNlQm91bmRhcnkgPSBnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZShyZXR1cm5GaWJlcik7IC8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGR1cmluZyBoeWRyYXRpb24sIHdlIG1heSBiZSBhYmxlIHRvIHJlY292ZXIgYnlcbiAgICAgIC8vIGRpc2NhcmRpbmcgdGhlIGRlaHlkcmF0ZWQgY29udGVudCBhbmQgc3dpdGNoaW5nIHRvIGEgY2xpZW50IHJlbmRlci5cbiAgICAgIC8vIEluc3RlYWQgb2Ygc3VyZmFjaW5nIHRoZSBlcnJvciwgZmluZCB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeVxuICAgICAgLy8gYW5kIHJlbmRlciBpdCBhZ2FpbiB3aXRob3V0IGh5ZHJhdGlvbi5cblxuXG4gICAgICBpZiAoX3N1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKChfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmIFNob3VsZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgLy8gU2V0IGEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHdlIHNob3VsZCB0cnkgcmVuZGVyaW5nIHRoZSBub3JtYWxcbiAgICAgICAgICAvLyBjaGlsZHJlbiBhZ2Fpbiwgbm90IHRoZSBmYWxsYmFjay5cbiAgICAgICAgICBfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShfc3VzcGVuc2VCb3VuZGFyeSwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByb290LCByb290UmVuZGVyTGFuZXMpOyAvLyBFdmVuIHRob3VnaCB0aGUgdXNlciBtYXkgbm90IGJlIGFmZmVjdGVkIGJ5IHRoaXMgZXJyb3IsIHdlIHNob3VsZFxuICAgICAgICAvLyBzdGlsbCBsb2cgaXQgc28gaXQgY2FuIGJlIGZpeGVkLlxuXG4gICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG5cbiAgcmVuZGVyRGlkRXJyb3IodmFsdWUpO1xuICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG5cbiAgZG8ge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF9lcnJvckluZm8sIGxhbmUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cbiAgICAgICAgICB2YXIgX2xhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBfbGFuZSk7IC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuXG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgc3VzcGVuZHMuIEl0IHJldHVybnMgdGhlXG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICAvLyBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmU3RhdGljO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhZE5vTXV0YXRpb25zRWZmZWN0cyhjdXJyZW50LCBjb21wbGV0ZWRXb3JrKSB7XG4gIHZhciBkaWRCYWlsb3V0ID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gIGlmIChkaWRCYWlsb3V0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUT0RPOiBJZiB3ZSBtb3ZlIHRoZSBgaGFkTm9NdXRhdGlvbnNFZmZlY3RzYCBjYWxsIGFmdGVyIGBidWJibGVQcm9wZXJ0aWVzYFxuICAvLyB0aGVuIHdlIG9ubHkgaGF2ZSB0byBjaGVjayB0aGUgYGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzYC5cblxuXG4gIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgaWYgKChjaGlsZC5mbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MgfHwgKGNoaWxkLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGFwcGVuZEFsbENoaWxkcmVuO1xudmFyIHVwZGF0ZUhvc3RDb250YWluZXI7XG52YXIgdXBkYXRlSG9zdENvbXBvbmVudDtcbnZhciB1cGRhdGVIb3N0VGV4dDtcblxuaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgLy8gTXV0YXRpb24gbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykgey8vIE5vb3BcbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgLy8gUGVyc2lzdGVudCBob3N0IHRyZWUgbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgcHJvcHMgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHRleHQgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgX2luc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoX2luc3RhbmNlLCB0ZXh0LCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIF9pbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIG5vZGUsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vICRGbG93Rml4TWUgVGhpcyBpcyBjb3JyZWN0IGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBsYWJlbGVkIGJyZWFrLlxuXG5cbiAgICAgIG5vZGUgPSBub2RlO1xuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9OyAvLyBBbiB1bmZvcnR1bmF0ZSBmb3JrIG9mIGFwcGVuZEFsbENoaWxkcmVuIGJlY2F1c2Ugd2UgaGF2ZSB0d28gZGlmZmVyZW50IHBhcmVudCB0eXBlcy5cblxuXG4gIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHByb3BzID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMiA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcbiAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBIaWRlIGl0LlxuICAgICAgICAgIHZhciB0ZXh0ID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIF9pbnN0YW5jZTIgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShfaW5zdGFuY2UyLCB0ZXh0LCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgX2luc3RhbmNlMik7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKGNvbnRhaW5lckNoaWxkU2V0LCBub2RlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgY29ycmVjdCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgbGFiZWxlZCBicmVhay5cblxuXG4gICAgICBub2RlID0gbm9kZTtcblxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHBvcnRhbE9yUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSBoYWROb011dGF0aW9uc0VmZmVjdHMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSA7IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTsgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuXG4gICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDsgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjb250YWluZXIgdG8gc3dhcCBvdXQgdGhlIGNvbnRhaW5lci5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wczsgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuXG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gaGFkTm9NdXRhdGlvbnNFZmZlY3RzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiBvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUocmVjeWNsYWJsZUluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuXG4gICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcblxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7IC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7Ly8gTm9vcFxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb21wb25lbnQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHsvLyBOb29wXG4gIH07XG5cbiAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHsvLyBOb29wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgLy8gSWYgd2UncmUgaHlkcmF0aW5nLCB3ZSBzaG91bGQgY29uc3VtZSBhcyBtYW55IGl0ZW1zIGFzIHdlIGNhblxuICAgIC8vIHNvIHdlIGRvbid0IGxlYXZlIGFueSBiZWhpbmQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAodGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsYXN0VGFpbE5vZGUgPSB0YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAobGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbGxhcHNlZCc6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgX3RhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChfdGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoX3RhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2xhc3RUYWlsTm9kZSA9IF90YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGFpbE5vZGUgPSBfdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChfbGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICBpZiAoIWhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayAmJiByZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBzdXNwZW5kZWQgZHVyaW5nIHRoZSBoZWFkLiBXZSB3YW50IHRvIHNob3cgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgICAvLyByb3cgYXQgdGhlIHRhaWwuIFNvIHdlJ2xsIGtlZXAgb24gYW5kIGN1dCBvZmYgdGhlIHJlc3QuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgX2xhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICB2YXIgZGlkQmFpbG91dCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuXG4gIGlmICghZGlkQmFpbG91dCkge1xuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoY2hpbGQubGFuZXMsIGNoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzOyAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4gICAgICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgICAgIC8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi4gSWZcbiAgICAgICAgLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuICAgICAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLiBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXNcbiAgICAgICAgLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cblxuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLCBfY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZC5mbGFnczsgLy8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuICAgICAgICAvLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbiAgICAgICAgLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5cbiAgICAgICAgX2NoaWxkLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgfSBlbHNlIHtcbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHZhciBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZDIgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQyLmxhbmVzLCBfY2hpbGQyLmNoaWxkTGFuZXMpKTsgLy8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGVtLlxuXG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jaGlsZDMgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkMyAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZDMubGFuZXMsIF9jaGlsZDMuY2hpbGRMYW5lcykpOyAvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbiAgICAgICAgLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaWdub3JlIHRoZW0uXG5cbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuZmxhZ3MgJiBTdGF0aWNNYXNrOyAvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4gICAgICAgIC8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuICAgICAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cblxuICAgICAgICBfY2hpbGQzLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZDMgPSBfY2hpbGQzLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICB9XG5cbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgcmV0dXJuIGRpZEJhaWxvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cblxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG5cbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2NoZWR1bGUgYW4gdXBkYXRlIGZvclxuICAgICAgICAgICAgLy8gdGhlIGNvbW1pdCBzaWRlLWVmZmVjdHMgb24gdGhlIHJvb3QuXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjbGllbnQgcm9vdFxuICAgICAgICAgICAgICAhcHJldlN0YXRlLmlzRGVoeWRyYXRlZCB8fCAvLyBDaGVjayBpZiB3ZSByZXZlcnRlZCB0byBjbGllbnQgcmVuZGVyaW5nIChlLmcuIGR1ZSB0byBhbiBlcnJvcilcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGNsZWFyIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGNvbW1pdC4gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGFcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXIgd2l0aCBwcmV2aW91cyBjaGlsZHJlbi4gSXQncyBhbHNvIHNhZmUgdG8gZG8gZm9yXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGwgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgcmVuZGVyIHdhcyBudWxsIChzbyB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBiZSBlbXB0eSkuXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7IC8vIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsIHRoZXJlIG1heSBoYXZlIGJlZW5cbiAgICAgICAgICAgICAgICAvLyByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvbiBhdHRlbXB0LiBJZiBzbywgYWRkXG4gICAgICAgICAgICAgICAgLy8gdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGUgY29tbWl0IHBoYXNlLlxuXG4gICAgICAgICAgICAgICAgdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBhZGQgdGhlbSB0b3AtPmRvd24gb3JcbiAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWQgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWYgb24gYSBob3N0IG5vZGUgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBoYXNVbmh5ZHJhdGVkVGFpbE5vZGVzKCkgJiYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2Rlcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlciB8IEluY29tcGxldGUgfCBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0U3RhdGUgIT09IG51bGwgJiYgbmV4dFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIGluc2lkZSBhIGh5ZHJhdGlvbiBzdGF0ZSB0aGUgZmlyc3QgdGltZSB3ZSdyZSBwaWNraW5nIHVwIHRoaXNcbiAgICAgICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCBhbmQgYWxzbyBhZnRlciB3ZSd2ZSByZWVudGVyZWQgaXQgZm9yIGZ1cnRoZXIgaHlkcmF0aW9uLlxuICAgICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDMgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICghX3dhc0h5ZHJhdGVkMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudCB3YXMgY29tcGxldGVkIHdpdGhvdXQgYSBoeWRyYXRlZCBub2RlLiAnICsgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHJlZW50ZXJlZCB0aGlzIGJvdW5kYXJ5IHRvIGh5ZHJhdGUgaXQuIElmIHNvLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBoeWRyYXRpb25cbiAgICAgICAgICAgICAgLy8gc3RhdGUgc2luY2Ugd2UncmUgbm93IGV4aXRpbmcgb3V0IG9mIGl0LiBwb3BIeWRyYXRpb25TdGF0ZSBkb2Vzbid0IGRvIHRoYXQgZm9yIHVzLlxuICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBib3VuZGFyeSBkaWQgbm90IHN1c3BlbmQgc28gaXQncyBub3cgaHlkcmF0ZWQgYW5kIHVuc3VzcGVuZGVkLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBtYXJrIHRoaXMgYm91bmRhcnlcbiAgICAgICAgICAgICAgLy8gYXMgaGF2aW5nIGh5ZHJhdGVkIHNvIGV2ZW50cyBrbm93IHRoYXQgdGhleSdyZSBmcmVlIHRvIGJlIGludm9rZWQuXG4gICAgICAgICAgICAgIC8vIEl0J3MgYWxzbyBhIHNpZ25hbCB0byByZXBsYXkgZXZlbnRzIGFuZCB0aGUgc3VzcGVuc2UgY2FsbGJhY2suXG4gICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggcmV0cnkgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSBtaWdodCBhcyB3ZWxsIGFsd2F5cyBtYXJrIHRoaXMuXG5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9pc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChfaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9wcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBfcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB0aGlzIHRyZWUuIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsXG4gICAgICAgICAgLy8gdGhlcmUgbWF5IGhhdmUgYmVlbiByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvblxuICAgICAgICAgIC8vIGF0dGVtcHQuIElmIHNvLCBhZGQgdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuXG5cblxuICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLiBSZS1yZW5kZXIgd2l0aCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lczsgLy8gRG8gbm90IHJlc2V0IHRoZSBlZmZlY3QgbGlzdC5cblxuICAgICAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcHJldkRpZFRpbWVvdXQgPSBfcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuIGVmZmVjdCB0byB0b2dnbGUgdGhlIHN1YnRyZWUncyB2aXNpYmlsaXR5LiBXaGVuIHdlIHN3aXRjaCBmcm9tXG4gICAgICAgIC8vIGZhbGxiYWNrIC0+IHByaW1hcnksIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgc2NoZWR1bGVzIHRoaXMgZWZmZWN0XG4gICAgICAgIC8vIGFzIHBhcnQgb2YgaXRzIG5vcm1hbCBjb21wbGV0ZSBwaGFzZS4gQnV0IHdoZW4gd2Ugc3dpdGNoIGZyb21cbiAgICAgICAgLy8gcHJpbWFyeSAtPiBmYWxsYmFjaywgdGhlIGlubmVyIE9mZnNjcmVlbiBmaWJlciBkb2VzIG5vdCBoYXZlIGEgY29tcGxldGVcbiAgICAgICAgLy8gcGhhc2UuIFNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgaXRzIGVmZmVjdCBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBhbHNvIHVzZSB0aGlzIGZsYWcgdG8gY29ubmVjdC9kaXNjb25uZWN0IHRoZSBlZmZlY3RzLCBidXQgdGhlIHNhbWVcbiAgICAgICAgLy8gbG9naWMgYXBwbGllczogd2hlbiByZS1jb25uZWN0aW5nLCB0aGUgT2Zmc2NyZWVuIGZpYmVyJ3MgY29tcGxldGVcbiAgICAgICAgLy8gcGhhc2Ugd2lsbCBoYW5kbGUgc2NoZWR1bGluZyB0aGUgZWZmZWN0LiBJdCdzIG9ubHkgd2hlbiB0aGUgZmFsbGJhY2tcbiAgICAgICAgLy8gaXMgYWN0aXZlIHRoYXQgd2UgaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsLlxuXG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICYmICFwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgIHZhciBfb2Zmc2NyZWVuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBfb2Zmc2NyZWVuRmliZXIuZmxhZ3MgfD0gVmlzaWJpbGl0eTsgLy8gVE9ETzogVGhpcyB3aWxsIHN0aWxsIHN1c3BlbmQgYSBzeW5jaHJvbm91cyB0cmVlIGlmIGFueXRoaW5nXG4gICAgICAgICAgLy8gaW4gdGhlIGNvbmN1cnJlbnQgdHJlZSBhbHJlYWR5IHN1c3BlbmRlZCBkdXJpbmcgdGhpcyByZW5kZXIuXG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGtub3duIGJ1Zy5cblxuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYmFjayB0byB0aHJvd0V4Y2VwdGlvbiBiZWNhdXNlIHRoaXMgaXMgdG9vIGxhdGVcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2VcbiAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuICAgICAgICAgICAgLy8gdGhpcyBtYXJrZXIsIGFuZCB0aGlzIGlzIHRvbyBsYXRlLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBpbW1lZGlhdGVseSByZXN0YXJ0IGZyb20gd2l0aGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgICAgICAgdmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCA9IGN1cnJlbnQgPT09IG51bGwgJiYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUgfHwgIWVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2spO1xuXG4gICAgICAgICAgICBpZiAoaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0IHx8IGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgaW4gYW4gaW52aXNpYmxlIHRyZWUgb3IgYSBuZXcgcmVuZGVyLCB0aGVuIHNob3dpbmdcbiAgICAgICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBpcyBvay5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIGhpZGUgY29udGVudCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZCBmb3IgbG9uZ2VyIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdha2VhYmxlcyA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh3YWtlYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gYXR0YWNoIGEgcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuXG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgaWYgKF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gU2FtZSBhcyBjbGFzcyBjb21wb25lbnQgY2FzZS4gSSBwdXQgaXQgZG93biBoZXJlIHNvIHRoYXQgdGhlIHRhZ3MgYXJlXG4gICAgICAgIC8vIHNlcXVlbnRpYWwgdG8gZW5zdXJlIHRoaXMgc3dpdGNoIGlzIGNvbXBpbGVkIHRvIGEganVtcCB0YWJsZS5cbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiB0aGUgZGVmYXVsdCwgXCJpbmRlcGVuZGVudFwiIG1vZGUuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZFN1c3BlbmRBbHJlYWR5ID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG4gICAgICAgIHZhciByZW5kZXJlZFRhaWwgPSByZW5kZXJTdGF0ZS5yZW5kZXJpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4gICAgICAgICAgICAvLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3JcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbiAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbm5vdEJlU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBJZiB0aGlzIGlzIGEgbmV3bHkgc3VzcGVuZGVkIHRyZWUsIGl0IG1pZ2h0IG5vdCBnZXQgY29tbWl0dGVkIGFzXG4gICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGl0cyB0aGVuYWJsZXMuIEluc3RlYWQsIHdlJ2xsIHRyYW5zZmVyIGl0cyB0aGVuYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VGhlbmFibGVzID0gc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3VGhlbmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbmV3VGhlbmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJlZm9yZSBkb2luZyB0aGUgc2Vjb25kIHBhc3Mgc2luY2UgdGhhdCdzIG5vdyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTsgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwgJiYgbm93JDEoKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuICAgICAgICAgICAgICAvLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICB9IC8vIE5leHQgd2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZSB0YWlsLlxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSByZW5kZXJlZCByb3cgdG8gdGhlIGNoaWxkIGxpc3QuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgdmFyIF9zdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocmVuZGVyZWRUYWlsKTtcblxuICAgICAgICAgICAgaWYgKF9zdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlOyAvLyBFbnN1cmUgd2UgdHJhbnNmZXIgdGhlIHVwZGF0ZSBxdWV1ZSB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBnZXQgbG9zdCBpZiB0aGlzIHJvdyBlbmRzIHVwIGRyb3BwZWQgZHVyaW5nIGEgc2Vjb25kIHBhc3MuXG5cbiAgICAgICAgICAgICAgdmFyIF9uZXdUaGVuYWJsZXMgPSBfc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgIGlmIChfbmV3VGhlbmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfbmV3VGhlbmFibGVzO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgdHJ1ZSk7IC8vIFRoaXMgbWlnaHQgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuXG4gICAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsID09PSBudWxsICYmIHJlbmRlclN0YXRlLnRhaWxNb2RlID09PSAnaGlkZGVuJyAmJiAhcmVuZGVyZWRUYWlsLmFsdGVybmF0ZSAmJiAhZ2V0SXNIeWRyYXRpbmcoKSAvLyBXZSBkb24ndCBjdXQgaXQgaWYgd2UncmUgaHlkcmF0aW5nLlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuICAgICAgICAgICAgLy8gZXhjZWVkIGl0LlxuICAgICAgICAgICAgbm93JDEoKSAqIDIgLSByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkgJiYgcmVuZGVyTGFuZXMgIT09IE9mZnNjcmVlbkxhbmUpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG4gICAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBpcyB1c3VhbGx5IGZhc3Rlci5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBvZiB0aGUgYmFja3dhcmRzIHRhaWwgd2lsbCBoYXZlIGJlZW4gYWRkZWRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBlbmQuIFRoaXMgYnJlYWtzIHRoZSBndWFyYW50ZWUgdGhhdCBsaWZlLWN5Y2xlcyBmaXJlIGluXG4gICAgICAgICAgICAvLyBzaWJsaW5nIG9yZGVyIGJ1dCB0aGF0IGlzbid0IGEgc3Ryb25nIGd1YXJhbnRlZSBwcm9taXNlZCBieSBSZWFjdC5cbiAgICAgICAgICAgIC8vIEVzcGVjaWFsbHkgc2luY2UgdGhlc2UgbWlnaHQgYWxzbyBqdXN0IHBvcCBpbiBkdXJpbmcgZnV0dXJlIGNvbW1pdHMuXG4gICAgICAgICAgICAvLyBBcHBlbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJlbmRlcmVkVGFpbC5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHJlbmRlclN0YXRlLmxhc3Q7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyU3RhdGUubGFzdCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIHN0aWxsIGhhdmUgdGFpbCByb3dzIHRvIHJlbmRlci5cbiAgICAgICAgICAvLyBQb3AgYSByb3cuXG4gICAgICAgICAgdmFyIG5leHQgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG5leHQ7XG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG5leHQuc2libGluZztcbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3ckMSgpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIG5leHRJc0hpZGRlbiA9IF9uZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX3ByZXZTdGF0ZTIgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUyICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuICYmICggLy8gTGVnYWN5SGlkZGVuIGRvZXNuJ3QgZG8gYW55IGhpZGluZyDigJQgaXQgb25seSBwcmUtcmVuZGVycy5cbiAgICAgICAgICAhZW5hYmxlTGVnYWN5SGlkZGVuICkpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXh0SXNIaWRkZW4gfHwgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGZvciBoaWRkZW4gY2hpbGRyZW4gdW5sZXNzIHdlJ3JlIHJlbmRlcmluZ1xuICAgICAgICAgIC8vIGF0IG9mZnNjcmVlbiBwcmlvcml0eS5cbiAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGFuIGluc2VydGlvbiBvciB1cGRhdGUgaW4gdGhlIGhpZGRlbiBzdWJ0cmVlLlxuICAgICAgICAgICAgICAvLyBJZiBzbywgd2UgbmVlZCB0byBoaWRlIHRob3NlIG5vZGVzIGluIHRoZSBjb21taXQgcGhhc2UsIHNvXG4gICAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgdmlzaWJpbGl0eSBlZmZlY3QuXG4gICAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHZhciBoYXNJZDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhDb21wb25lbnQudHlwZSwgbnVsbCwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MubW9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIGNoaWxkLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBjaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNoaWxkO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHtcbiAgICB2YXIgX3R5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICB2YXIgX2lubmVyUHJvcFR5cGVzID0gX3R5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKF9pbm5lclByb3BUeXBlcykge1xuICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICBjaGVja1Byb3BUeXBlcyhfaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBvdXRlck1lbW9UeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG5cbiAgICAgIGlmIChvdXRlck1lbW9UeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgLy8gV2Ugd2FybiB3aGVuIHlvdSBkZWZpbmUgcHJvcFR5cGVzIG9uIGxhenkoKVxuICAgICAgICAvLyBzbyBsZXQncyBqdXN0IHNraXAgb3ZlciBpdCB0byBmaW5kIG1lbW8oKSBvdXRlciB3cmFwcGVyLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBmb3IgbWVtbyBhcmUgdmFsaWRhdGVkIGxhdGVyLlxuICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IG91dGVyTWVtb1R5cGU7XG4gICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gbnVsbDtcbiAgICAgICAgfSAvLyBJbm5lciBwcm9wVHlwZXMgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBwYXRoLlxuXG5cbiAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gb3V0ZXJNZW1vVHlwZSAmJiBvdXRlck1lbW9UeXBlLnByb3BUeXBlcztcblxuICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCAoU2ltcGxlTWVtb0NvbXBvbmVudCBoYXMgbm8gZGVmYXVsdFByb3BzKVxuICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtdWxhdGVkIGR1cmluZyB0aGUgZXZhbHVhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IChpLmUuIHdoZW4gcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlKS4gQnV0IHNpbmNlIHNpbmNlXG4gICAgICAgIC8vIHdlJ3JlIGJhaWxpbmcgb3V0IGVhcmx5ICp3aXRob3V0KiBldmFsdWF0aW5nIHRoZSBjb21wb25lbnQsIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYWNjb3VudCBmb3IgaXQgaGVyZSwgdG9vLiBSZXNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgZmliZXIuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgb25seSBhcHBsaWVzIHRvIFNpbXBsZU1lbW9Db21wb25lbnQsIG5vdCBNZW1vQ29tcG9uZW50LFxuICAgICAgICAvLyBiZWNhdXNlIGEgTWVtb0NvbXBvbmVudCBmaWJlciBkb2VzIG5vdCBoYXZlIGhvb2tzIG9yIGFuIHVwZGF0ZSBxdWV1ZTtcbiAgICAgICAgLy8gcmF0aGVyLCBpdCB3cmFwcyBhcm91bmQgYW4gaW5uZXIgY29tcG9uZW50LCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICAgICAgICAvLyBjb250YWlucyBob29rcy5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGUgcmVzZXQgYXQgaW4gYmVnaW5Xb3JrIG91dCBvZiB0aGUgY29tbW9uIHBhdGggc28gdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJldlN0YXRlID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG5cbiAgaWYgKG5leHRQcm9wcy5tb2RlID09PSAnaGlkZGVuJyB8fCBlbmFibGVMZWdhY3lIaWRkZW4gKSB7XG4gICAgLy8gUmVuZGVyaW5nIGEgaGlkZGVuIHRyZWUuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIGxlZ2FjeSBzeW5jIG1vZGUsIGRvbid0IGRlZmVyIHRoZSBzdWJ0cmVlLiBSZW5kZXIgaXQgbm93LlxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IG51bGxcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2UgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSkge1xuICAgICAgdmFyIHNwYXduZWRDYWNoZVBvb2wgPSBudWxsOyAvLyBXZSdyZSBoaWRkZW4sIGFuZCB3ZSdyZSBub3QgcmVuZGVyaW5nIGF0IE9mZnNjcmVlbi4gV2Ugd2lsbCBiYWlsIG91dFxuICAgICAgLy8gYW5kIHJlc3VtZSB0aGlzIHRyZWUgbGF0ZXIuXG5cbiAgICAgIHZhciBuZXh0QmFzZUxhbmVzO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2QmFzZUxhbmVzID0gcHJldlN0YXRlLmJhc2VMYW5lcztcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IG1lcmdlTGFuZXMocHJldkJhc2VMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgICAgfSAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cblxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTtcbiAgICAgIHZhciBfbmV4dFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogc3Bhd25lZENhY2hlUG9vbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgLy8gdG8gYXZvaWQgYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5cblxuICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBuZXh0QmFzZUxhbmVzKTtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIuIFRoZSBzdXJyb3VuZGluZyB2aXNpYmxlIGNvbnRlbnQgaGFzIGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gTm93IHdlIHJlc3VtZSByZW5kZXJpbmcgdGhlIGhpZGRlbiB0cmVlLlxuICAgICAgLy8gUmVuZGVyaW5nIGF0IG9mZnNjcmVlbiwgc28gd2UgY2FuIGNsZWFyIHRoZSBiYXNlIGxhbmVzLlxuICAgICAgdmFyIF9uZXh0U3RhdGUyID0ge1xuICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogbnVsbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlMjsgLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG4gICAgICB2YXIgc3VidHJlZVJlbmRlckxhbmVzID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmJhc2VMYW5lcyA6IHJlbmRlckxhbmVzO1xuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlcmluZyBhIHZpc2libGUgdHJlZS5cbiAgICB2YXIgX3N1YnRyZWVSZW5kZXJMYW5lcztcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcyk7XG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHdlcmVuJ3QgcHJldmlvdXNseSBoaWRkZW4sIGFuZCB3ZSBzdGlsbCBhcmVuJ3QsIHNvIHRoZXJlJ3Mgbm90aGluZ1xuICAgICAgLy8gc3BlY2lhbCB0byBkby4gTmVlZCB0byBwdXNoIHRvIHRoZSBzdGFjayByZWdhcmRsZXNzLCB0aG91Z2gsIHRvIGF2b2lkXG4gICAgICAvLyBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cbiAgICAgIF9zdWJ0cmVlUmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICB9XG5cbiAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIF9zdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICB9XG5cbiAge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG5cbiAgICB7XG4gICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1JlZiQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcblxuICAgIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZlN0YXRpYztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgdmFyIGhhc0lkO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIGVycm9yLlxuICAgIHN3aXRjaCAoc2hvdWxkRXJyb3Iod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7IC8vIFRPRE8gVGhpcyB3YXkgb2YgcmVzZXR0aW5nIHRoZSBlcnJvciBib3VuZGFyeSBzdGF0ZSBpcyBhIGhhY2suXG4gICAgICAgICAgLy8gSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXM/XG5cbiAgICAgICAgICB2YXIgdGVtcEluc3RhbmNlID0gbmV3IGN0b3Iod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcywgX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRlbXBJbnN0YW5jZS5zdGF0ZTtcblxuICAgICAgICAgIF9pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShfaW5zdGFuY2UsIHN0YXRlLCBudWxsKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblxuICAgICAgICAgIHZhciBlcnJvciQxID0gbmV3IEVycm9yKCdTaW11bGF0ZWQgZXJyb3IgY29taW5nIGZyb20gRGV2VG9vbHMnKTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yJDEsIHdvcmtJblByb2dyZXNzKSwgbGFuZSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCB1cGRhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlO1xuXG4gIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGNsYXNzIGNvbXBvbmVudCB3aXRob3V0IGFuIGluc3RhbmNlIG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZFxuICAgICAgLy8gaW5zaWRlIGEgbm9uLWNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvXG4gICAgICAvLyB0cmVhdCBpdCBsaWtlIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gICAgfSAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cblxuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUgJiYgaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ2EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0VW5pdE9mV29yaztcbn1cblxuZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcykge1xuICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICBtYXJrUmVmJDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlOyAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cblxuICBpZiAoaGFzQ29udGV4dCkge1xuICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gIH1cblxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZS5lbGVtZW50O1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uICYmIHByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAvLyBUaGlzIGlzIGEgaHlkcmF0aW9uIHJvb3Qgd2hvc2Ugc2hlbGwgaGFzIG5vdCB5ZXQgaHlkcmF0ZWQuIFdlIHNob3VsZFxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZS5cbiAgICAvLyBGbGlwIGlzRGVoeWRyYXRlZCB0byBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gdGhpcyByZW5kZXJcbiAgICAvLyBmaW5pc2hlcywgdGhlIHJvb3Qgd2lsbCBubyBsb25nZXIgYmUgZGVoeWRyYXRlZC5cbiAgICB2YXIgb3ZlcnJpZGVTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IG5leHRDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogZmFsc2UsXG4gICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlLFxuICAgICAgdHJhbnNpdGlvbnM6IG5leHRTdGF0ZS50cmFuc2l0aW9uc1xuICAgIH07XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIGBiYXNlU3RhdGVgIGNhbiBhbHdheXMgYmUgdGhlIGxhc3Qgc3RhdGUgYmVjYXVzZSB0aGUgcm9vdCBkb2Vzbid0XG4gICAgLy8gaGF2ZSByZWR1Y2VyIGZ1bmN0aW9ucyBzbyBpdCBkb2Vzbid0IG5lZWQgcmViYXNpbmcuXG5cbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBhIHByZXZpb3VzIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgc2hlbGwsIHNvIHdlXG4gICAgICAvLyBmb3JjZWQgYSBjbGllbnQgcmVuZGVyLlxuICAgICAgdmFyIHJlY292ZXJhYmxlRXJyb3IgPSBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcuIEJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbmVkIG91dHNpZGUgJyArICdvZiBhIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGUgZW50aXJlIHJvb3Qgd2lsbCBzd2l0Y2ggdG8gJyArICdjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgICAgcmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzLCByZWNvdmVyYWJsZUVycm9yKTtcbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPT0gcHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIgX3JlY292ZXJhYmxlRXJyb3IgPSBuZXcgRXJyb3IoJ1RoaXMgcm9vdCByZWNlaXZlZCBhbiBlYXJseSB1cGRhdGUsIGJlZm9yZSBhbnl0aGluZyB3YXMgYWJsZSAnICsgJ2h5ZHJhdGUuIFN3aXRjaGVkIHRoZSBlbnRpcmUgcm9vdCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuXG4gICAgICByZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMsIF9yZWNvdmVyYWJsZUVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG91dGVybW9zdCBzaGVsbCBoYXMgbm90IGh5ZHJhdGVkIHlldC4gU3RhcnQgaHlkcmF0aW5nLlxuICAgICAgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHZhciBjaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICAgIHZhciBub2RlID0gY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIC8vIE1hcmsgZWFjaCBjaGlsZCBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAgICAgLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuICAgICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgICAgIC8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuICAgICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgJiB+UGxhY2VtZW50IHwgSHlkcmF0aW5nO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSb290IGlzIG5vdCBkZWh5ZHJhdGVkLiBFaXRoZXIgdGhpcyBpcyBhIGNsaWVudC1vbmx5IHJvb3QsIG9yIGl0XG4gICAgLy8gYWxyZWFkeSBoeWRyYXRlZC5cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcywgcmVjb3ZlcmFibGVFcnJvcikge1xuICAvLyBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cbiAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhcyBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcyAhPT0gbnVsbCAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQSBsYXp5IGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBsYXp5Q29tcG9uZW50ID0gZWxlbWVudFR5cGU7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTsgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG5cbiAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudDtcbiAgdmFyIHJlc29sdmVkVGFnID0gd29ya0luUHJvZ3Jlc3MudGFnID0gcmVzb2x2ZUxhenlDb21wb25lbnRUYWcoQ29tcG9uZW50KTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICB2YXIgY2hpbGQ7XG5cbiAgc3dpdGNoIChyZXNvbHZlZFRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUZvcndhcmRSZWYobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgcmVzb2x2ZWRQcm9wcywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVNZW1vQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LnR5cGUsIHJlc29sdmVkUHJvcHMpLCAvLyBUaGUgaW5uZXIgdHlwZSBjYW4gaGF2ZSBkZWZhdWx0cyB0b29cbiAgICAgICAgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gIH1cblxuICB2YXIgaGludCA9ICcnO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgfVxuICB9IC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgLy8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW5cbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiBcIiArIENvbXBvbmVudCArIFwiLiBcIiArIChcIkxhenkgZWxlbWVudCB0eXBlIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLlwiICsgaGludCkpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBpbmNvbXBsZXRlIGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH0gLy8gUHJvbW90ZSB0aGUgZmliZXIgdG8gYSBjbGFzcyBhbmQgdHJ5IHJlbmRlcmluZyBhZ2Fpbi5cblxuXG4gIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50OyAvLyBUaGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgZm9yayBvZiBgdXBkYXRlQ2xhc3NDb21wb25lbnRgXG4gIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgY29udGV4dDtcblxuICB7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBmYWxzZSk7XG4gICAgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciBoYXNJZDtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG5cblxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50OyAvLyBUaHJvdyBvdXQgYW55IGhvb2tzIHRoYXQgd2VyZSB1c2VkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsOyAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cbiAgICB2YXIgaGFzQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gdmFsdWUuc3RhdGUgIT09IG51bGwgJiYgdmFsdWUuc3RhdGUgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnN0YXRlIDogbnVsbDtcbiAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGdW5jdGlvbkNvbXBvbmVudDtcblxuICAgIHtcblxuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihudWxsLCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUsIHJlbmRlckxhbmVzKTtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAge1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIGlmIChDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuXG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cblxuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgJyc7XG4gICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG5cbiAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHVzZSBSZWFjdC5mb3J3YXJkUmVmKCk/JXMnLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgdHJlZUNvbnRleHQ6IG51bGwsXG4gIHJldHJ5TGFuZTogTm9MYW5lXG59O1xuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLFxuICAgIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNhY2hlUG9vbCA9IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IG1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpLFxuICAgIGNhY2hlUG9vbDogY2FjaGVQb29sXG4gIH07XG59IC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCBpbmxpbmUgdGhpcyBiYWNrXG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG9cbiAgLy8gcmVtYWluIG9uIHRoYXQgZmFsbGJhY2sgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb250ZW50IGhhcyByZXNvbHZlZC5cbiAgLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgcmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxuICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuICAgICAgLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbiAgICAgIC8vIEF2b2lkZWQgYm91bmRhcmllcyBhcmUgbm90IGNvbnNpZGVyZWQgc2luY2UgdGhleSBjYW5ub3QgaGFuZGxlIHByZWZlcnJlZCBmYWxsYmFjayBzdGF0ZXMuXG4gICAgICB7XG4gICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7IC8vIE9LLCB0aGUgbmV4dCBwYXJ0IGlzIGNvbmZ1c2luZy4gV2UncmUgYWJvdXQgdG8gcmVjb25jaWxlIHRoZSBTdXNwZW5zZVxuICAvLyBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGlzIGludm9sdmVzIHNvbWUgY3VzdG9tIHJlY29uY2lsaWF0aW9uIGxvZ2ljLiBUd29cbiAgLy8gbWFpbiByZWFzb25zIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQuXG4gIC8vXG4gIC8vIEZpcnN0LCBMZWdhY3kgTW9kZSBoYXMgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZVxuICAvLyBwcmltYXJ5IHRyZWUgd2lsbCBjb21taXQgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLCBzbyB3aGVuIHdlIGRvIHRoZVxuICAvLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG4gIC8vIGhhY2tzIHRvIG1ha2UgdGhhdCBub3QgdG90YWxseSBicmVhay4gTGlrZSB0cmFuc2ZlcnJpbmcgZWZmZWN0cyBhbmRcbiAgLy8gZGVsZXRpb25zIGZyb20gaGlkZGVuIHRyZWUuIEluIENvbmN1cnJlbnQgTW9kZSwgaXQncyBtdWNoIHNpbXBsZXIsXG4gIC8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcbiAgLy8gc3RhdGUsIG5vIGVmZmVjdHMuIFNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgT2Zmc2NyZWVuIChleGNlcHQgdGhhdFxuICAvLyBPZmZzY3JlZW4gZG9lc24ndCBoYXZlIHRoZSBmaXJzdCByZW5kZXIgcGFzcykuXG4gIC8vXG4gIC8vIFNlY29uZCBpcyBoeWRyYXRpb24uIER1cmluZyBoeWRyYXRpb24sIHRoZSBTdXNwZW5zZSBmaWJlciBoYXMgYSBzbGlnaHRseVxuICAvLyBkaWZmZXJlbnQgbGF5b3V0LCB3aGVyZSB0aGUgY2hpbGQgcG9pbnRzIHRvIGEgZGVoeWRyYXRlZCBmcmFnbWVudCwgd2hpY2hcbiAgLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuICAvL1xuICAvLyBUaGlyZCwgZXZlbiBpZiB5b3Ugc2V0IGFsbCB0aGF0IGFzaWRlLCBTdXNwZW5zZSBpcyBsaWtlIGVycm9yIGJvdW5kYXJpZXMgaW5cbiAgLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG4gIC8vIGFuZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHJlZS4gTGlrZSBhIHRyeS9jYXRjaCBibG9jay4gU28gd2UgaGF2ZSB0byB0cmFja1xuICAvLyB3aGljaCBicmFuY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZy4gSWRlYWxseSB3ZSB3b3VsZCBtb2RlbCB0aGlzIHVzaW5nXG4gIC8vIGEgc3RhY2suXG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgY291bGQndmUgYmVlbiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuXG4gICAge1xuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVoeWRyYXRlZCA9IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcywgZGVoeWRyYXRlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICB2YXIgZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrRnJhZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgZmliZXIgaGFzIGEgU3VzcGVuc2VTdGF0ZSwgdGhhdCBtZWFucyBpdCdzIGFscmVhZHkgc2hvd2luZ1xuICAgIC8vIGEgZmFsbGJhY2suXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2tcbiAgICAgIC8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG4gICAgICB7XG4gICAgICAgIHZhciBfZGVoeWRyYXRlZCA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChfZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZGlkU3VzcGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX2RlaHlkcmF0ZWQsIHByZXZTdGF0ZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVHJ5IGFnYWluIHdpdGhvdXQgaHlkcmF0aW5nLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkZvcmNlQ2xpZW50UmVuZGVyO1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIHRoaXMgU3VzcGVuc2UgYm91bmRhcnkuICcgKyAnU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy4nKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFuZCB3ZSBzaG91bGQgc3RpbGwgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgICAgICAgLy8gTGVhdmUgdGhlIGV4aXN0aW5nIGNoaWxkIGluIHBsYWNlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBUaGUgZGVoeWRyYXRlZCBjb21wbGV0aW9uIHBhc3MgZXhwZWN0cyB0aGlzIGZsYWcgdG8gYmUgdGhlcmVcbiAgICAgICAgICAgIC8vIGJ1dCB0aGUgbm9ybWFsIHN1c3BlbnNlIHBhc3MgZG9lc24ndC5cblxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdXNwZW5kZWQgYnV0IHdlIHNob3VsZCBubyBsb25nZXIgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5vdyBoYXZlIHRvIHJlbmRlciB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbiwgX25leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MiA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuMiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4yLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICAvLyBUaW1lZCBvdXQuXG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW40ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW40LCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIF9wcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUubWVtb2l6ZWRTdGF0ZSA9IF9wcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShfcHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTsgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICByZXR1cm4gX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBoYXZlbid0IHRpbWVkIG91dC4gQ29udGludWUgcmVuZGVyaW5nIHRoZSBjaGlsZHJlbiwgbGlrZSB3ZVxuICAgICAgICAvLyBub3JtYWxseSBkby5cbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NiA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjUsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDY7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlKTtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKChtb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIC8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBjb21taXQgdGhlIHByaW1hcnkgdHJlZSBhcyBpZiBpdCBzdWNjZXNzZnVsbHlcbiAgICAvLyBjb21wbGV0ZWQsIGV2ZW4gdGhvdWdoIGl0J3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLlxuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbiAgICAgIC8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4gICAgICAvLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlKTtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIH1cblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlXG4gIC8vIHRoaXMgd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIE5vTGFuZXMsIG51bGwpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKSB7XG4gIC8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlV29ya0luUHJvZ3Jlc3NgIGlzIGBhbnlgIHR5cGVkLCBzbyB3ZSB1c2UgdGhpc1xuICAvLyB3cmFwcGVyIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiBpdC5cbiAgcmV0dXJuIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfSk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBudWxsO1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuICAgIHZhciBkZWxldGlvbnMgPSB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM7XG5cbiAgICBpZiAoZGVsZXRpb25zID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBbY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudF07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDaGlsZERlbGV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGlvbnMucHVzaChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50KTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKCAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gIChtb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgLy8gTWFrZSBzdXJlIHdlJ3JlIG9uIHRoZSBzZWNvbmQgcGFzcywgaS5lLiB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCB3YXNcbiAgLy8gYWxyZWFkeSBjbG9uZWQuIEluIGxlZ2FjeSBtb2RlLCB0aGUgb25seSBjYXNlIHdoZXJlIHRoaXMgaXNuJ3QgdHJ1ZSBpc1xuICAvLyB3aGVuIERldlRvb2xzIGZvcmNlcyB1cyB0byBkaXNwbGF5IGEgZmFsbGJhY2s7IHdlIHNraXAgdGhlIGZpcnN0IHJlbmRlclxuICAvLyBwYXNzIGVudGlyZWx5IGFuZCBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgdGhlIGZhbGxiYWNrLiAoSW4gQ29uY3VycmVudFxuICAvLyBNb2RlLCBTdXNwZW5zZUxpc3QgY2FuIGFsc28gdHJpZ2dlciB0aGlzIHNjZW5hcmlvLCBidXQgdGhpcyBpcyBhIGxlZ2FjeS1cbiAgLy8gb25seSBjb2RlcGF0aC4pXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQpIHtcbiAgICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbiAgICAgIC8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4gICAgICAvLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG4gICAgLy8gSG93ZXZlciwgc2luY2Ugd2UncmUgZ29pbmcgdG8gcmVtYWluIG9uIHRoZSBmYWxsYmFjaywgd2Ugbm8gbG9uZ2VyIHdhbnRcbiAgICAvLyB0byBkZWxldGUgaXQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwgcHJpbWFyeUNoaWxkUHJvcHMpO1xuICAgIC8vIChXZSBkb24ndCBkbyB0aGlzIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGluIGxlZ2FjeSBtb2RlIHdlIGRvbid0IHJlLXVzZVxuICAgIC8vIHRoZSBjdXJyZW50IHRyZWU7IHNlZSBwcmV2aW91cyBicmFuY2guKVxuXG5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3MgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LCBmYWxsYmFja0NoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAgIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCByZWNvdmVyYWJsZUVycm9yKSB7XG4gIC8vIEZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLiBCZWNhdXNlIHRoaXMgaGFzIHBlcmZvcm1hbmNlXG4gIC8vIGltcGxpY2F0aW9ucywgaXQncyBjb25zaWRlcmVkIGEgcmVjb3ZlcmFibGUgZXJyb3IsIGV2ZW4gdGhvdWdoIHRoZSB1c2VyXG4gIC8vIGxpa2VseSB3b24ndCBvYnNlcnZlIGFueXRoaW5nIHdyb25nIHdpdGggdGhlIFVJLlxuICAvL1xuICAvLyBUaGUgZXJyb3IgaXMgcGFzc2VkIGluIGFzIGFuIGFyZ3VtZW50IHRvIGVuZm9yY2UgdGhhdCBldmVyeSBjYWxsZXIgcHJvdmlkZVxuICAvLyBhIGN1c3RvbSBtZXNzYWdlLCBvciBleHBsaWNpdGx5IG9wdCBvdXQgKGN1cnJlbnRseSB0aGUgb25seSBwYXRoIHRoYXQgb3B0c1xuICAvLyBvdXQgaXMgbGVnYWN5IG1vZGU7IGV2ZXJ5IGNvbmN1cnJlbnQgcGF0aCBwcm92aWRlcyBhbiBlcnJvcikuXG4gIGlmIChyZWNvdmVyYWJsZUVycm9yICE9PSBudWxsKSB7XG4gICAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcbiAgfSAvLyBUaGlzIHdpbGwgYWRkIHRoZSBvbGQgZmliZXIgdG8gdGhlIGRlbGV0aW9uIGxpc3RcblxuXG4gIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7IC8vIFdlJ3JlIG5vdyBub3Qgc3VzcGVuZGVkIG5vciBkZWh5ZHJhdGVkLlxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbik7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGZpYmVyTW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsIGZpYmVyTW9kZSk7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBmaWJlck1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5KSBhbHJlYWR5IG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSkge1xuICAgIC8vIFdlIHdpbGwgaGF2ZSBkcm9wcGVkIHRoZSBlZmZlY3QgbGlzdCB3aGljaCBjb250YWlucyB0aGVcbiAgICAvLyBkZWxldGlvbi4gV2UgbmVlZCB0byByZWNvbmNpbGUgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VJbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gRHVyaW5nIHRoZSBmaXJzdCBwYXNzLCB3ZSdsbCBiYWlsIG91dCBhbmQgbm90IGRyaWxsIGludG8gdGhlIGNoaWxkcmVuLlxuICAvLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB0aGUgY29udGVudCBpbiBwbGFjZSBhbmQgdHJ5IHRvIGh5ZHJhdGUgaXQgbGF0ZXIuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ0Nhbm5vdCBoeWRyYXRlIFN1c3BlbnNlIGluIGxlZ2FjeSBtb2RlLiBTd2l0Y2ggZnJvbSAnICsgJ1JlYWN0RE9NLmh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyKSB0byAnICsgJ1JlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGNvbnRhaW5lciwgPEFwcCAvPiknICsgJy5yZW5kZXIoZWxlbWVudCkgb3IgcmVtb3ZlIHRoZSBTdXNwZW5zZSBjb21wb25lbnRzIGZyb20gJyArICd0aGUgc2VydmVyIHJlbmRlcmVkIGNvbXBvbmVudHMuJyk7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhTeW5jTGFuZSk7XG4gIH0gZWxzZSBpZiAoaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAvLyBUaGlzIGlzIGEgY2xpZW50LW9ubHkgYm91bmRhcnkuIFNpbmNlIHdlIHdvbid0IGdldCBhbnkgY29udGVudCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAvLyBmb3IgdGhpcywgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGF0IGF0IGEgaGlnaGVyIHByaW9yaXR5IGJhc2VkIG9uIHdoZW4gaXQgd291bGRcbiAgICAvLyBoYXZlIHRpbWVkIG91dC4gSW4gdGhlb3J5IHdlIGNvdWxkIHJlbmRlciBpdCBpbiB0aGlzIHBhc3MgYnV0IGl0IHdvdWxkIGhhdmUgdGhlXG4gICAgLy8gd3JvbmcgcHJpb3JpdHkgYXNzb2NpYXRlZCB3aXRoIGl0IGFuZCB3aWxsIHByZXZlbnQgaHlkcmF0aW9uIG9mIHBhcmVudCBwYXRoLlxuICAgIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHdvcmsgbGVmdCBvbiBpdCB0byByZW5kZXIgaXQgaW4gYSBzZXBhcmF0ZSBjb21taXQuXG4gICAgLy8gVE9ETyBUaGlzIHRpbWUgc2hvdWxkIGJlIHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgcmVzcG9uc2UgdGhhdCBpc1xuICAgIC8vIGEgcGFyZW50IHRvIHRoaXMgYm91bmRhcnkgd2FzIGRpc3BsYXllZC4gSG93ZXZlciwgc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IGhhdmVcbiAgICAvLyBhIHByb3RvY29sIHRvIHRyYW5zZmVyIHRoYXQgdGltZSwgd2UnbGwganVzdCBlc3RpbWF0ZSBpdCBieSB1c2luZyB0aGUgY3VycmVudFxuICAgIC8vIHRpbWUuIFRoaXMgd2lsbCBtZWFuIHRoYXQgU3VzcGVuc2UgdGltZW91dHMgYXJlIHNsaWdodGx5IHNoaWZ0ZWQgdG8gbGF0ZXIgdGhhblxuICAgIC8vIHRoZXkgc2hvdWxkIGJlLlxuICAgIC8vIFNjaGVkdWxlIGEgbm9ybWFsIHByaSB1cGRhdGUgdG8gcmVuZGVyIHRoaXMgY29udGVudC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhbmVUb0xhbmVzKERlZmF1bHRIeWRyYXRpb25MYW5lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSdsbCBjb250aW51ZSBoeWRyYXRpbmcgdGhlIHJlc3QgYXQgb2Zmc2NyZWVuIHByaW9yaXR5IHNpbmNlIHdlJ2xsIGFscmVhZHlcbiAgICAvLyBiZSBzaG93aW5nIHRoZSByaWdodCBjb250ZW50IGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXIsIGl0IGlzIG5vIHJ1c2guXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFdlIHNob3VsZCBuZXZlciBiZSBoeWRyYXRpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IGlzIHRoZSBmaXJzdCBwYXNzLFxuICAvLyBidXQgYWZ0ZXIgd2UndmUgYWxyZWFkeSBjb21taXR0ZWQgb25jZS5cbiAgd2FybklmSHlkcmF0aW5nKCk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCAvLyBUT0RPOiBXaGVuIHdlIGRlbGV0ZSBsZWdhY3kgbW9kZSwgd2Ugc2hvdWxkIG1ha2UgdGhpcyBlcnJvciBhcmd1bWVudFxuICAgIC8vIHJlcXVpcmVkIOKAlCBldmVyeSBjb25jdXJyZW50IG1vZGUgcGF0aCB0aGF0IGNhdXNlcyBoeWRyYXRpb24gdG9cbiAgICAvLyBkZS1vcHQgdG8gY2xpZW50IHJlbmRlcmluZyBzaG91bGQgaGF2ZSBhbiBlcnJvciBtZXNzYWdlLlxuICAgIG51bGwpO1xuICB9XG5cbiAgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgLy8gVGhpcyBib3VuZGFyeSBpcyBpbiBhIHBlcm1hbmVudCBmYWxsYmFjayBzdGF0ZS4gSW4gdGhpcyBjYXNlLCB3ZSdsbCBuZXZlclxuICAgIC8vIGdldCBhbiB1cGRhdGUgYW5kIHdlJ2xsIG5ldmVyIGJlIGFibGUgdG8gaHlkcmF0ZSB0aGUgZmluYWwgY29udGVudC4gTGV0J3MganVzdCB0cnkgdGhlXG4gICAgLy8gY2xpZW50IHNpZGUgcmVuZGVyIGluc3RlYWQuXG4gICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgLy8gVE9ETzogVGhlIHNlcnZlciBzaG91bGQgc2VyaWFsaXplIHRoZSBlcnJvciBtZXNzYWdlIHNvIHdlIGNhbiBsb2cgaXRcbiAgICAvLyBoZXJlIG9uIHRoZSBjbGllbnQuIE9yLCBpbiBwcm9kdWN0aW9uLCBhIGhhc2gvaWQgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAgIC8vIHRoZSBlcnJvci5cbiAgICBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgY291bGQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LCBsaWtlbHkgJyArICdkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuIFN3aXRjaGVkIHRvICcgKyAnY2xpZW50IHJlbmRlcmluZy4nKSk7XG4gIH1cbiAgLy8gYW55IGNvbnRleHQgaGFzIGNoYW5nZWQsIHdlIG5lZWQgdG8gdHJlYXQgaXMgYXMgaWYgdGhlIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZC5cblxuXG4gIHZhciBoYXNDb250ZXh0Q2hhbmdlZCA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIGN1cnJlbnQuY2hpbGRMYW5lcyk7XG5cbiAgaWYgKGRpZFJlY2VpdmVVcGRhdGUgfHwgaGFzQ29udGV4dENoYW5nZWQpIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBmaXJzdCByZW5kZXIuIFRoaXMgbWVhbnMgdGhhdCB3ZSBhcmUgbm93IHVuYWJsZSB0b1xuICAgIC8vIGh5ZHJhdGUgaXQuIFdlIG1pZ2h0IHN0aWxsIGJlIGFibGUgdG8gaHlkcmF0ZSBpdCB1c2luZyBhIGhpZ2hlciBwcmlvcml0eSBsYW5lLlxuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKGF0dGVtcHRIeWRyYXRpb25BdExhbmUgIT09IE5vTGFuZSAmJiBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lICE9PSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IG11dGF0aW5nIHNpbmNlIHRoaXMgcmVuZGVyIHdpbGwgZ2V0IGludGVycnVwdGVkLiBUaGlzXG4gICAgICAgIC8vIGlzIG9uZSBvZiB0aGUgdmVyeSByYXJlIHRpbWVzIHdoZXJlIHdlIG11dGF0ZSB0aGUgY3VycmVudCB0cmVlXG4gICAgICAgIC8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSA9IGF0dGVtcHRIeWRyYXRpb25BdExhbmU7IC8vIFRPRE86IElkZWFsbHkgdGhpcyB3b3VsZCBpbmhlcml0IHRoZSBldmVudCB0aW1lIG9mIHRoZSBjdXJyZW50IHJlbmRlclxuXG4gICAgICAgIHZhciBldmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGN1cnJlbnQsIGF0dGVtcHRIeWRyYXRpb25BdExhbmUsIGV2ZW50VGltZSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiB3ZSBoYXZlIHNjaGVkdWxlZCBoaWdoZXIgcHJpIHdvcmsgYWJvdmUsIHRoaXMgd2lsbCBwcm9iYWJseSBqdXN0IGFib3J0IHRoZSByZW5kZXJcbiAgICAvLyBzaW5jZSB3ZSBub3cgaGF2ZSBoaWdoZXIgcHJpb3JpdHkgd29yaywgYnV0IGluIGNhc2UgaXQgZG9lc24ndCwgd2UgbmVlZCB0byBwcmVwYXJlIHRvXG4gICAgLy8gcmVuZGVyIHNvbWV0aGluZywgaWYgd2UgdGltZSBvdXQuIEV2ZW4gaWYgdGhhdCByZXF1aXJlcyB1cyB0byBkZWxldGUgZXZlcnl0aGluZyBhbmRcbiAgICAvLyBza2lwIGh5ZHJhdGlvbi5cbiAgICAvLyBEZWxheSBoYXZpbmcgdG8gZG8gdGhpcyBhcyBsb25nIGFzIHRoZSBzdXNwZW5zZSB0aW1lb3V0IGFsbG93cyB1cy5cblxuXG4gICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIG5ldyBFcnJvcignVGhpcyBTdXNwZW5zZSBib3VuZGFyeSByZWNlaXZlZCBhbiB1cGRhdGUgYmVmb3JlIGl0IGZpbmlzaGVkICcgKyAnaHlkcmF0aW5nLiBUaGlzIGNhdXNlZCB0aGUgYm91bmRhcnkgdG8gc3dpdGNoIHRvIGNsaWVudCByZW5kZXJpbmcuICcgKyAnVGhlIHVzdWFsIHdheSB0byBmaXggdGhpcyBpcyB0byB3cmFwIHRoZSBvcmlnaW5hbCB1cGRhdGUgJyArICdpbiBzdGFydFRyYW5zaXRpb24uJykpO1xuICB9IGVsc2UgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyBzdGlsbCBwZW5kaW5nIG1vcmUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGNhbid0IGh5ZHJhdGUgaXRzXG4gICAgLy8gY29udGVudC4gV2UgdHJlYXQgaXQgYXMgaWYgdGhpcyBjb21wb25lbnQgc3VzcGVuZGVkIGl0c2VsZi4gSXQgbWlnaHQgc2VlbSBhcyBpZlxuICAgIC8vIHdlIGNvdWxkIGp1c3QgdHJ5IHRvIHJlbmRlciBpdCBjbGllbnQtc2lkZSBpbnN0ZWFkLiBIb3dldmVyLCB0aGlzIHdpbGwgcGVyZm9ybSBhXG4gICAgLy8gbG90IG9mIHVubmVjZXNzYXJ5IHdvcmsgYW5kIGlzIHVubGlrZWx5IHRvIGNvbXBsZXRlIHNpbmNlIGl0IG9mdGVuIHdpbGwgc3VzcGVuZFxuICAgIC8vIG9uIG1pc3NpbmcgZGF0YSBhbnl3YXkuIEFkZGl0aW9uYWxseSwgdGhlIHNlcnZlciBtaWdodCBiZSBhYmxlIHRvIHJlbmRlciBtb3JlXG4gICAgLy8gdGhhbiB3ZSBjYW4gb24gdGhlIGNsaWVudCB5ZXQuIEluIHRoYXQgY2FzZSB3ZSdkIGVuZCB1cCB3aXRoIG1vcmUgZmFsbGJhY2sgc3RhdGVzXG4gICAgLy8gb24gdGhlIGNsaWVudCB0aGFuIGlmIHdlIGp1c3QgbGVhdmUgaXQgYWxvbmUuIElmIHRoZSBzZXJ2ZXIgdGltZXMgb3V0IG9yIGVycm9yc1xuICAgIC8vIHRoZXNlIHNob3VsZCB1cGRhdGUgdGhpcyBib3VuZGFyeSB0byB0aGUgcGVybWFuZW50IEZhbGxiYWNrIHN0YXRlIGluc3RlYWQuXG4gICAgLy8gTWFyayBpdCBhcyBoYXZpbmcgY2FwdHVyZWQgKGkuZS4gc3VzcGVuZGVkKS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlOyAvLyBMZWF2ZSB0aGUgY2hpbGQgaW4gcGxhY2UuIEkuZS4gdGhlIGRlaHlkcmF0ZWQgZnJhZ21lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gcmV0cnkgdGhpcyBib3VuZGFyeSBvbmNlIHRoZSBzZXJ2ZXIgaGFzIHNlbnQgdGhlIHJlc3VsdC5cblxuICAgIHZhciByZXRyeSA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChudWxsLCBjdXJyZW50KTtcbiAgICByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShzdXNwZW5zZUluc3RhbmNlLCByZXRyeSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAgICByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUudHJlZUNvbnRleHQpO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pOyAvLyBNYXJrIHRoZSBjaGlsZHJlbiBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4gICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFncyB8PSBIeWRyYXRpbmc7XG4gICAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KTtcbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBmaXJzdENoaWxkLCByZW5kZXJMYW5lcykge1xuICAvLyBNYXJrIGFueSBTdXNwZW5zZSBib3VuZGFyaWVzIHdpdGggZmFsbGJhY2tzIGFzIGhhdmluZyB3b3JrIHRvIGRvLlxuICAvLyBJZiB0aGV5IHdlcmUgcHJldmlvdXNseSBmb3JjZWQgaW50byBmYWxsYmFja3MsIHRoZXkgbWF5IG5vdyBiZSBhYmxlXG4gIC8vIHRvIHVuYmxvY2suXG4gIHZhciBub2RlID0gZmlyc3RDaGlsZDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCkge1xuICAgICAgLy8gSWYgdGhlIHRhaWwgaXMgaGlkZGVuIHRoZXJlIG1pZ2h0IG5vdCBiZSBhbiBTdXNwZW5zZSBib3VuZGFyaWVzXG4gICAgICAvLyB0byBzY2hlZHVsZSB3b3JrIG9uLiBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBvbiB0aGVcbiAgICAgIC8vIGxpc3QgaXRzZWxmLlxuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byB0cmF2ZXJzZSB0byB0aGUgY2hpbGRyZW4gb2YgdGhlIGxpc3Qgc2luY2VcbiAgICAgIC8vIHRoZSBsaXN0IHdpbGwgcHJvcGFnYXRlIHRoZSBjaGFuZ2Ugd2hlbiBpdCByZXJlbmRlcnMuXG4gICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTGFzdENvbnRlbnRSb3coZmlyc3RDaGlsZCkge1xuICAvLyBUaGlzIGlzIGdvaW5nIHRvIGZpbmQgdGhlIGxhc3Qgcm93IGFtb25nIHRoZXNlIGNoaWxkcmVuIHRoYXQgaXMgYWxyZWFkeVxuICAvLyBzaG93aW5nIGNvbnRlbnQgb24gdGhlIHNjcmVlbiwgYXMgb3Bwb3NlZCB0byBiZWluZyBpbiBmYWxsYmFjayBzdGF0ZSBvclxuICAvLyBuZXcuIElmIGEgcm93IGhhcyBtdWx0aXBsZSBTdXNwZW5zZSBib3VuZGFyaWVzLCBhbnkgb2YgdGhlbSBiZWluZyBpbiB0aGVcbiAgLy8gZmFsbGJhY2sgc3RhdGUsIGNvdW50cyBhcyB0aGUgd2hvbGUgcm93IGJlaW5nIGluIGEgZmFsbGJhY2sgc3RhdGUuXG4gIC8vIE5vdGUgdGhhdCB0aGUgXCJyb3dzXCIgd2lsbCBiZSB3b3JrSW5Qcm9ncmVzcywgYnV0IGFueSBuZXN0ZWQgY2hpbGRyZW5cbiAgLy8gd2lsbCBzdGlsbCBiZSBjdXJyZW50IHNpbmNlIHdlIGhhdmVuJ3QgcmVuZGVyZWQgdGhlbSB5ZXQuIFRoZSBtb3VudGVkXG4gIC8vIG9yZGVyIG1heSBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG5ldyBvcmRlci4gV2UgdXNlIHRoZSBuZXcgb3JkZXIuXG4gIHZhciByb3cgPSBmaXJzdENoaWxkO1xuICB2YXIgbGFzdENvbnRlbnRSb3cgPSBudWxsO1xuXG4gIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgbGFzdENvbnRlbnRSb3cgPSByb3c7XG4gICAgfVxuXG4gICAgcm93ID0gcm93LnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbGFzdENvbnRlbnRSb3c7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmIChyZXZlYWxPcmRlciAhPT0gdW5kZWZpbmVkICYmIHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ3RvZ2V0aGVyJyAmJiAhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdKSB7XG4gICAgICBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0gPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIHJldmVhbE9yZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICd0b2dldGhlcic6XG4gICAgICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnVXNlIGxvd2VyY2FzZSBcIiVzXCIgaW5zdGVhZC4nLCByZXZlYWxPcmRlciwgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnUmVhY3QgdXNlcyB0aGUgLXMgc3VmZml4IGluIHRoZSBzcGVsbGluZy4gVXNlIFwiJXNzXCIgaW5zdGVhZC4nLCByZXZlYWxPcmRlciwgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICh0YWlsTW9kZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0pIHtcbiAgICAgIGlmICh0YWlsTW9kZSAhPT0gJ2NvbGxhcHNlZCcgJiYgdGFpbE1vZGUgIT09ICdoaWRkZW4nKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJjb2xsYXBzZWRcIiBvciBcImhpZGRlblwiPycsIHRhaWxNb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAocmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJzxTdXNwZW5zZUxpc3QgdGFpbD1cIiVzXCIgLz4gaXMgb25seSB2YWxpZCBpZiByZXZlYWxPcmRlciBpcyAnICsgJ1wiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LCBpbmRleCkge1xuICB7XG4gICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXkoY2hpbGRTbG90KTtcbiAgICB2YXIgaXNJdGVyYWJsZSA9ICFpc0FuQXJyYXkgJiYgdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmIChpc0FuQXJyYXkgfHwgaXNJdGVyYWJsZSkge1xuICAgICAgdmFyIHR5cGUgPSBpc0FuQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuICAgICAgZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcgKyAnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJyArICc8L1N1c3BlbnNlTGlzdD4nLCB0eXBlLCBpbmRleCwgdHlwZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbiwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjaGlsZHJlbkl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIF9pID0gMDtcblxuICAgICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcgKyAnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaXNCYWNrd2FyZHMsIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSkge1xuICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWw6IHRhaWwsXG4gICAgICB0YWlsTW9kZTogdGFpbE1vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGNhbiByZXVzZSB0aGUgZXhpc3Rpbmcgb2JqZWN0IGZyb20gcHJldmlvdXMgcmVuZGVycy5cbiAgICByZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMDtcbiAgICByZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3c7XG4gICAgcmVuZGVyU3RhdGUudGFpbCA9IHRhaWw7XG4gICAgcmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZTtcbiAgfVxufSAvLyBUaGlzIGNhbiBlbmQgdXAgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IG11bHRpcGxlIHBhc3Nlcy5cbi8vIFRoZSBmaXJzdCBwYXNzIHNwbGl0cyB0aGUgY2hpbGRyZW4gZmliZXJzIGludG8gdHdvIHNldHMuIEEgaGVhZCBhbmQgdGFpbC5cbi8vIFdlIGZpcnN0IHJlbmRlciB0aGUgaGVhZC4gSWYgYW55dGhpbmcgaXMgaW4gZmFsbGJhY2sgc3RhdGUsIHdlIGRvIGFub3RoZXJcbi8vIHBhc3MgdGhyb3VnaCBiZWdpbldvcmsgdG8gcmVyZW5kZXIgYWxsIGNoaWxkcmVuIChpbmNsdWRpbmcgdGhlIHRhaWwpIHdpdGhcbi8vIHRoZSBmb3JjZSBzdXNwZW5kIGNvbnRleHQuIElmIHRoZSBmaXJzdCByZW5kZXIgZGlkbid0IGhhdmUgYW55dGhpbmcgaW5cbi8vIGluIGZhbGxiYWNrIHN0YXRlLiBUaGVuIHdlIHJlbmRlciBlYWNoIHJvdyBpbiB0aGUgdGFpbCBvbmUtYnktb25lLlxuLy8gVGhhdCBoYXBwZW5zIGluIHRoZSBjb21wbGV0ZVdvcmsgcGhhc2Ugd2l0aG91dCBnb2luZyBiYWNrIHRvIGJlZ2luV29yay5cblxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcjtcbiAgdmFyIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWw7XG4gIHZhciBuZXdDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKTtcbiAgdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihuZXdDaGlsZHJlbiwgcmV2ZWFsT3JkZXIpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3VsZEZvcmNlRmFsbGJhY2sgPSBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuXG4gIGlmIChzaG91bGRGb3JjZUZhbGxiYWNrKSB7XG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcbiAgICAgIC8vIG9uIGFueSBuZXN0ZWQgYm91bmRhcmllcyB0byBsZXQgdGhlbSBrbm93IHRvIHRyeSB0byByZW5kZXJcbiAgICAgIC8vIGFnYWluLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNvbnRleHQgdXBkYXRpbmcuXG4gICAgICBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgfVxuXG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAvLyBJbiBsZWdhY3kgbW9kZSwgU3VzcGVuc2VMaXN0IGRvZXNuJ3Qgd29yayBzbyB3ZSBqdXN0XG4gICAgLy8gdXNlIG1ha2UgaXQgYSBub29wIGJ5IHRyZWF0aW5nIGl0IGFzIHRoZSBkZWZhdWx0IHJldmVhbE9yZGVyLlxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIpIHtcbiAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXN0Q29udGVudFJvdyA9IGZpbmRMYXN0Q29udGVudFJvdyh3b3JrSW5Qcm9ncmVzcy5jaGlsZCk7XG4gICAgICAgICAgdmFyIHRhaWw7XG5cbiAgICAgICAgICBpZiAobGFzdENvbnRlbnRSb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBsaXN0IGlzIHBhcnQgb2YgdGhlIHRhaWwuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBjb3VsZCBmYXN0IHBhdGggYnkganVzdCByZW5kZXJpbmcgdGhlIHRhaWwgbm93LlxuICAgICAgICAgICAgdGFpbCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSB0YWlsIHJvd3MgYWZ0ZXIgdGhlIGNvbnRlbnQgcm93LlxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZW0gc2VwYXJhdGVseSBsYXRlci5cbiAgICAgICAgICAgIHRhaWwgPSBsYXN0Q29udGVudFJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgbGFzdENvbnRlbnRSb3cuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICB0YWlsLCBsYXN0Q29udGVudFJvdywgdGFpbE1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBmaW5kIHRoZSBmaXJzdCByb3cgdGhhdCBoYXMgZXhpc3RpbmcgY29udGVudC5cbiAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIGdvaW5nIHRvIHJldmVyc2UgdGhlIGxpc3Qgb2YgZXZlcnl0aGluZ1xuICAgICAgICAgIC8vIHdlIHBhc3MgaW4gdGhlIG1lYW50aW1lLiBUaGF0J3MgZ29pbmcgdG8gYmUgb3VyIHRhaWwgaW4gcmV2ZXJzZVxuICAgICAgICAgIC8vIG9yZGVyLlxuICAgICAgICAgIHZhciBfdGFpbCA9IG51bGw7XG4gICAgICAgICAgdmFyIHJvdyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcblxuICAgICAgICAgIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYWluIGNvbnRlbnQuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcm93O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHRSb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgIHJvdy5zaWJsaW5nID0gX3RhaWw7XG4gICAgICAgICAgICBfdGFpbCA9IHJvdztcbiAgICAgICAgICAgIHJvdyA9IG5leHRSb3c7XG4gICAgICAgICAgfSAvLyBUT0RPOiBJZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBpcyBudWxsLCB3ZSBjYW4gY29udGludWUgb24gdGhlIHRhaWwgaW1tZWRpYXRlbHkuXG5cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBfdGFpbCwgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHRhaWxNb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICd0b2dldGhlcic6XG4gICAgICAgIHtcbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIG51bGwsIC8vIHRhaWxcbiAgICAgICAgICBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGRlZmF1bHQgcmV2ZWFsIG9yZGVyIGlzIHRoZSBzYW1lIGFzIG5vdCBoYXZpbmdcbiAgICAgICAgICAvLyBhIGJvdW5kYXJ5LlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHByb3ZpZGVyVHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJUeXBlLl9jb250ZXh0O1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuXG4gIHtcbiAgICBpZiAoISgndmFsdWUnIGluIG5ld1Byb3BzKSkge1xuICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlcikge1xuICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1RoZSBgdmFsdWVgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgPENvbnRleHQuUHJvdmlkZXI+YC4gRGlkIHlvdSBtaXNzcGVsbCBpdCBvciBmb3JnZXQgdG8gcGFzcyBpdD8nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvdmlkZXJQcm9wVHlwZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3BUeXBlcztcblxuICAgIGlmIChwcm92aWRlclByb3BUeXBlcykge1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvdmlkZXJQcm9wVHlwZXMsIG5ld1Byb3BzLCAncHJvcCcsICdDb250ZXh0LlByb3ZpZGVyJyk7XG4gICAgfVxuICB9XG5cbiAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBuZXdWYWx1ZSk7XG5cbiAge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZFZhbHVlID0gb2xkUHJvcHMudmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgIC8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG4gICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgICAgLy8gdGhlbSB0byB1cGRhdGUuXG4gICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0KTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gVGhpcyBmaWJlciBkb2Vzbid0IGhhdmUgd29yaywgYnV0IGl0cyBzdWJ0cmVlIGRvZXMuIENsb25lIHRoZSBjaGlsZFxuICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuXG5cbiAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci4nKTtcbiAgICB9IC8vIERpc2Nvbm5lY3QgZnJvbSB0aGUgb2xkIGN1cnJlbnQuXG4gICAgLy8gSXQgd2lsbCBnZXQgZGVsZXRlZC5cblxuXG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIG9sZFdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIENvbm5lY3QgdG8gdGhlIG5ldyB0cmVlLlxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuaW5kZXggPSBvbGRXb3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gb2xkV29ya0luUHJvZ3Jlc3Muc2libGluZztcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZXR1cm4gPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmVmID0gb2xkV29ya0luUHJvZ3Jlc3MucmVmOyAvLyBSZXBsYWNlIHRoZSBjaGlsZC9zaWJsaW5nIHBvaW50ZXJzIGFib3ZlIGl0LlxuXG4gICAgaWYgKG9sZFdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZCkge1xuICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwcmV2U2libGluZy5zaWJsaW5nICE9PSBvbGRXb3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudCk7XG4gICAgfVxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50OyAvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxuXG4gICAgcmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIEJlZm9yZSBwZXJmb3JtaW5nIGFuIGVhcmx5IGJhaWxvdXQsIHdlIG11c3QgY2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmdcbiAgLy8gdXBkYXRlcyBvciBjb250ZXh0LlxuICB2YXIgdXBkYXRlTGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBObyBwZW5kaW5nIHVwZGF0ZSwgYnV0IGJlY2F1c2UgY29udGV4dCBpcyBwcm9wYWdhdGVkIGxhemlseSwgd2UgbmVlZFxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gIC8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7XG4gICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgbmV3VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIC8vIFByb2ZpbGVyIHNob3VsZCBvbmx5IGNhbGwgb25SZW5kZXIgd2hlbiBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgaWYgKGhhc0NoaWxkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbiAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpOyAvLyBXZSBrbm93IHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBzdXNwZW5kIGFnYWluIGJlY2F1c2UgaWYgaXQgaGFzXG4gICAgICAgICAgICAgIC8vIGJlZW4gdW5zdXNwZW5kZWQgaXQgaGFzIGNvbW1pdHRlZCBhcyBhIHJlc29sdmVkIFN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgLy8gSWYgaXQgbmVlZHMgdG8gYmUgcmV0cmllZCwgaXQgc2hvdWxkIGhhdmUgd29yayBzY2hlZHVsZWQgb24gaXQuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gV2Ugc2hvdWxkIG5ldmVyIHJlbmRlciB0aGUgY2hpbGRyZW4gb2YgYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IHVudGlsIHdlXG4gICAgICAgICAgICAgIC8vIHVwZ3JhZGUgaXQuIFdlIHJldHVybiBudWxsIGluc3RlYWQgb2YgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yay5cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgaXMgY3VycmVudGx5IHRpbWVkIG91dCwgd2UgbmVlZCB0byBkZWNpZGVcbiAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4gICAgICAgICAgLy8gZ28gc3RyYWlnaHQgdG8gdGhlIGZhbGxiYWNrLiBDaGVjayB0aGUgcHJpb3JpdHkgb2YgdGhlIHByaW1hcnlcbiAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZExhbmVzID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcztcblxuICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG4gICAgICAgICAgICAvLyB0byBhdHRlbXB0IHRvIHJlbmRlciB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhZ2Fpbi5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCBkb2VzIG5vdCBoYXZlIHBlbmRpbmcgd29yayBtYXJrZWRcbiAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuICAgICAgICAgICAgLy8gcHJpb3JpdHkuIEJhaWxvdXQuXG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBmYWxsYmFjayBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gU2tpcCBvdmVyIHRoZVxuICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBjYW4gcmV0dXJuIGBudWxsYCBoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgd2VyZSBuZXN0ZWQgY29udGV4dCBjb25zdW1lcnMsIHZpYSB0aGUgY2FsbCB0b1xuICAgICAgICAgICAgICAvLyBgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29ya2AgYWJvdmUuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGNoaWxkcmVuIHRoZW4gd2UncmUgc3RpbGwgaW4gcHJvZ3Jlc3NpdmUgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBtaWdodCBnZXQgdW5ibG9ja2VkIGJ5IHN0YXRlIHVwZGF0ZXMgb3IgcmV0cmllcyBpbiB0aGVcbiAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgIC8vIHBhdGggdG8gY29tcHV0ZSB0aGUgY29ycmVjdCB0YWlsLlxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG5cblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQgYmVmb3JlIGFuZCB3ZSdyZSByZW5kZXJpbmcgdGhlIHNhbWUgY2hpbGRyZW4sXG4gICAgICAgIC8vIHRoZW4gdGhlIHRhaWwgZG9lc24ndCBtYXR0ZXIuIEFueXRoaW5nIG5ldyB0aGF0IHN1c3BlbmRzIHdpbGwgd29ya1xuICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIHBhc3QgYnV0IGRpZG4ndCBjb21wbGV0ZSBpdC5cbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuICAgICAgICAvLyBhbG1vc3QgaWRlbnRpY2FsIHRvIHRoZSBsb2dpYyB1c2VkIGluIHRoZSBub3JtYWwgdXBkYXRlIHBhdGgsXG4gICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAvLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuICAgICAgICAvLyBoYXZlIG5vdCBjaGFuZ2VkLiBXaGljaCBpcyBmaW5lLlxuICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbiAgICAgICAgLy8gYnV0IEkgd29uJ3QgOilcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgcHJvcHMgbm9yIGxlZ2FjeSBjb250ZXh0IGNoYW5nZXMuIENoZWNrIGlmIHRoZXJlJ3MgYSBwZW5kaW5nXG4gICAgICAvLyB1cGRhdGUgb3IgY29udGV4dCBjaGFuZ2UuXG4gICAgICB2YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0ID0gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCAmJiAvLyBJZiB0aGlzIGlzIHRoZSBzZWNvbmQgcGFzcyBvZiBhbiBlcnJvciBvciBzdXNwZW5zZSBib3VuZGFyeSwgdGhlcmVcbiAgICAgIC8vIG1heSBub3QgYmUgd29yayBzY2hlZHVsZWQgb24gYGN1cnJlbnRgLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBmbGFnLlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gTm8gcGVuZGluZyB1cGRhdGVzIG9yIGNvbnRleHQuIEJhaWwgb3V0IG5vdy5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGNoaWxkIGJlbG9uZ3MgdG8gYSBsaXN0IG9mIG11bGlwbGUgY2hpbGRyZW4gaW5cbiAgICAgIC8vIGl0cyBwYXJlbnQuXG4gICAgICAvL1xuICAgICAgLy8gSW4gYSB0cnVlIG11bHRpLXRocmVhZGVkIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZCByZW5kZXIgY2hpbGRyZW4gb25cbiAgICAgIC8vIHBhcmFsbGVsIHRocmVhZHMuIFRoaXMgd291bGQgcmVwcmVzZW50IHRoZSBiZWdpbm5pbmcgb2YgYSBuZXcgcmVuZGVyXG4gICAgICAvLyB0aHJlYWQgZm9yIHRoaXMgc3VidHJlZS5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBvbmx5IHVzZSB0aGlzIGZvciBpZCBnZW5lcmF0aW9uIGR1cmluZyBoeWRyYXRpb24sIHdoaWNoIGlzIHdoeSB0aGVcbiAgICAgIC8vIGxvZ2ljIGlzIGxvY2F0ZWQgaW4gdGhpcyBzcGVjaWFsIGJyYW5jaC5cbiAgICAgIHZhciBzbG90SW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gZ2V0Rm9ya3NBdExldmVsKCk7XG4gICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzLCBzbG90SW5kZXgpO1xuICAgIH1cbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBDb21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQgPyBfdW5yZXNvbHZlZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50LCBfdW5yZXNvbHZlZFByb3BzKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IHR5cGUgPyBfdW5yZXNvbHZlZFByb3BzMiA6IHJlc29sdmVEZWZhdWx0UHJvcHModHlwZSwgX3VucmVzb2x2ZWRQcm9wczIpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBfcmVzb2x2ZWRQcm9wczIsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHJldHVybiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3R5cGUyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBSZXNvbHZlIG91dGVyIHByb3BzIGZpcnN0LCB0aGVuIHJlc29sdmUgaW5uZXIgcHJvcHMuXG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLCBfdW5yZXNvbHZlZFByb3BzMyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gX3R5cGUyLnByb3BUeXBlcztcblxuICAgICAgICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBfcmVzb2x2ZWRQcm9wczMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLnR5cGUsIF9yZXNvbHZlZFByb3BzMyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIF9yZXNvbHZlZFByb3BzMywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudDIgPyBfdW5yZXNvbHZlZFByb3BzNCA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsIF91bnJlc29sdmVkUHJvcHM0KTtcblxuICAgICAgICByZXR1cm4gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQyLCBfcmVzb2x2ZWRQcm9wczQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBcIiArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuICAvLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbiAgLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuICAvLyBmb3IgaHlkcmF0aW9uLlxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcblxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIHZhciBfZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoKF9mbGFncyAmIFNob3VsZENhcHR1cmUpICE9PSBOb0ZsYWdzICYmIChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgcmVuZGVyIHRoYXQgd2Fzbid0IGNhcHR1cmVkIGJ5IGEgc3VzcGVuc2VcbiAgICAgICAgICAvLyBib3VuZGFyeS4gRG8gYSBzZWNvbmQgcGFzcyBvbiB0aGUgcm9vdCB0byB1bm1vdW50IHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH0gLy8gV2UgdW53b3VuZCB0byB0aGUgcm9vdCB3aXRob3V0IGNvbXBsZXRpbmcgaXQuIEV4aXQuXG5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczIgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbiAgICAgICAgLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4gIC8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4gIC8vIGZvciBoeWRyYXRpb24uXG4gIHBvcFRyZWVDb250ZXh0KGludGVycnVwdGVkV29yayk7XG5cbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG5cbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBjb250ZXh0ID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuX2NvbnRleHQ7XG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFJlbmRlckxhbmVzKGludGVycnVwdGVkV29yayk7XG5cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2Q7XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW5pbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBmdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGRvY3VtZW50YCBnbG9iYWwgd2FzIGRlZmluZWQgd2hlbiBSZWFjdCB3YXMgaW5pdGlhbGl6ZWQsIGJ1dCBpcyBub3QgJyArICdkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgJyArICdzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgJyArICdmaW5pc2hlZCBydW5uaW5nLiBUbyBzb2x2ZSB0aGlzLCB5b3UgY2FuIGVpdGhlciB1bm1vdW50IHRoZSBjb21wb25lbnQgYXQgJyArICd0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgJyArICdjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmICcgKyAndG8gYmUgYXN5bmNocm9ub3VzLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICB2YXIgZGlkQ2FsbCA9IGZhbHNlOyAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVzZXQgaXRcbiAgICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2sgdG8gbGV0IHVzZXIgY29kZSBhY2Nlc3Mgd2luZG93LmV2ZW50IGluIHRoZVxuICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LlxuXG4gICAgICB2YXIgd2luZG93RXZlbnQgPSB3aW5kb3cuZXZlbnQ7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBkZXNjcmlwdG9yIG9mIHdpbmRvdy5ldmVudCB0byByZXN0b3JlIGl0IGFmdGVyIGV2ZW50XG4gICAgICAvLyBkaXNwYXRjaGluZzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzY4OFxuXG4gICAgICB2YXIgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3csICdldmVudCcpO1xuXG4gICAgICBmdW5jdGlvbiByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFdlIGNoZWNrIGZvciB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykgdG8gcHJldmVudCB0aGVcbiAgICAgICAgLy8gd2luZG93LmV2ZW50IGFzc2lnbm1lbnQgaW4gYm90aCBJRSA8PSAxMCBhcyB0aGV5IHRocm93IGFuIGVycm9yXG4gICAgICAgIC8vIFwiTWVtYmVyIG5vdCBmb3VuZFwiIGluIHN0cmljdCBtb2RlLCBhbmQgaW4gRmlyZWZveCB3aGljaCBkb2VzIG5vdFxuICAgICAgICAvLyBzdXBwb3J0IHdpbmRvdy5ldmVudC5cblxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5ldmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cblxuXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIGRpZENhbGwgPSB0cnVlO1xuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH0gLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cblxuXG4gICAgICB2YXIgZXJyb3I7IC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlV2luZG93RXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHsvLyBJZ25vcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cblxuXG4gICAgICB2YXIgZXZ0VHlwZSA9IFwicmVhY3QtXCIgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7IC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cblxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAod2luZG93RXZlbnREZXNjcmlwdG9yKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdldmVudCcsIHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWRDYWxsICYmIGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfSAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcblxuICAgICAgaWYgKCFkaWRDYWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHJlYWxseSB3cm9uZywgYW5kIG91ciBldmVudCB3YXMgbm90IGRpc3BhdGNoZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIHByb2R1Y3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIHJldHVybiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbDtcblxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsOyAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxudmFyIHJlcG9ydGVyID0ge1xuICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBoYXNDYXVnaHRFcnJvcigpIHtcbiAgcmV0dXJuIGhhc0Vycm9yO1xufVxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xuXG57XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xufSAvLyBVc2VkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHRvIHRyYWNrIHRoZSBzdGF0ZSBvZiB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCBzdGFjay5cbi8vIEFsbG93cyB1cyB0byBhdm9pZCB0cmF2ZXJzaW5nIHRoZSByZXR1cm4gcGF0aCB0byBmaW5kIHRoZSBuZWFyZXN0IE9mZnNjcmVlbiBhbmNlc3Rvci5cbi8vIE9ubHkgdXNlZCB3aGVuIGVuYWJsZVN1c3BlbnNlTGF5b3V0RWZmZWN0U2VtYW50aWNzIGlzIGVuYWJsZWQuXG5cblxudmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGZhbHNlO1xudmFyIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBmYWxzZTtcbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG52YXIgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFVzZWQgZm9yIFByb2ZpbGluZyBidWlsZHMgdG8gdHJhY2sgdXBkYXRlcnMuXG5cbnZhciBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xudmFyIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcblxuZnVuY3Rpb24gcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKSB7XG4gIC8vIFdyYXBwaW5nIGVhY2ggc21hbGwgcGFydCBvZiB0aGUgY29tbWl0IHBoYXNlIGludG8gYSBndWFyZGVkXG4gIC8vIGNhbGxiYWNrIGlzIGEgYml0IHRvbyBzbG93IChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMTY2NikuXG4gIC8vIEJ1dCB3ZSByZWx5IG9uIGl0IHRvIHN1cmZhY2UgZXJyb3JzIHRvIERFViB0b29scyBsaWtlIG92ZXJsYXlzXG4gIC8vIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNzEyKS5cbiAgLy8gQXMgYSBjb21wcm9taXNlLCByZXRocm93IG9ubHkgY2F1Z2h0IGVycm9ycyBpbiBhIGd1YXJkLlxuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQsIGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGluc3RhbmNlKSB7XG4gIHRyeSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyKGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufSAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpIHtcbiAgdHJ5IHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0QXR0YWNoUmVmKGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciByZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZXRWYWw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIGVuYWJsZVByb2ZpbGVyQ29tbWl0SG9va3MgJiYgY3VycmVudC5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgcmV0VmFsID0gcmVmKG51bGwpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0VmFsID0gcmVmKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXRWYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZXR1cm4gdmFsdWUgZnJvbSBhIGNhbGxiYWNrIHJlZiBpbiAlcy4gJyArICdBIGNhbGxiYWNrIHJlZiBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSkge1xuICB0cnkge1xuICAgIGRlc3Ryb3koKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuXG52YXIgZm9jdXNlZEluc3RhbmNlSGFuZGxlID0gbnVsbDtcbnZhciBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcbiAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cbiAgdmFyIHNob3VsZEZpcmUgPSBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuICBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuICByZXR1cm4gc2hvdWxkRmlyZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRoaXMgcGhhc2UgaXMgb25seSB1c2VkIGZvciBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIuXG5cbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgQmVmb3JlTXV0YXRpb25NYXNrKSAhPT0gTm9GbGFncyAmJiBjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoY2hpbGQsIGZpYmVyKTtcbiAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaWJlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgZmliZXIucmV0dXJuKTtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgIHNldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IHByZXZQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChmbGFncywgZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlJDEpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTW91bnRcblxuXG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG5cbiAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICgoZWZmZWN0LnRhZyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGVmZmVjdC50YWcgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VFZmZlY3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkZXN0cm95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiAnICsgJ3VwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdHJveS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlICcgKyBob29rTmFtZSArICcoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyBob29rTmFtZSArICcoKCkgPT4ge1xcbicgKyAnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJyArICcgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArICcgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJyArICcgICAgLy8gLi4uXFxuJyArICcgIH1cXG4nICsgJyAgZmV0Y2hEYXRhKCk7XFxuJyArIFwifSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuXCIgKyAnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ob29rcy1kYXRhLWZldGNoaW5nJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQ6ICcgKyBkZXN0cm95O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcignJXMgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgJyArICd3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lcycsIGhvb2tOYW1lLCBhZGRlbmR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAge1xuICAgIC8vIE9ubHkgUHJvZmlsZXJzIHdpdGggd29yayBpbiB0aGVpciBzdWJ0cmVlIHdpbGwgaGF2ZSBhbiBVcGRhdGUgZWZmZWN0IHNjaGVkdWxlZC5cbiAgICBpZiAoKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICBpZCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxcbiAgICAgICAgICAgICAgICBvblBvc3RDb21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25Qb3N0Q29tbWl0OyAvLyBUaGlzIHZhbHVlIHdpbGwgc3RpbGwgcmVmbGVjdCB0aGUgcHJldmlvdXMgY29tbWl0IHBoYXNlLlxuICAgICAgICAgICAgLy8gSXQgZG9lcyBub3QgZ2V0IHJlc2V0IHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjb21taXQgcGhhc2UuXG5cbiAgICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHBoYXNlID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJztcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBwaGFzZSA9ICduZXN0ZWQtdXBkYXRlJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uUG9zdENvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvblBvc3RDb21taXQoaWQsIHBoYXNlLCBwYXNzaXZlRWZmZWN0RHVyYXRpb24sIGNvbW1pdFRpbWUpO1xuICAgICAgICAgICAgfSAvLyBCdWJibGUgdGltZXMgdG8gdGhlIG5leHQgbmVhcmVzdCBhbmNlc3RvciBQcm9maWxlci5cbiAgICAgICAgICAgIC8vIEFmdGVyIHdlIHByb2Nlc3MgdGhhdCBQcm9maWxlciwgd2UnbGwgYnViYmxlIGZ1cnRoZXIgdXAuXG5cblxuICAgICAgICAgICAgdmFyIHBhcmVudEZpYmVyID0gZmluaXNoZWRXb3JrLnJldHVybjtcblxuICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIHJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgaWYgKChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBMYXlvdXRNYXNrKSAhPT0gTm9GbGFncykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICggIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgbGF5b3V0IGVmZmVjdHMgaGF2ZSBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIChkdXJpbmcgbXV0YXRpb24gcGhhc2UpLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbiAgICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgPT09IGZpbmlzaGVkV29yay50eXBlID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuXG5cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG5cbiAgICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgdXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuICAgICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIF91cGRhdGVRdWV1ZSwgX2luc3RhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vbkNvbW1pdCxcbiAgICAgICAgICAgICAgICBvblJlbmRlciA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25SZW5kZXI7XG4gICAgICAgICAgICB2YXIgZWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0gJ25lc3RlZC11cGRhdGUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb25SZW5kZXIoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLCBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLCBjb21taXRUaW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uQ29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Db21taXQoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBlZmZlY3REdXJhdGlvbiwgY29tbWl0VGltZSk7XG4gICAgICAgICAgICAgIH0gLy8gU2NoZWR1bGUgYSBwYXNzaXZlIGVmZmVjdCBmb3IgdGhpcyBQcm9maWxlciB0byBjYWxsIG9uUG9zdENvbW1pdCBob29rcy5cbiAgICAgICAgICAgICAgLy8gVGhpcyBlZmZlY3Qgc2hvdWxkIGJlIHNjaGVkdWxlZCBldmVuIGlmIHRoZXJlIGlzIG5vIG9uUG9zdENvbW1pdCBjYWxsYmFjayBmb3IgdGhpcyBQcm9maWxlcixcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgZWZmZWN0IGlzIGFsc28gd2hlcmUgdGltZXMgYnViYmxlIHRvIHBhcmVudCBQcm9maWxlcnMuXG5cblxuICAgICAgICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaW5pc2hlZFdvcmspOyAvLyBQcm9wYWdhdGUgbGF5b3V0IGVmZmVjdCBkdXJhdGlvbnMgdG8gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3Rvci5cbiAgICAgICAgICAgICAgLy8gRG8gbm90IHJlc2V0IHRoZXNlIHZhbHVlcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgc28gRGV2VG9vbHMgaGFzIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSBmaXJzdC5cblxuICAgICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuXG4gICAgICAgICAgICAgIG91dGVyOiB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCAhb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgIHtcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIobm9kZSkge1xuICAvLyBUdXJuIG9uIGxheW91dCBlZmZlY3RzIGluIGEgdHJlZSB0aGF0IHByZXZpb3VzbHkgZGlzYXBwZWFyZWQuXG4gIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG4gIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICggbm9kZS5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudERpZE1vdW50KG5vZGUsIG5vZGUucmV0dXJuLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzYWZlbHlBdHRhY2hSZWYobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKG5vZGUsIG5vZGUucmV0dXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbikge1xuICAvLyBPbmx5IGhpZGUgb3IgdW5oaWRlIHRoZSB0b3AtbW9zdCBob3N0IG5vZGVzLlxuICB2YXIgaG9zdFN1YnRyZWVSb290ID0gbnVsbDtcblxuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBub2RlO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmhpZGVJbnN0YW5jZShub2RlLnN0YXRlTm9kZSwgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMywgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBub2RlKSB7XG4gICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgdmFyIGluc3RhbmNlVG9Vc2U7XG5cbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9IC8vIE1vdmVkIG91dHNpZGUgdG8gZW5zdXJlIERDRSB3b3JrcyB3aXRoIHRoaXMgZmxhZ1xuXG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZXRWYWw7XG5cbiAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICByZXRWYWwgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0VmFsID0gcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0VmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcgKyAnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFyZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50UmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59IC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbi8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG5cblxuZnVuY3Rpb24gY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuXG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdmFyIF9lZmZlY3QgPSBlZmZlY3QsXG4gICAgICAgICAgICAgICAgICBkZXN0cm95ID0gX2VmZmVjdC5kZXN0cm95LFxuICAgICAgICAgICAgICAgICAgdGFnID0gX2VmZmVjdC50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgodGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgcm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAvLyB3ZSBkbyBhbiBpbm5lciBsb29wIHdoaWxlIHdlJ3JlIHN0aWxsIGluc2lkZSB0aGUgaG9zdCBub2RlLlxuICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgIXN1cHBvcnRzTXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyTXV0YXRpb24oZmliZXIpIHtcbiAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXIgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGV0ZWN0IGFuZCB3YXJuIGFnYWluc3Qgc3RhdGUgdXBkYXRlcyBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlxuICAvLyBJdCBhbHNvIHByZXZlbnRzIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIGZyb20gd2l0aGluIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzLlxuICAvL1xuICAvLyBJZGVhbGx5LCB3ZSBzaG91bGQgYWxzbyBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLlxuICAvLyBUaGlzIGNoaWxkIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjbGVhciBjaGlsZCBvciBzaWJsaW5nIHBvaW50ZXJzIHlldC5cbiAgLy8gVGhleSdyZSBuZWVkZWQgZm9yIHBhc3NpdmUgZWZmZWN0cyBhbmQgZm9yIGZpbmRET01Ob2RlLlxuICAvLyBXZSBkZWZlciB0aG9zZSBmaWVsZHMsIGFuZCBhbGwgb3RoZXIgY2xlYW51cCwgdG8gdGhlIHBhc3NpdmUgcGhhc2UgKHNlZSBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cykuXG4gIC8vXG4gIC8vIERvbid0IHJlc2V0IHRoZSBhbHRlcm5hdGUgeWV0LCBlaXRoZXIuIFdlIG5lZWQgdGhhdCBzbyB3ZSBjYW4gZGV0YWNoIHRoZVxuICAvLyBhbHRlcm5hdGUncyBmaWVsZHMgaW4gdGhlIHBhc3NpdmUgcGhhc2UuIENsZWFyaW5nIHRoZSByZXR1cm4gcG9pbnRlciBpc1xuICAvLyBzdWZmaWNpZW50IGZvciBmaW5kRE9NTm9kZSBzZW1hbnRpY3MuXG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5yZXR1cm4gPSBudWxsO1xuICB9XG5cbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpO1xuICB9IC8vIE5vdGU6IERlZmVuc2l2ZWx5IHVzaW5nIG5lZ2F0aW9uIGluc3RlYWQgb2YgPCBpbiBjYXNlXG4gIC8vIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgaXMgdW5kZWZpbmVkLlxuXG5cbiAge1xuICAgIC8vIENsZWFyIGN5Y2xpY2FsIEZpYmVyIGZpZWxkcy4gVGhpcyBsZXZlbCBhbG9uZSBpcyBkZXNpZ25lZCB0byByb3VnaGx5XG4gICAgLy8gYXBwcm94aW1hdGUgdGhlIHBsYW5uZWQgRmliZXIgcmVmYWN0b3IuIEluIHRoYXQgd29ybGQsIGBzZXRTdGF0ZWAgd2lsbCBiZVxuICAgIC8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG4gICAgLy8gb2JqZWN0IHdpbGwgbm90IGhhdmUgYW55IG9mIHRoZXNlIGZpZWxkcy4gSXQgd2lsbCBvbmx5IGJlIGNvbm5lY3RlZCB0b1xuICAgIC8vIHRoZSBmaWJlciB0cmVlIHZpYSBhIHNpbmdsZSBsaW5rIGF0IHRoZSByb290LiBTbyBpZiB0aGlzIGxldmVsIGFsb25lIGlzXG4gICAgLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG4gICAgZmliZXIuY2hpbGQgPSBudWxsO1xuICAgIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgZmliZXIuc2libGluZyA9IG51bGw7IC8vIFRoZSBgc3RhdGVOb2RlYCBpcyBjeWNsaWNhbCBiZWNhdXNlIG9uIGhvc3Qgbm9kZXMgaXQgcG9pbnRzIHRvIHRoZSBob3N0XG4gICAgLy8gdHJlZSwgd2hpY2ggaGFzIGl0cyBvd24gcG9pbnRlcnMgdG8gY2hpbGRyZW4sIHBhcmVudHMsIGFuZCBzaWJsaW5ncy5cbiAgICAvLyBUaGUgb3RoZXIgaG9zdCBub2RlcyBhbHNvIHBvaW50IGJhY2sgdG8gZmliZXJzLCBzbyB3ZSBzaG91bGQgZGV0YWNoIHRoYXRcbiAgICAvLyBvbmUsIHRvby5cblxuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDsgLy8gSSdtIGludGVudGlvbmFsbHkgbm90IGNsZWFyaW5nIHRoZSBgcmV0dXJuYCBmaWVsZCBpbiB0aGlzIGxldmVsLiBXZVxuICAgIC8vIGFscmVhZHkgZGlzY29ubmVjdCB0aGUgYHJldHVybmAgcG9pbnRlciBhdCB0aGUgcm9vdCBvZiB0aGUgZGVsZXRlZFxuICAgIC8vIHN1YnRyZWUgKGluIGBkZXRhY2hGaWJlck11dGF0aW9uYCkuIEJlc2lkZXMsIGByZXR1cm5gIGJ5IGl0c2VsZiBpcyBub3RcbiAgICAvLyBjeWNsaWNhbCDigJQgaXQncyBvbmx5IGN5Y2xpY2FsIHdoZW4gY29tYmluZWQgd2l0aCBgY2hpbGRgLCBgc2libGluZ2AsIGFuZFxuICAgIC8vIGBhbHRlcm5hdGVgLiBCdXQgd2UnbGwgY2xlYXIgaXQgaW4gdGhlIG5leHQgbGV2ZWwgYW55d2F5LCBqdXN0IGluIGNhc2UuXG5cbiAgICB7XG4gICAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gVGhlb3JldGljYWxseSwgbm90aGluZyBpbiBoZXJlIHNob3VsZCBiZSBuZWNlc3NhcnksIGJlY2F1c2Ugd2UgYWxyZWFkeVxuICAgICAgLy8gZGlzY29ubmVjdGVkIHRoZSBmaWJlciBmcm9tIHRoZSB0cmVlLiBTbyBldmVuIGlmIHNvbWV0aGluZyBsZWFrcyB0aGlzXG4gICAgICAvLyBwYXJ0aWN1bGFyIGZpYmVyLCBpdCB3b24ndCBsZWFrIGFueXRoaW5nIGVsc2VcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGlzIGJyYW5jaCBpcyB0byBiZSBzdXBlciBhZ2dyZXNzaXZlIHNvIHdlIGNhbiBtZWFzdXJlXG4gICAgICAvLyBpZiB0aGVyZSdzIGFueSBkaWZmZXJlbmNlIGluIG1lbW9yeSBpbXBhY3QuIElmIHRoZXJlIGlzLCB0aGF0IGNvdWxkXG4gICAgICAvLyBpbmRpY2F0ZSBhIFJlYWN0IGxlYWsgd2UgZG9uJ3Qga25vdyBhYm91dC5cbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsOyAvLyBUT0RPOiBNb3ZlIHRvIGBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcmAgaW5zdGVhZC5cblxuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcbiAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgIHBlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW47XG4gICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBwZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgLy8gbm9kZS4gVW5mb3J0dW5hdGVseSwgaWYgbXVsdGlwbGUgaW5zZXJ0aW9ucyBhcmUgZG9uZSBpbiBhIHJvdyB3ZSBoYXZlIHRvXG4gIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAvLyBUT0RPOiBGaW5kIGEgbW9yZSBlZmZpY2llbnQgd2F5IHRvIGRvIHRoaXMuXG4gIHZhciBub2RlID0gZmliZXI7XG5cbiAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZS5yZXR1cm4pKSB7XG4gICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgLy8gbGFzdCBzaWJsaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCAmJiBub2RlLnRhZyAhPT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICBpZiAobm9kZS5mbGFncyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgLy8gV2UgYWxzbyBza2lwIHBvcnRhbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGlzIGhvc3QgdHJlZS5cblxuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfSAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuXG5cbiAgICBpZiAoIShub2RlLmZsYWdzICYgUGxhY2VtZW50KSkge1xuICAgICAgLy8gRm91bmQgaXQhXG4gICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG5cblxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgICAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgX2JlZm9yZSwgX3BhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBkZWxldGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IGN1cnJlbnQ7IC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG5cbiAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7IC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuXG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuXG4gICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnICsgJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGU7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIG5vZGUsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpOyAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG5cbiAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cblxuICAgIH0gZWxzZSBpZiAoIG5vZGUudGFnID09PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcblxuXG4gICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgICAgLy8gV2Ugd2lsbCByZWFzc2lnbiBpdCBiYWNrIHdoZW4gd2UgcG9wIHRoZSBwb3J0YWwgb24gdGhlIHdheSB1cC5cbiAgICAgICAgY3VycmVudFBhcmVudCA9IG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgcG9ydGFscyBtaWdodCBjb250YWluIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIG5vZGUsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblxuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gIH1cblxuICBkZXRhY2hGaWJlck11dGF0aW9uKGN1cnJlbnQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspOyAvLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcbiAgICAgICAgICAvLyBkZXN0cm95IGZ1bmN0aW9ucyBmb3IgYWxsIGZpYmVycyBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgY3JlYXRlIGZ1bmN0aW9ucy5cbiAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbiAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgYW4gT2Zmc2NyZWVuIHN1YnRyZWUgdGhhdCBkaXNhcHBlYXJlZFxuICAgICAgICAgIC8vIGR1cmluZyB0aGlzIGNvbW1pdC4gSWYgc28sIHdlIHdvdWxkIGhhdmUgYWxyZWFkeSB1bm1vdW50ZWQgaXRzXG4gICAgICAgICAgLy8gbGF5b3V0IGhvb2tzLiAoSG93ZXZlciwgc2luY2Ugd2UgbnVsbCBvdXQgdGhlIGBkZXN0cm95YCBmdW5jdGlvblxuICAgICAgICAgIC8vIHJpZ2h0IGJlZm9yZSBjYWxsaW5nIGl0LCB0aGUgYmVoYXZpb3IgaXMgYWxyZWFkeSBjb3JyZWN0LCBzbyB0aGlzXG4gICAgICAgICAgLy8gd291bGQgbW9zdGx5IGJlIGZvciBtb2RlbGluZyBwdXJwb3Nlcy4pXG5cbiAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcHJldlJvb3RTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICBpZiAocHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KEluc2VydGlvbiB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTsgLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuXG4gICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTsgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3ByZXZSb290U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChfcHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9yb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIoX3Jvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgY29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspO1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKSB7XG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBwYXNzaXZlIHBoYXNlXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaykge1xuICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4gIC8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgdmFyIHdha2VhYmxlcyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuXG4gICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAgICAgaWYgKGluUHJvZ3Jlc3NMYW5lcyAhPT0gbnVsbCAmJiBpblByb2dyZXNzUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgYXNzb2NpYXRlIHRoZSBvcmlnaW5hbCB1cGRhdGVycyB3aXRoIGl0LlxuICAgICAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKGluUHJvZ3Jlc3NSb290LCBpblByb2dyZXNzTGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0V4cGVjdGVkIGZpbmlzaGVkIHJvb3QgYW5kIGxhbmVzIHRvIGJlIHNldC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG5cbmZ1bmN0aW9uIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQoY3VycmVudCkge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQsIGNvbW1pdHRlZExhbmVzKSB7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICBjb21taXRNdXRhdGlvbkVmZmVjdHNfYmVnaW4ocm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICBpblByb2dyZXNzUm9vdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c19iZWdpbihyb290LCBsYW5lcykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRPRE86IFNob3VsZCB3cmFwIHRoaXMgaW4gZmxhZ3MgY2hlY2ssIHRvbywgYXMgb3B0aW1pemF0aW9uXG5cbiAgICB2YXIgZGVsZXRpb25zID0gZmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb21taXREZWxldGlvbihyb290LCBjaGlsZFRvRGVsZXRlLCBmaWJlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjaGlsZFRvRGVsZXRlLCBmaWJlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICBpZiAoKGZpYmVyLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGNoaWxkLCBmaWJlcik7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZShyb290LCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZShyb290LCBsYW5lcykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgIHRyeSB7XG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpYmVyLCByb290LCBsYW5lcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgZmliZXIucmV0dXJuKTtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKSB7XG4gIC8vIFRPRE86IFRoZSBmYWN0b3Jpbmcgb2YgdGhpcyBwaGFzZSBjb3VsZCBwcm9iYWJseSBiZSBpbXByb3ZlZC4gQ29uc2lkZXJcbiAgLy8gc3dpdGNoaW5nIG9uIHRoZSB0eXBlIG9mIHdvcmsgYmVmb3JlIGNoZWNraW5nIHRoZSBmbGFncy4gVGhhdCdzIHdoYXRcbiAgLy8gd2UgZG8gaW4gYWxsIHRoZSBvdGhlciBwaGFzZXMuIEkgdGhpbmsgdGhpcyBvbmUgaXMgb25seSBkaWZmZXJlbnRcbiAgLy8gYmVjYXVzZSBvZiB0aGUgc2hhcmVkIHJlY29uY2lsaWF0aW9uIGxvZ2ljIGJlbG93LlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKGZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChmaW5pc2hlZFdvcmspO1xuICB9XG5cbiAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmxhZ3MgJiBWaXNpYmlsaXR5KSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV3U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gX2N1cnJlbnQgIT09IG51bGwgJiYgX2N1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCF3YXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgICAgICAgICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9uZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgdmFyIF9pc0hpZGRlbiA9IF9uZXdTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgdmFyIF93YXNIaWRkZW4gPSBfY3VycmVudDIgIT09IG51bGwgJiYgX2N1cnJlbnQyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICB2YXIgb2Zmc2NyZWVuQm91bmRhcnkgPSBmaW5pc2hlZFdvcms7XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBuZWVkcyB0byBydW4gd2hlbmV2ZXIgdGhlcmUncyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlXG4gICAgICAgICAgICAvLyBpbnNpZGUgYSBoaWRkZW4gT2Zmc2NyZWVuIHRyZWUuXG4gICAgICAgICAgICBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihvZmZzY3JlZW5Cb3VuZGFyeSwgX2lzSGlkZGVuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoX2lzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIGlmICghX3dhc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIGlmICgob2Zmc2NyZWVuQm91bmRhcnkubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gb2Zmc2NyZWVuQm91bmRhcnk7XG4gICAgICAgICAgICAgICAgICB2YXIgb2Zmc2NyZWVuQ2hpbGQgPSBvZmZzY3JlZW5Cb3VuZGFyeS5jaGlsZDtcblxuICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNjcmVlbkNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBvZmZzY3JlZW5DaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihvZmZzY3JlZW5DaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbkNoaWxkID0gb2Zmc2NyZWVuQ2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnkgcG9zc2libGVcbiAgLy8gYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlIGVmZmVjdCB0YWcgYW5kXG4gIC8vIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuXG5cbiAgdmFyIHByaW1hcnlGbGFncyA9IGZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IEh5ZHJhdGluZyk7XG5cbiAgIHN3aXRjaCAocHJpbWFyeUZsYWdzKSB7XG4gICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspOyAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAgICAgLy8gYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBraWxsIHRoaXMuXG5cbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cblxuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gflBsYWNlbWVudDsgLy8gVXBkYXRlXG5cbiAgICAgICAgdmFyIF9jdXJyZW50MyA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSHlkcmF0aW5nOlxuICAgICAge1xuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gfkh5ZHJhdGluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEh5ZHJhdGluZ0FuZFVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5IeWRyYXRpbmc7IC8vIFVwZGF0ZVxuXG4gICAgICAgIHZhciBfY3VycmVudDQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50NCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jdXJyZW50NSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQ1LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgbmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihmaW5pc2hlZFdvcmssIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICAvLyBTdXNwZW5zZSBsYXlvdXQgZWZmZWN0cyBzZW1hbnRpY3MgZG9uJ3QgY2hhbmdlIGZvciBsZWdhY3kgcm9vdHMuXG4gIHZhciBpc01vZGVyblJvb3QgPSAoc3VidHJlZVJvb3QubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKCBmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBpc01vZGVyblJvb3QpIHtcbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIHN0YWNrJ3Mgc3RhdGUuXG4gICAgICB2YXIgaXNIaWRkZW4gPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcblxuICAgICAgaWYgKG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbikge1xuICAgICAgICAvLyBUaGUgT2Zmc2NyZWVuIHRyZWUgaXMgaGlkZGVuLiBTa2lwIG92ZXIgaXRzIGxheW91dCBlZmZlY3RzLlxuICAgICAgICBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIEFsc28gY2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dE1hc2tcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSB3YXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47IC8vIFRyYXZlcnNlIHRoZSBPZmZzY3JlZW4gc3VidHJlZSB3aXRoIHRoZSBjdXJyZW50IE9mZnNjcmVlbiBhcyB0aGUgcm9vdC5cblxuICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuICYmICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSByZWFwcGVhcmluZyBib3VuZGFyeS4gVHVybiBpdHMgbGF5b3V0IGVmZmVjdHNcbiAgICAgICAgICAvLyBiYWNrIG9uLlxuICAgICAgICAgIG5leHRFZmZlY3QgPSBmaWJlcjtcbiAgICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oZmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihjaGlsZCwgLy8gTmV3IHJvb3Q7IGJ1YmJsZSBiYWNrIHVwIHRvIGhlcmUgYW5kIHN0b3AuXG4gICAgICAgICAgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfSAvLyBSZXN0b3JlIE9mZnNjcmVlbiBzdGF0ZSBhbmQgcmVzdW1lIGluIG91ci1wcm9ncmVzcyB0cmF2ZXJzYWwuXG5cblxuICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MgJiYgZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoZmlyc3RDaGlsZCwgZmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmICgoZmliZXIuZmxhZ3MgJiBMYXlvdXRNYXNrKSAhPT0gTm9GbGFncykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIGN1cnJlbnQsIGZpYmVyLCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKHNpYmxpbmcsIGZpYmVyLnJldHVybik7XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oc3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBmaXJzdENoaWxkID0gZmliZXIuY2hpbGQ7IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgKFJlZlN0YXRpYyB8IExheW91dFN0YXRpYylcblxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBmaWJlci5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCwgZmliZXIsIGZpYmVyLnJldHVybik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIFJlZlN0YXRpY1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsIGZpYmVyLnJldHVybiwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYVxuICAgICAgICAgIHZhciBpc0hpZGRlbiA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIE5lc3RlZCBPZmZzY3JlZW4gdHJlZSBpcyBhbHJlYWR5IGhpZGRlbi4gRG9uJ3QgZGlzYXBwZWFyXG4gICAgICAgICAgICAvLyBpdHMgZWZmZWN0cy5cbiAgICAgICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dFN0YXRpY1xuXG5cbiAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoZmliZXIgPT09IHN1YnRyZWVSb290KSB7XG4gICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmIChmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkge1xuICAgICAgdmFyIGlzSGlkZGVuID0gZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgIC8vIE5lc3RlZCBPZmZzY3JlZW4gdHJlZSBpcyBzdGlsbCBoaWRkZW4uIERvbid0IHJlLWFwcGVhciBpdHMgZWZmZWN0cy5cbiAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBzdWJ0cmVlRmxhZ3MgJiBMYXlvdXRTdGF0aWNcblxuXG4gICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBtYXkgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLCBzbyB3ZSBjYW4ndFxuICAgICAgLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0LlxuICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0OyAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIExheW91dFN0YXRpY1xuXG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgIHRyeSB7XG4gICAgICByZWFwcGVhckxheW91dEVmZmVjdHNPbkZpYmVyKGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBtYXkgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLCBzbyB3ZSBjYW4ndFxuICAgICAgLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0LlxuICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIG5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4oZmluaXNoZWRXb3JrLCByb290KTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCwgcm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzICYmIGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGZpcnN0Q2hpbGQsIGZpYmVyKTtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCwgZmliZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihzaWJsaW5nLCBmaWJlci5yZXR1cm4pO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KFBhc3NpdmUkMSB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpcnN0Q2hpbGQpIHtcbiAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbigpO1xufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfYmVnaW4oKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgobmV4dEVmZmVjdC5mbGFncyAmIENoaWxkRGVsZXRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gZmliZXIuZGVsZXRpb25zO1xuXG4gICAgICBpZiAoZGVsZXRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpYmVyVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IGZpYmVyVG9EZWxldGU7XG4gICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihmaWJlclRvRGVsZXRlLCBmaWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgLy8gQSBmaWJlciB3YXMgZGVsZXRlZCBmcm9tIHRoaXMgcGFyZW50IGZpYmVyLCBidXQgaXQncyBzdGlsbCBwYXJ0IG9mXG4gICAgICAgICAgLy8gdGhlIHByZXZpb3VzIChhbHRlcm5hdGUpIHBhcmVudCBmaWJlcidzIGxpc3Qgb2YgY2hpbGRyZW4uIEJlY2F1c2VcbiAgICAgICAgICAvLyBjaGlsZHJlbiBhcmUgYSBsaW5rZWQgbGlzdCwgYW4gZWFybGllciBzaWJsaW5nIHRoYXQncyBzdGlsbCBhbGl2ZVxuICAgICAgICAgIC8vIHdpbGwgYmUgY29ubmVjdGVkIHRvIHRoZSBkZWxldGVkIGZpYmVyIHZpYSBpdHMgYGFsdGVybmF0ZWA6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgIGxpdmUgZmliZXJcbiAgICAgICAgICAvLyAgIC0tYWx0ZXJuYXRlLS0+IHByZXZpb3VzIGxpdmUgZmliZXJcbiAgICAgICAgICAvLyAgIC0tc2libGluZy0tPiBkZWxldGVkIGZpYmVyXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBXZSBjYW4ndCBkaXNjb25uZWN0IGBhbHRlcm5hdGVgIG9uIG5vZGVzIHRoYXQgaGF2ZW4ndCBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAvLyB5ZXQsIGJ1dCB3ZSBjYW4gZGlzY29ubmVjdCB0aGUgYHNpYmxpbmdgIGFuZCBgY2hpbGRgIHBvaW50ZXJzLlxuICAgICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkZXRhY2hlZENoaWxkID0gcHJldmlvdXNGaWJlci5jaGlsZDtcblxuICAgICAgICAgICAgaWYgKGRldGFjaGVkQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNGaWJlci5jaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBkZXRhY2hlZFNpYmxpbmcgPSBkZXRhY2hlZENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWRDaGlsZC5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZXRhY2hlZENoaWxkID0gZGV0YWNoZWRTaWJsaW5nO1xuICAgICAgICAgICAgICB9IHdoaWxlIChkZXRhY2hlZENoaWxkICE9PSBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGNoaWxkLCBmaWJlcik7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmICgoZmliZXIuZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaWJlcik7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihzaWJsaW5nLCBmaWJlci5yZXR1cm4pO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGRlbGV0ZWRTdWJ0cmVlUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIERlbGV0aW9uIGVmZmVjdHMgZmlyZSBpbiBwYXJlbnQgLT4gY2hpbGQgb3JkZXJcbiAgICAvLyBUT0RPOiBDaGVjayBpZiBmaWJlciBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWdcblxuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIoZmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IC8vIFRPRE86IE9ubHkgdHJhdmVyc2Ugc3VidHJlZSBpZiBpdCBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWcuIChCdXQsIGlmIHdlXG4gICAgLy8gZG8gdGhpcywgc3RpbGwgbmVlZCB0byBoYW5kbGUgYGRlbGV0ZWRUcmVlQ2xlYW5VcExldmVsYCBjb3JyZWN0bHkuKVxuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihjaGlsZCwgZmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlKGRlbGV0ZWRTdWJ0cmVlUm9vdCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG4gICAgdmFyIHJldHVybkZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgdGhlIGVudGlyZSBkZWxldGVkIHRyZWUgYW5kIGNsZWFuIHVwIGZpYmVyIGZpZWxkcy5cbiAgICAgIC8vIFRoaXMgaXMgbW9yZSBhZ2dyZXNzaXZlIHRoYW4gaWRlYWwsIGFuZCB0aGUgbG9uZyB0ZXJtIGdvYWwgaXMgdG8gb25seVxuICAgICAgLy8gaGF2ZSB0byBkZXRhY2ggdGhlIGRlbGV0ZWQgdHJlZSBhdCB0aGUgcm9vdC5cbiAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKTtcblxuICAgICAgaWYgKGZpYmVyID09PSBkZWxldGVkU3VidHJlZVJvb3QpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgcmV0dXJuRmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBjdXJyZW50Lm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoZmliZXIsIGV4cGVjdGVkUmV0dXJuRmliZXIpIHtcbiAge1xuICAgIGlmICghZGlkV2Fybldyb25nUmV0dXJuUG9pbnRlciAmJiBmaWJlci5yZXR1cm4gIT09IGV4cGVjdGVkUmV0dXJuRmliZXIpIHtcbiAgICAgIGRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIgPSB0cnVlO1xuXG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IFJldHVybiBwb2ludGVyIGlzIGluY29uc2lzdGVudCAnICsgJ3dpdGggcGFyZW50LicpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhc3NpZ25tZW50IG9uY2Ugd2UncmUgY29uZmlkZW50IHRoYXQgaXQgd29uJ3QgYnJlYWtcbiAgLy8gYW55dGhpbmcsIGJ5IGNoZWNraW5nIHRoZSB3YXJuaW5nIGxvZ3MgZm9yIHRoZSBhYm92ZSBpbnZhcmlhbnRcblxuXG4gIGZpYmVyLnJldHVybiA9IGV4cGVjdGVkUmV0dXJuRmliZXI7XG59IC8vIFRPRE86IFJldXNlIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyB0cmF2ZXJzYWwgaGVyZT9cblxuXG5mdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RNb3VudEluREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmliZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0TW91bnRJbkRFVihmaWJlcikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpYmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsIGZpYmVyLnJldHVybiwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgQ09NUE9ORU5UX1RZUEUgPSAwO1xudmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDE7XG52YXIgUk9MRV9UWVBFID0gMjtcbnZhciBURVNUX05BTUVfVFlQRSA9IDM7XG52YXIgVEVYVF9UWVBFID0gNDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3MnKTtcbiAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IudGV4dCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRTZWxlY3Rvcihjb21wb25lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogQ09NUE9ORU5UX1RZUEUsXG4gICAgdmFsdWU6IGNvbXBvbmVudFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvcihzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogSEFTX1BTRVVET19DTEFTU19UWVBFLFxuICAgIHZhbHVlOiBzZWxlY3RvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvbGVTZWxlY3Rvcihyb2xlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJPTEVfVFlQRSxcbiAgICB2YWx1ZTogcm9sZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFNlbGVjdG9yKHRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogVEVYVF9UWVBFLFxuICAgIHZhbHVlOiB0ZXh0XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUZXN0TmFtZVNlbGVjdG9yKGlkKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFRFU1RfTkFNRV9UWVBFLFxuICAgIHZhbHVlOiBpZFxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcbiAgdmFyIG1heWJlRmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGhvc3RSb290KTtcblxuICBpZiAobWF5YmVGaWJlciAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBtYXliZUZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHJvb3Qgc3BlY2lmaWVkLiBTaG91bGQgYmUgZWl0aGVyIGEgUmVhY3QgY29udGFpbmVyIG9yIGEgbm9kZSB3aXRoIGEgdGVzdG5hbWUgYXR0cmlidXRlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZUZpYmVyO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaWJlclJvb3QgPSBmaW5kRmliZXJSb290KGhvc3RSb290KTtcblxuICAgIGlmIChmaWJlclJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgUmVhY3QgY29udGFpbmVyIHdpdGhpbiBzcGVjaWZpZWQgaG9zdCBzdWJ0cmVlLicpO1xuICAgIH0gLy8gVGhlIEZsb3cgdHlwZSBmb3IgRmliZXJSb290IGlzIGEgbGl0dGxlIGZ1bmt5LlxuICAgIC8vIGNyZWF0ZUZpYmVyUm9vdCgpIGNoZWF0cyB0aGlzIGJ5IHRyZWF0aW5nIHRoZSByb290IGFzIDphbnkgYW5kIGFkZGluZyBzdGF0ZU5vZGUgbGF6aWx5LlxuXG5cbiAgICByZXR1cm4gZmliZXJSb290LnN0YXRlTm9kZS5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSB7XG4gIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnR5cGUgPT09IHNlbGVjdG9yLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgcmV0dXJuIGhhc01hdGNoaW5nUGF0aHMoZmliZXIsIHNlbGVjdG9yLnZhbHVlKTtcblxuICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZShub2RlLCBzZWxlY3Rvci52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGZpYmVyKTtcblxuICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwgJiYgdGV4dENvbnRlbnQuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGRhdGFUZXN0SUQgPSBmaWJlci5tZW1vaXplZFByb3BzWydkYXRhLXRlc3RuYW1lJ107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhVGVzdElEID09PSAnc3RyaW5nJyAmJiBkYXRhVGVzdElELnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuJyk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHtcbiAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoc2VsZWN0b3IudmFsdWUpIHx8ICdVbmtub3duJztcbiAgICAgIHJldHVybiBcIjxcIiArIGRpc3BsYXlOYW1lICsgXCI+XCI7XG5cbiAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgIHJldHVybiBcIjpoYXMoXCIgKyAoc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikgfHwgJycpICsgXCIpXCI7XG5cbiAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgIHJldHVybiBcIltyb2xlPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG4gICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyBzZWxlY3Rvci52YWx1ZSArIFwiXFxcIlwiO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIHJldHVybiBcIltkYXRhLXRlc3RuYW1lPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKSB7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IFtdO1xuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoc2VsZWN0b3IgIT0gbnVsbCAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgICAgc2VsZWN0b3JJbmRleCsrO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgbWF0Y2hpbmdGaWJlcnMucHVzaChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hpbmdGaWJlcnM7XG59IC8vIFNhbWUgYXMgZmluZFBhdGhzIGJ1dCB3aXRoIGVhZ2VyIGJhaWxvdXQgb24gZmlyc3QgbWF0Y2hcblxuXG5mdW5jdGlvbiBoYXNNYXRjaGluZ1BhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoc2VsZWN0b3IgIT0gbnVsbCAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgICAgc2VsZWN0b3JJbmRleCsrO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpO1xuICB2YXIgaW5zdGFuY2VSb290cyA9IFtdO1xuICB2YXIgc3RhY2sgPSBBcnJheS5mcm9tKG1hdGNoaW5nRmliZXJzKTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgbm9kZSA9IHN0YWNrW2luZGV4KytdO1xuXG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZVJvb3RzLnB1c2gobm9kZS5zdGF0ZU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2VSb290cztcbn1cbmZ1bmN0aW9uIGdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbihob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXhTZWxlY3RvckluZGV4ID0gMDtcbiAgdmFyIG1hdGNoZWROYW1lcyA9IFtdOyAvLyBUaGUgbG9naWMgb2YgdGhpcyBsb29wIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCBmaW5kUGF0aHMoKVxuXG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3JJbmRleCA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcblxuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgIG1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpKTtcbiAgICAgIHNlbGVjdG9ySW5kZXgrKztcblxuICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4KSB7XG4gICAgICAgIG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgIHZhciB1bm1hdGNoZWROYW1lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IG1heFNlbGVjdG9ySW5kZXg7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcnNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ2ZpbmRBbGxOb2RlcyB3YXMgYWJsZSB0byBtYXRjaCBwYXJ0IG9mIHRoZSBzZWxlY3RvcjpcXG4nICsgKFwiICBcIiArIG1hdGNoZWROYW1lcy5qb2luKCcgPiAnKSArIFwiXFxuXFxuXCIpICsgJ05vIG1hdGNoaW5nIGNvbXBvbmVudCB3YXMgZm91bmQgZm9yOlxcbicgKyAoXCIgIFwiICsgdW5tYXRjaGVkTmFtZXMuam9pbignID4gJykpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQm91bmRpbmdSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIGJvdW5kaW5nUmVjdHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlUm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICBib3VuZGluZ1JlY3RzLnB1c2goZ2V0Qm91bmRpbmdSZWN0KGluc3RhbmNlUm9vdHNbaV0pKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gYm91bmRpbmdSZWN0cy5sZW5ndGggLSAxOyBfaSA+IDA7IF9pLS0pIHtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IGJvdW5kaW5nUmVjdHNbX2ldO1xuICAgIHZhciB0YXJnZXRMZWZ0ID0gdGFyZ2V0UmVjdC54O1xuICAgIHZhciB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyB0YXJnZXRSZWN0LndpZHRoO1xuICAgIHZhciB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0Lnk7XG4gICAgdmFyIHRhcmdldEJvdHRvbSA9IHRhcmdldFRvcCArIHRhcmdldFJlY3QuaGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaiA9IF9pIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChfaSAhPT0gaikge1xuICAgICAgICB2YXIgb3RoZXJSZWN0ID0gYm91bmRpbmdSZWN0c1tqXTtcbiAgICAgICAgdmFyIG90aGVyTGVmdCA9IG90aGVyUmVjdC54O1xuICAgICAgICB2YXIgb3RoZXJSaWdodCA9IG90aGVyTGVmdCArIG90aGVyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIG90aGVyVG9wID0gb3RoZXJSZWN0Lnk7XG4gICAgICAgIHZhciBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDsgLy8gTWVyZ2luZyBhbGwgcmVjdHMgdG8gdGhlIG1pbmltdW1zIHNldCB3b3VsZCBiZSBjb21wbGljYXRlZCxcbiAgICAgICAgLy8gYnV0IHdlIGNhbiBoYW5kbGUgdGhlIG1vc3QgY29tbW9uIGNhc2VzOlxuICAgICAgICAvLyAxLiBjb21wbGV0ZWx5IG92ZXJsYXBwaW5nIHJlY3RzXG4gICAgICAgIC8vIDIuIGFkamFjZW50IHJlY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHdpZHRoIG9yIGhlaWdodCAoZS5nLiBpdGVtcyBpbiBhIGxpc3QpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV2ZW4gZ2l2ZW4gdGhlIGFib3ZlIGNvbnN0cmFpbnRzLFxuICAgICAgICAvLyB3ZSBzdGlsbCB3b24ndCBlbmQgdXAgd2l0aCB0aGUgZmV3ZXN0IHBvc3NpYmxlIHJlY3RzIHdpdGhvdXQgZG9pbmcgbXVsdGlwbGUgcGFzc2VzLFxuICAgICAgICAvLyBidXQgaXQncyBnb29kIGVub3VnaCBmb3IgdGhpcyBwdXJwb3NlLlxuXG4gICAgICAgIGlmICh0YXJnZXRMZWZ0ID49IG90aGVyTGVmdCAmJiB0YXJnZXRUb3AgPj0gb3RoZXJUb3AgJiYgdGFyZ2V0UmlnaHQgPD0gb3RoZXJSaWdodCAmJiB0YXJnZXRCb3R0b20gPD0gb3RoZXJCb3R0b20pIHtcbiAgICAgICAgICAvLyBDb21wbGV0ZSBvdmVybGFwcGluZyByZWN0czsgcmVtb3ZlIHRoZSBpbm5lciBvbmUuXG4gICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldExlZnQgPT09IG90aGVyTGVmdCAmJiB0YXJnZXRSZWN0LndpZHRoID09PSBvdGhlclJlY3Qud2lkdGggJiYgIShvdGhlckJvdHRvbSA8IHRhcmdldFRvcCkgJiYgIShvdGhlclRvcCA+IHRhcmdldEJvdHRvbSkpIHtcbiAgICAgICAgICAvLyBBZGphY2VudCB2ZXJ0aWNhbCByZWN0czsgbWVyZ2UgdGhlbS5cbiAgICAgICAgICBpZiAob3RoZXJUb3AgPiB0YXJnZXRUb3ApIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgKz0gb3RoZXJUb3AgLSB0YXJnZXRUb3A7XG4gICAgICAgICAgICBvdGhlclJlY3QueSA9IHRhcmdldFRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXJCb3R0b20gPCB0YXJnZXRCb3R0b20pIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZGluZ1JlY3RzLnNwbGljZShfaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VG9wID09PSBvdGhlclRvcCAmJiB0YXJnZXRSZWN0LmhlaWdodCA9PT0gb3RoZXJSZWN0LmhlaWdodCAmJiAhKG90aGVyUmlnaHQgPCB0YXJnZXRMZWZ0KSAmJiAhKG90aGVyTGVmdCA+IHRhcmdldFJpZ2h0KSkge1xuICAgICAgICAgIC8vIEFkamFjZW50IGhvcml6b250YWwgcmVjdHM7IG1lcmdlIHRoZW0uXG4gICAgICAgICAgaWYgKG90aGVyTGVmdCA+IHRhcmdldExlZnQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCArPSBvdGhlckxlZnQgLSB0YXJnZXRMZWZ0O1xuICAgICAgICAgICAgb3RoZXJSZWN0LnggPSB0YXJnZXRMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlclJpZ2h0IDwgdGFyZ2V0UmlnaHQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kaW5nUmVjdHMuc3BsaWNlKF9pLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZGluZ1JlY3RzO1xufVxuZnVuY3Rpb24gZm9jdXNXaXRoaW4oaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIHN0YWNrID0gQXJyYXkuZnJvbShtYXRjaGluZ0ZpYmVycyk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG5cbiAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgdmFyIG5vZGUgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChzZXRGb2N1c0lmRm9jdXNhYmxlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzdGFjay5wdXNoKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgY29tbWl0SG9va3MgPSBbXTtcbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKCkge1xuICBpZiAoc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gb2JzZXJ2ZVZpc2libGVSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG5cbiAgdmFyIF9zZXR1cEludGVyc2VjdGlvbk9icyA9IHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW5zdGFuY2VSb290cywgY2FsbGJhY2ssIG9wdGlvbnMpLFxuICAgICAgZGlzY29ubmVjdCA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5kaXNjb25uZWN0LFxuICAgICAgb2JzZXJ2ZSA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5vYnNlcnZlLFxuICAgICAgdW5vYnNlcnZlID0gX3NldHVwSW50ZXJzZWN0aW9uT2JzLnVub2JzZXJ2ZTsgLy8gV2hlbiBSZWFjdCBtdXRhdGVzIHRoZSBob3N0IGVudmlyb25tZW50LCB3ZSBtYXkgbmVlZCB0byBjaGFuZ2Ugd2hhdCB3ZSdyZSBsaXN0ZW5pbmcgdG8uXG5cblxuICB2YXIgY29tbWl0SG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dEluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgaW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgIHVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5leHRJbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKGluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpIDwgMCkge1xuICAgICAgICBvYnNlcnZlKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29tbWl0SG9va3MucHVzaChjb21taXRIb29rKTtcbiAgcmV0dXJuIHtcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3IgUmVhY3QgbXV0YXRpb25zOlxuICAgICAgdmFyIGluZGV4ID0gY29tbWl0SG9va3MuaW5kZXhPZihjb21taXRIb29rKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgY29tbWl0SG9va3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH0gLy8gRGlzY29ubmVjdCB0aGUgaG9zdCBvYnNlcnZlcjpcblxuXG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3RDdXJyZW50QWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZTtcbmZ1bmN0aW9uIGlzTGVnYWN5QWN0RW52aXJvbm1lbnQoZmliZXIpIHtcbiAge1xuICAgIC8vIExlZ2FjeSBtb2RlLiBXZSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2YgUmVhY3QgMTcncyBhY3QuIEl0IGFzc3VtZXMgYW5cbiAgICAvLyBhY3QgZW52aXJvbm1lbnQgd2hlbmV2ZXIgYGplc3RgIGlzIGRlZmluZWQsIGJ1dCB5b3UgY2FuIHN0aWxsIHR1cm4gb2ZmXG4gICAgLy8gc3B1cmlvdXMgd2FybmluZ3MgYnkgc2V0dGluZyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZXhwbGljaXRseVxuICAgIC8vIHRvIGZhbHNlLlxuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDsgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgamVzdFxuXG4gICAgdmFyIGplc3RJc0RlZmluZWQgPSB0eXBlb2YgamVzdCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgcmV0dXJuIHdhcm5zSWZOb3RBY3RpbmcgJiYgamVzdElzRGVmaW5lZCAmJiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgIT09IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAge1xuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IEluY2x1ZGUgbGluayB0byByZWxldmFudCBkb2N1bWVudGF0aW9uIHBhZ2UuXG4gICAgICBlcnJvcignVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0ICcgKyAnYWN0KC4uLiknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICB9XG59XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyLFxuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7XG52YXIgTm9Db250ZXh0ID1cbi8qICAgICAgICAgICAgICovXG4wO1xudmFyIEJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUmVuZGVyQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBDb21taXRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgICovXG40O1xudmFyIFJvb3RJblByb2dyZXNzID0gMDtcbnZhciBSb290RmF0YWxFcnJvcmVkID0gMTtcbnZhciBSb290RXJyb3JlZCA9IDI7XG52YXIgUm9vdFN1c3BlbmRlZCA9IDM7XG52YXIgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQ7XG52YXIgUm9vdENvbXBsZXRlZCA9IDU7XG52YXIgUm9vdERpZE5vdENvbXBsZXRlID0gNjsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSAoKm5vdCogYW4gaW50ZXJsZWF2ZWQgZXZlbnQpLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzOyAvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7IC8vIFRoZXNlIGFyZSBlcnJvcnMgdGhhdCB3ZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IHN1cmZhY2luZyB0aGVtIHRvIHRoZSBVSS5cbi8vIFdlIHdpbGwgbG9nIHRoZW0gb25jZSB0aGUgdHJlZSBjb21taXRzLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsOyAvLyBUaGUgbW9zdCByZWNlbnQgdGltZSB3ZSBjb21taXR0ZWQgYSBmYWxsYmFjay4gVGhpcyBsZXRzIHVzIGVuc3VyZSBhIHRyYWluXG4vLyBtb2RlbCB3aGVyZSB3ZSBkb24ndCBjb21taXQgbmV3IGxvYWRpbmcgc3RhdGVzIGluIHRvbyBxdWljayBzdWNjZXNzaW9uLlxuXG52YXIgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDA7XG52YXIgRkFMTEJBQ0tfVEhST1RUTEVfTVMgPSA1MDA7IC8vIFRoZSBhYnNvbHV0ZSB0aW1lIGZvciB3aGVuIHdlIHNob3VsZCBzdGFydCBnaXZpbmcgdXAgb24gcmVuZGVyaW5nXG4vLyBtb3JlIGFuZCBwcmVmZXIgQ1BVIHN1c3BlbnNlIGhldXJpc3RpY3MgaW5zdGVhZC5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eTsgLy8gSG93IGxvbmcgYSByZW5kZXIgaXMgc3VwcG9zZWQgdG8gdGFrZSBiZWZvcmUgd2Ugc3RhcnQgZm9sbG93aW5nIENQVVxuLy8gc3VzcGVuc2UgaGV1cmlzdGljcyBhbmQgb3B0IG91dCBvZiByZW5kZXJpbmcgbW9yZSBjb250ZW50LlxuXG52YXIgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDA7XG5cbmZ1bmN0aW9uIHJlc2V0UmVuZGVyVGltZXIoKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVM7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO1xufVxudmFyIGhhc1VuY2F1Z2h0RXJyb3IgPSBmYWxzZTtcbnZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDsgLy8gT25seSB1c2VkIHdoZW4gZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVTY2hlZHVsZWRIb29rIGlzIHRydWU7XG52YXIgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG52YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xudmFyIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzID0gW107XG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDsgLy8gSWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlIHNob3VsZCB0cmVhdCB0aGVpclxuLy8gZXZlbnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2sgdGltZSBoYXMgYWR2YW5jZWRcbi8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxudmFyIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbnZhciBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IE5vTGFuZXM7XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG59XG5mdW5jdGlvbiByZXF1ZXN0RXZlbnRUaW1lKCkge1xuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgLy8gV2UncmUgaW5zaWRlIFJlYWN0LCBzbyBpdCdzIGZpbmUgdG8gcmVhZCB0aGUgYWN0dWFsIHRpbWUuXG4gICAgcmV0dXJuIG5vdyQxKCk7XG4gIH0gLy8gV2UncmUgbm90IGluc2lkZSBSZWFjdCwgc28gd2UgbWF5IGJlIGluIHRoZSBtaWRkbGUgb2YgYSBicm93c2VyIGV2ZW50LlxuXG5cbiAgaWYgKGN1cnJlbnRFdmVudFRpbWUgIT09IE5vVGltZXN0YW1wKSB7XG4gICAgLy8gVXNlIHRoZSBzYW1lIHN0YXJ0IHRpbWUgZm9yIGFsbCB1cGRhdGVzIHVudGlsIHdlIGVudGVyIFJlYWN0IGFnYWluLlxuICAgIHJldHVybiBjdXJyZW50RXZlbnRUaW1lO1xuICB9IC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZSBzaW5jZSBSZWFjdCB5aWVsZGVkLiBDb21wdXRlIGEgbmV3IHN0YXJ0IHRpbWUuXG5cblxuICBjdXJyZW50RXZlbnRUaW1lID0gbm93JDEoKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICggKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFRoZXNlIGFyZSBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuIFRoZVxuICAgIC8vIG9sZCBiZWhhdmlvciBpcyB0byBnaXZlIHRoaXMgdGhlIHNhbWUgXCJ0aHJlYWRcIiAobGFuZXMpIGFzXG4gICAgLy8gd2hhdGV2ZXIgaXMgY3VycmVudGx5IHJlbmRlcmluZy4gU28gaWYgeW91IGNhbGwgYHNldFN0YXRlYCBvbiBhIGNvbXBvbmVudFxuICAgIC8vIHRoYXQgaGFwcGVucyBsYXRlciBpbiB0aGUgc2FtZSByZW5kZXIsIGl0IHdpbGwgZmx1c2guIElkZWFsbHksIHdlIHdhbnQgdG9cbiAgICAvLyByZW1vdmUgdGhlIHNwZWNpYWwgY2FzZSBhbmQgdHJlYXQgdGhlbSBhcyBpZiB0aGV5IGNhbWUgZnJvbSBhblxuICAgIC8vIGludGVybGVhdmVkIGV2ZW50LiBSZWdhcmRsZXNzLCB0aGlzIHBhdHRlcm4gaXMgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgb25seSBhIGZhbGxiYWNrLiBUaGUgZmxhZyBvbmx5IGV4aXN0cyB1bnRpbCB3ZSBjYW4gcm9sbFxuICAgIC8vIG91dCB0aGUgc2V0U3RhdGUgd2FybmluZywgc2luY2UgZXhpc3RpbmcgY29kZSBtaWdodCBhY2NpZGVudGFsbHkgcmVseSBvblxuICAgIC8vIHRoZSBjdXJyZW50IGJlaGF2aW9yLlxuICAgIHJldHVybiBwaWNrQXJiaXRyYXJ5TGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgaXNUcmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkgIT09IE5vVHJhbnNpdGlvbjtcblxuICBpZiAoaXNUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuXG4gICAgICBpZiAoIXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpO1xuICAgIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gICAgLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZVxuICAgIC8vIGlucHV0cyB0byB0aGUgYWxnb3JpdGhtIG11c3QgYmUgdGhlIHNhbWUuXG4gICAgLy9cbiAgICAvLyBUaGUgdHJpY2sgd2UgdXNlIGlzIHRvIGNhY2hlIHRoZSBmaXJzdCBvZiBlYWNoIG9mIHRoZXNlIGlucHV0cyB3aXRoaW4gYW5cbiAgICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpc1xuICAgIC8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cblxuXG4gICAgaWYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIEFsbCB0cmFuc2l0aW9ucyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgYXJlIGFzc2lnbmVkIHRoZSBzYW1lIGxhbmUuXG4gICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO1xuICB9IC8vIFVwZGF0ZXMgb3JpZ2luYXRpbmcgaW5zaWRlIGNlcnRhaW4gUmVhY3QgbWV0aG9kcywgbGlrZSBmbHVzaFN5bmMsIGhhdmVcbiAgLy8gdGhlaXIgcHJpb3JpdHkgc2V0IGJ5IHRyYWNraW5nIGl0IHdpdGggYSBjb250ZXh0IHZhcmlhYmxlLlxuICAvL1xuICAvLyBUaGUgb3BhcXVlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGhvc3QgY29uZmlnIGlzIGludGVybmFsbHkgYSBsYW5lLCBzbyB3ZSBjYW5cbiAgLy8gdXNlIHRoYXQgZGlyZWN0bHkuXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0eXBlIGNvbnZlcnNpb24gdG8gdGhlIGV2ZW50IHByaW9yaXR5IG1vZHVsZS5cblxuXG4gIHZhciB1cGRhdGVMYW5lID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgaWYgKHVwZGF0ZUxhbmUgIT09IE5vTGFuZSkge1xuICAgIHJldHVybiB1cGRhdGVMYW5lO1xuICB9IC8vIFRoaXMgdXBkYXRlIG9yaWdpbmF0ZWQgb3V0c2lkZSBSZWFjdC4gQXNrIHRoZSBob3N0IGVudmlyb25tZW50IGZvciBhblxuICAvLyBhcHByb3ByaWF0ZSBwcmlvcml0eSwgYmFzZWQgb24gdGhlIHR5cGUgb2YgZXZlbnQuXG4gIC8vXG4gIC8vIFRoZSBvcGFxdWUgdHlwZSByZXR1cm5lZCBieSB0aGUgaG9zdCBjb25maWcgaXMgaW50ZXJuYWxseSBhIGxhbmUsIHNvIHdlIGNhblxuICAvLyB1c2UgdGhhdCBkaXJlY3RseS5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHR5cGUgY29udmVyc2lvbiB0byB0aGUgZXZlbnQgcHJpb3JpdHkgbW9kdWxlLlxuXG5cbiAgdmFyIGV2ZW50TGFuZSA9IGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCk7XG4gIHJldHVybiBldmVudExhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfVxuXG4gIHJldHVybiBjbGFpbU5leHRSZXRyeUxhbmUoKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIGxhbmUpO1xuXG4gIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxuXG5cbiAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vTGFuZXMgJiYgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gVGhpcyB1cGRhdGUgd2FzIGRpc3BhdGNoZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXMgaXMgYSBtaXN0YWtlXG4gICAgLy8gaWYgdGhlIHVwZGF0ZSBvcmlnaW5hdGVzIGZyb20gdXNlciBzcGFjZSAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIGxvY2FsXG4gICAgLy8gaG9vayB1cGRhdGVzLCB3aGljaCBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgcmVhY2ggdGhpc1xuICAgIC8vIGZ1bmN0aW9uKSwgYnV0IHRoZXJlIGFyZSBzb21lIGludGVybmFsIFJlYWN0IGZlYXR1cmVzIHRoYXQgdXNlIHRoaXMgYXNcbiAgICAvLyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGxpa2Ugc2VsZWN0aXZlIGh5ZHJhdGlvbi5cbiAgICB3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcik7IC8vIFRyYWNrIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIG5vcm1hbCB1cGRhdGUsIHNjaGVkdWxlZCBmcm9tIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS4gRm9yXG4gICAgLy8gZXhhbXBsZSwgZHVyaW5nIGFuIGlucHV0IGV2ZW50LlxuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcik7XG5cbiAgICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgICAvLyBUT0RPOiBDb25zb2xpZGF0ZSB3aXRoIGBpc0ludGVybGVhdmVkVXBkYXRlYCBjaGVja1xuICAgICAgLy8gUmVjZWl2ZWQgYW4gdXBkYXRlIHRvIGEgdHJlZSB0aGF0J3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuIE1hcmtcbiAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuICAgICAgLy8gYGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaGAgZmxhZyBpcyBvZmYgYW5kIHRoaXMgaXMgYSByZW5kZXJcbiAgICAgIC8vIHBoYXNlIHVwZGF0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBkb24ndCB0cmVhdCByZW5kZXIgcGhhc2UgdXBkYXRlcyBhcyBpZlxuICAgICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICAgICAgaWYgKCAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpIHtcbiAgICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbiAgICAgICAgLy8gc3VzcGVuZGVkIG5vdywgcmlnaHQgYmVmb3JlIG1hcmtpbmcgdGhlIGluY29taW5nIHVwZGF0ZS4gVGhpcyBoYXMgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuICAgICAgICAvLyBhbHJlYWR5IHN0YXJ0ZWQgcmVuZGVyaW5nLlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcblxuICAgIGlmIChsYW5lID09PSBTeW5jTGFuZSAmJiBleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiYgKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgIC8vIGEgYmF0Y2guIFRoaXMgaXMgaW50ZW50aW9uYWxseSBpbnNpZGUgc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGluc3RlYWQgb2ZcbiAgICAgIC8vIHNjaGVkdWxlQ2FsbGJhY2tGb3JGaWJlciB0byBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAvLyB1cGRhdGVzLCB0byBwcmVzZXJ2ZSBoaXN0b3JpY2FsIGJlaGF2aW9yIG9mIGxlZ2FjeSBtb2RlLlxuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSkge1xuICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBmb3JrIG9mIHNjaGVkdWxlVXBkYXRlT25GaWJlciB0aGF0IGlzIG9ubHkgdXNlZCB0b1xuICAvLyBzY2hlZHVsZSB0aGUgaW5pdGlhbCBoeWRyYXRpb24gb2YgYSByb290IHRoYXQgaGFzIGp1c3QgYmVlbiBjcmVhdGVkLiBNb3N0XG4gIC8vIG9mIHRoZSBzdHVmZiBpbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgY2FuIGJlIHNraXBwZWQuXG4gIC8vXG4gIC8vIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBzZXBhcmF0ZSBwYXRoLCB0aG91Z2gsIGlzIHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAvLyBpbml0aWFsIGNoaWxkcmVuIGZyb20gc3Vic2VxdWVudCB1cGRhdGVzLiBJbiBmdWxseSBjbGllbnQtcmVuZGVyZWQgcm9vdHNcbiAgLy8gKGNyZWF0ZVJvb3QgaW5zdGVhZCBvZiBoeWRyYXRlUm9vdCksIGFsbCB0b3AtbGV2ZWwgcmVuZGVycyBhcmUgbW9kZWxlZCBhc1xuICAvLyB1cGRhdGVzLCBidXQgaHlkcmF0aW9uIHJvb3RzIGFyZSBzcGVjaWFsIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3RcbiAgLy8gbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIGN1cnJlbnQubGFuZXMgPSBsYW5lO1xuICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG59IC8vIFRoaXMgaXMgc3BsaXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIHdlIGNhbiBtYXJrIGEgZmliZXIgd2l0aCBwZW5kaW5nXG4vLyB3b3JrIHdpdGhvdXQgdHJlYXRpbmcgaXQgYXMgYSB0eXBpY2FsIHVwZGF0ZSB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBhbiBldmVudDtcbi8vIGUuZy4gcmV0cnlpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBpc24ndCBhbiB1cGRhdGUsIGJ1dCBpdCBkb2VzIHNjaGVkdWxlIHdvcmtcbi8vIG9uIGEgZmliZXIuXG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCBsYW5lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgbGFuZXNcbiAgc291cmNlRmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLCBsYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIGxhbmUpO1xuICB9XG5cbiAge1xuICAgIGlmIChhbHRlcm5hdGUgPT09IG51bGwgJiYgKHNvdXJjZUZpYmVyLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICB9XG4gIH0gLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMuXG5cblxuICB2YXIgbm9kZSA9IHNvdXJjZUZpYmVyO1xuICB2YXIgcGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBwYXJlbnQuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMocGFyZW50LmNoaWxkTGFuZXMsIGxhbmUpO1xuICAgIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG5cbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIGxhbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmICgocGFyZW50LmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gcGFyZW50O1xuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cblxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyLCBsYW5lKSB7XG4gIHJldHVybiAoLy8gVE9ETzogT3B0aW1pemUgc2xpZ2h0bHkgYnkgY29tcGFyaW5nIHRvIHJvb3QgdGhhdCBmaWJlciBiZWxvbmdzIHRvLlxuICAgIC8vIFJlcXVpcmVzIHNvbWUgcmVmYWN0b3JpbmcuIE5vdCBhIGJpZyBkZWFsIHRob3VnaCBzaW5jZSBpdCdzIHJhcmUgZm9yXG4gICAgLy8gY29uY3VycmVudCBhcHBzIHRvIGhhdmUgbW9yZSB0aGFuIGEgc2luZ2xlIHJvb3QuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsICYmIChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUgJiYgKCAvLyBJZiB0aGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZSAoaS5lLiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyksXG4gICAgLy8gdGhlbiBkb24ndCB0cmVhdCB0aGlzIGFzIGFuIGludGVybGVhdmVkIHVwZGF0ZS4gVGhpcyBwYXR0ZXJuIGlzXG4gICAgLy8gYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nIGJ1dCB3ZSBoYXZlbid0IGZ1bGx5IGRlcHJlY2F0ZWQgaXQgeWV0LiBXZSBjYW5cbiAgICAvLyByZW1vdmUgb25jZSB0aGUgZGVmZXJSZW5kZXJQaGFzZVVwZGF0ZVRvTmV4dEJhdGNoIGZsYWcgaXMgZW5hYmxlZC5cbiAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KVxuICApO1xufSAvLyBVc2UgdGhpcyBmdW5jdGlvbiB0byBzY2hlZHVsZSBhIHRhc2sgZm9yIGEgcm9vdC4gVGhlcmUncyBvbmx5IG9uZSB0YXNrIHBlclxuLy8gcm9vdDsgaWYgYSB0YXNrIHdhcyBhbHJlYWR5IHNjaGVkdWxlZCwgd2UnbGwgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBwcmlvcml0eVxuLy8gb2YgdGhlIGV4aXN0aW5nIHRhc2sgaXMgdGhlIHNhbWUgYXMgdGhlIHByaW9yaXR5IG9mIHRoZSBuZXh0IGxldmVsIHRoYXQgdGhlXG4vLyByb290IGhhcyB3b3JrIG9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSB1cGRhdGUsIGFuZCByaWdodCBiZWZvcmVcbi8vIGV4aXRpbmcgYSB0YXNrLlxuXG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7IC8vIENoZWNrIGlmIGFueSBsYW5lcyBhcmUgYmVpbmcgc3RhcnZlZCBieSBvdGhlciB3b3JrLiBJZiBzbywgbWFyayB0aGVtIGFzXG4gIC8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG5cbiAgbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSk7IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG5cbiAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgICByZXR1cm47XG4gIH0gLy8gV2UgdXNlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGxhbmUgdG8gcmVwcmVzZW50IHRoZSBwcmlvcml0eSBvZiB0aGUgY2FsbGJhY2suXG5cblxuICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB0YXNrLiBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSBpdC5cblxuICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuXG4gIGlmIChleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPT09IG5ld0NhbGxiYWNrUHJpb3JpdHkgJiYgLy8gU3BlY2lhbCBjYXNlIHJlbGF0ZWQgdG8gYGFjdGAuIElmIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkIHRhc2sgaXMgYVxuICAvLyBTY2hlZHVsZXIgdGFzaywgcmF0aGVyIHRoYW4gYW4gYGFjdGAgdGFzaywgY2FuY2VsIGl0IGFuZCByZS1zY2hlZHVsZWRcbiAgLy8gb24gdGhlIGBhY3RgIHF1ZXVlLlxuICAhKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgIT09IG51bGwgJiYgZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUpKSB7XG4gICAge1xuICAgICAgLy8gSWYgd2UncmUgZ29pbmcgdG8gcmUtdXNlIGFuIGV4aXN0aW5nIHRhc2ssIGl0IG5lZWRzIHRvIGV4aXN0LlxuICAgICAgLy8gQXNzdW1lIHRoYXQgZGlzY3JldGUgdXBkYXRlIG1pY3JvdGFza3MgYXJlIG5vbi1jYW5jZWxsYWJsZSBhbmQgbnVsbC5cbiAgICAgIC8vIFRPRE86IFRlbXBvcmFyeSB1bnRpbCB3ZSBjb25maXJtIHRoaXMgd2FybmluZyBpcyBub3QgZmlyZWQuXG4gICAgICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgPT0gbnVsbCAmJiBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgIT09IFN5bmNMYW5lKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCBzY2hlZHVsZWQgY2FsbGJhY2sgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgcHJpb3JpdHkgaGFzbid0IGNoYW5nZWQuIFdlIGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgdGFzay4gRXhpdC5cblxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9IG51bGwpIHtcbiAgICAvLyBDYW5jZWwgdGhlIGV4aXN0aW5nIGNhbGxiYWNrLiBXZSdsbCBzY2hlZHVsZSBhIG5ldyBvbmUgYmVsb3cuXG4gICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gIH0gLy8gU2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG5cblxuICB2YXIgbmV3Q2FsbGJhY2tOb2RlO1xuXG4gIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBTeW5jTGFuZSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU3luYyBSZWFjdCBjYWxsYmFja3MgYXJlIHNjaGVkdWxlZCBvbiBhIHNwZWNpYWxcbiAgICAvLyBpbnRlcm5hbCBxdWV1ZVxuICAgIGlmIChyb290LnRhZyA9PT0gTGVnYWN5Um9vdCkge1xuICAgICAgaWYgKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmlzQmF0Y2hpbmdMZWdhY3kgIT09IG51bGwpIHtcbiAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrKHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c01pY3JvdGFza3MpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBxdWV1ZSBpbiBhIG1pY3JvdGFzay5cbiAgICAgIGlmICggUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEluc2lkZSBgYWN0YCwgdXNlIG91ciBpbnRlcm5hbCBgYWN0YCBxdWV1ZSBzbyB0aGF0IHRoZXNlIGdldCBmbHVzaGVkXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2NvcGUgZXZlbiB3aGVuIHVzaW5nIHRoZSBzeW5jIHZlcnNpb25cbiAgICAgICAgLy8gb2YgYGFjdGAuXG4gICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudC5wdXNoKGZsdXNoU3luY0NhbGxiYWNrcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gSW4gU2FmYXJpLCBhcHBlbmRpbmcgYW4gaWZyYW1lIGZvcmNlcyBtaWNyb3Rhc2tzIHRvIHJ1bi5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIyNDU5XG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBydW5uaW5nIGNhbGxiYWNrcyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlclxuICAgICAgICAgIC8vIG9yIGNvbW1pdCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgdGhhdC5cbiAgICAgICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgICAgICAvLyBJdCdzIG9ubHkgc2FmZSB0byBkbyB0aGlzIGNvbmRpdGlvbmFsbHkgYmVjYXVzZSB3ZSBhbHdheXNcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBwZW5kaW5nIHdvcmsgYmVmb3JlIHdlIGV4aXQgdGhlIHRhc2suXG4gICAgICAgICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCB0aGUgcXVldWUgaW4gYW4gSW1tZWRpYXRlIHRhc2suXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrcyk7XG4gICAgfVxuXG4gICAgbmV3Q2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbDtcblxuICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkobmV4dExhbmVzKSkge1xuICAgICAgY2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSWRsZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG5ld0NhbGxiYWNrTm9kZSA9IHNjaGVkdWxlQ2FsbGJhY2skMShzY2hlZHVsZXJQcmlvcml0eUxldmVsLCBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH1cblxuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICByb290LmNhbGxiYWNrTm9kZSA9IG5ld0NhbGxiYWNrTm9kZTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290LCBkaWRUaW1lb3V0KSB7XG4gIHtcbiAgICByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKTtcbiAgfSAvLyBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIGEgUmVhY3QgZXZlbnQsIHdlIGNhbiBjbGVhciB0aGUgY3VycmVudFxuICAvLyBldmVudCB0aW1lLiBUaGUgbmV4dCB1cGRhdGUgd2lsbCBjb21wdXRlIGEgbmV3IGV2ZW50IHRpbWUuXG5cblxuICBjdXJyZW50RXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG4gIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gTm9MYW5lcztcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfSAvLyBGbHVzaCBhbnkgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYmVmb3JlIGRlY2lkaW5nIHdoaWNoIGxhbmVzIHRvIHdvcmsgb24sXG4gIC8vIGluIGNhc2UgdGhleSBzY2hlZHVsZSBhZGRpdGlvbmFsIHdvcmsuXG5cblxuICB2YXIgb3JpZ2luYWxDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgdmFyIGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG5cbiAgaWYgKGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHBhc3NpdmUgZWZmZWN0IHBoYXNlIG1heSBoYXZlIGNhbmNlbGVkIHRoZSBjdXJyZW50IHRhc2suXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRhc2sgbm9kZSBmb3IgdGhpcyByb290IHdhcyBjaGFuZ2VkLlxuICAgIGlmIChyb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRhc2sgd2FzIGNhbmNlbGVkLiBFeGl0LiBXZSBkb24ndCBuZWVkIHRvIGNhbGxcbiAgICAgIC8vIGBlbnN1cmVSb290SXNTY2hlZHVsZWRgIGJlY2F1c2UgdGhlIGNoZWNrIGFib3ZlIGltcGxpZXMgZWl0aGVyIHRoYXRcbiAgICAgIC8vIHRoZXJlJ3MgYSBuZXcgdGFzaywgb3IgdGhhdCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG5cblxuICB2YXIgbGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBXZSBkaXNhYmxlIHRpbWUtc2xpY2luZyBpbiBzb21lIGNhc2VzOiBpZiB0aGUgd29yayBoYXMgYmVlbiBDUFUtYm91bmRcbiAgLy8gZm9yIHRvbyBsb25nIChcImV4cGlyZWRcIiB3b3JrLCB0byBwcmV2ZW50IHN0YXJ2YXRpb24pLCBvciB3ZSdyZSBpblxuICAvLyBzeW5jLXVwZGF0ZXMtYnktZGVmYXVsdCBtb2RlLlxuICAvLyBUT0RPOiBXZSBvbmx5IGNoZWNrIGBkaWRUaW1lb3V0YCBkZWZlbnNpdmVseSwgdG8gYWNjb3VudCBmb3IgYSBTY2hlZHVsZXJcbiAgLy8gYnVnIHdlJ3JlIHN0aWxsIGludmVzdGlnYXRpbmcuIE9uY2UgdGhlIGJ1ZyBpbiBTY2hlZHVsZXIgaXMgZml4ZWQsXG4gIC8vIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2UgdHJhY2sgZXhwaXJhdGlvbiBvdXJzZWx2ZXMuXG5cblxuICB2YXIgc2hvdWxkVGltZVNsaWNlID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSAmJiAhaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LCBsYW5lcykgJiYgKCAhZGlkVGltZW91dCk7XG4gIHZhciBleGl0U3RhdHVzID0gc2hvdWxkVGltZVNsaWNlID8gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIDogcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcykge1xuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsXG4gICAgICAvLyByZW5kZXIgc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGxcbiAgICAgIC8vIGluY2x1ZGVzIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlclxuICAgICAgLy8gdGhlIHNlY29uZCBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG4gICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICBleGl0U3RhdHVzID0gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgICAgdmFyIGZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgICAgIHRocm93IGZhdGFsRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSkge1xuICAgICAgLy8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcbiAgICAgIC8vIGNhc2VzIHdoZXJlIG5lZWQgdG8gZXhpdCB0aGUgY3VycmVudCByZW5kZXIgd2l0aG91dCBwcm9kdWNpbmcgYVxuICAgICAgLy8gY29uc2lzdGVudCB0cmVlIG9yIGNvbW1pdHRpbmcuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gZHVyaW5nIGEgY29uY3VycmVudCByZW5kZXIsIG5vdCBhIGRpc2NyZXRlIG9yXG4gICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGUuIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgY2hlY2tlZCBmb3IgdGhpcyB3aGVuIHdlXG4gICAgICAvLyB1bndvdW5kIHRoZSBzdGFjay5cbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmVuZGVyIGNvbXBsZXRlZC5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgcmVuZGVyIG1heSBoYXZlIHlpZWxkZWQgdG8gYSBjb25jdXJyZW50IGV2ZW50LCBhbmQgaWYgc28sXG4gICAgICAvLyBjb25maXJtIHRoYXQgYW55IG5ld2x5IHJlbmRlcmVkIHN0b3JlcyBhcmUgY29uc2lzdGVudC5cbiAgICAgIC8vIFRPRE86IEl0J3MgcG9zc2libGUgdGhhdCBldmVuIGEgY29uY3VycmVudCByZW5kZXIgbWF5IG5ldmVyIGhhdmUgeWllbGRlZFxuICAgICAgLy8gdG8gdGhlIG1haW4gdGhyZWFkLCBpZiBpdCB3YXMgZmFzdCBlbm91Z2gsIG9yIGlmIGl0IGV4cGlyZWQuIFdlIGNvdWxkXG4gICAgICAvLyBza2lwIHRoZSBjb25zaXN0ZW5jeSBjaGVjayBpbiB0aGF0IGNhc2UsIHRvby5cbiAgICAgIHZhciByZW5kZXJXYXNDb25jdXJyZW50ID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKTtcbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAocmVuZGVyV2FzQ29uY3VycmVudCAmJiAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgLy8gQSBzdG9yZSB3YXMgbXV0YXRlZCBpbiBhbiBpbnRlcmxlYXZlZCBldmVudC4gUmVuZGVyIGFnYWluLFxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5LCB0byBibG9jayBmdXJ0aGVyIG11dGF0aW9ucy5cbiAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTsgLy8gV2UgbmVlZCB0byBjaGVjayBhZ2FpbiBpZiBzb21ldGhpbmcgdGhyZXdcblxuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgX2Vycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG4gICAgICAgICAgaWYgKF9lcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgIGxhbmVzID0gX2Vycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBfZXJyb3JSZXRyeUxhbmVzKTsgLy8gV2UgYXNzdW1lIHRoZSB0cmVlIGlzIG5vdyBjb25zaXN0ZW50IGJlY2F1c2Ugd2UgZGlkbid0IHlpZWxkIHRvIGFueVxuICAgICAgICAgICAgLy8gY29uY3VycmVudCBldmVudHMuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgX2ZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgICAgICAgICB0aHJvdyBfZmF0YWxFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG4gICAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuXG4gIGlmIChyb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAvLyBUaGUgdGFzayBub2RlIHNjaGVkdWxlZCBmb3IgdGhpcyByb290IGlzIHRoZSBzYW1lIG9uZSB0aGF0J3NcbiAgICAvLyBjdXJyZW50bHkgZXhlY3V0ZWQuIE5lZWQgdG8gcmV0dXJuIGEgY29udGludWF0aW9uLlxuICAgIHJldHVybiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBlcnJvclJldHJ5TGFuZXMpIHtcbiAgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbiwgZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGxcbiAgLy8gYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG4gIC8vIEJlZm9yZSByZW5kZXJpbmcgYWdhaW4sIHNhdmUgdGhlIGVycm9ycyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LlxuICB2YXIgZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdCA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG5cbiAgaWYgKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpIHtcbiAgICAvLyBUaGUgc2hlbGwgZmFpbGVkIHRvIGh5ZHJhdGUuIFNldCBhIGZsYWcgdG8gZm9yY2UgYSBjbGllbnQgcmVuZGVyaW5nXG4gICAgLy8gZHVyaW5nIHRoZSBuZXh0IGF0dGVtcHQuIFRvIGRvIHRoaXMsIHdlIGNhbGwgcHJlcGFyZUZyZXNoU3RhY2sgbm93XG4gICAgLy8gdG8gY3JlYXRlIHRoZSByb290IHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoaXMgaXMgYSBiaXQgd2VpcmQgaW4gdGVybXNcbiAgICAvLyBvZiBmYWN0b3JpbmcsIGJlY2F1c2UgaXQgcmVsaWVzIG9uIHJlbmRlclJvb3RTeW5jIG5vdCBjYWxsaW5nXG4gICAgLy8gcHJlcGFyZUZyZXNoU3RhY2sgYWdhaW4gaW4gdGhlIGNhbGwgYmVsb3csIHdoaWNoIGhhcHBlbnMgYmVjYXVzZSB0aGVcbiAgICAvLyByb290IGFuZCBsYW5lcyBoYXZlbid0IGNoYW5nZWQuXG4gICAgLy9cbiAgICAvLyBUT0RPOiBJIHRoaW5rIHdoYXQgd2Ugc2hvdWxkIGRvIGlzIHNldCBGb3JjZUNsaWVudFJlbmRlciBpbnNpZGVcbiAgICAvLyB0aHJvd0V4Y2VwdGlvbiwgbGlrZSB3ZSBkbyBmb3IgbmVzdGVkIFN1c3BlbnNlIGJvdW5kYXJpZXMuIFRoZSByZWFzb25cbiAgICAvLyBpdCdzIGhlcmUgaW5zdGVhZCBpcyBzbyB3ZSBjYW4gc3dpdGNoIHRvIHRoZSBzeW5jaHJvbm91cyB3b3JrIGxvb3AsIHRvby5cbiAgICAvLyBTb21ldGhpbmcgdG8gY29uc2lkZXIgZm9yIGEgZnV0dXJlIHJlZmFjdG9yLlxuICAgIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuICAgIHJvb3RXb3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcblxuICAgIHtcbiAgICAgIGVycm9ySHlkcmF0aW5nQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBmaW5pc2hlZCByZW5kZXJpbmcgb24gcmV0cnlcbiAgICAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIGZhaWxlZCBmaXJzdCBhdHRlbXB0IGhhdmUgYmVlbiByZWNvdmVyZWQuIEFkZFxuICAgIC8vIHRoZW0gdG8gdGhlIGNvbGxlY3Rpb24gb2YgcmVjb3ZlcmFibGUgZXJyb3JzLiBXZSdsbCBsb2cgdGhlbSBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UuXG4gICAgdmFyIGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0ID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnNGcm9tRmlyc3RBdHRlbXB0OyAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIHNlY29uZCBhdHRlbXB0IHNob3VsZCBiZSBxdWV1ZWQgYWZ0ZXIgdGhlIGVycm9yc1xuICAgIC8vIGZyb20gdGhlIGZpcnN0IGF0dGVtcHQsIHRvIHByZXNlcnZlIHRoZSBjYXVzYWwgc2VxdWVuY2UuXG5cbiAgICBpZiAoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQgIT09IG51bGwpIHtcbiAgICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleGl0U3RhdHVzO1xufVxuXG5mdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9ycztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgbGFuZXMpIHtcbiAgc3dpdGNoIChleGl0U3RhdHVzKSB7XG4gICAgY2FzZSBSb290SW5Qcm9ncmVzczpcbiAgICBjYXNlIFJvb3RGYXRhbEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIC8vIEZsb3cga25vd3MgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnMgaWYgSSBhZGQgYSBicmVha1xuICAgIC8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcbiAgICAvLyBpZiBJIGRvLiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJldHJ5IHRoaXMgdHJlZS4gSWYgd2UgcmVhY2hlZFxuICAgICAgICAvLyB0aGlzIHBvaW50LCBpdCBlcnJvcmVkIGFnYWluLiBDb21taXQgaXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdFN1c3BlbmRlZDpcbiAgICAgIHtcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7IC8vIFdlIGhhdmUgYW4gYWNjZXB0YWJsZSBsb2FkaW5nIHN0YXRlLiBXZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgd2VcbiAgICAgICAgLy8gc2hvdWxkIGltbWVkaWF0ZWx5IGNvbW1pdCBpdCBvciB3YWl0IGEgYml0LlxuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSAmJiAvLyBkbyBub3QgZGVsYXkgaWYgd2UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlXG4gICAgICAgICFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSkge1xuICAgICAgICAgIC8vIFRoaXMgcmVuZGVyIG9ubHkgaW5jbHVkZWQgcmV0cmllcywgbm8gdXBkYXRlcy4gVGhyb3R0bGUgY29tbWl0dGluZ1xuICAgICAgICAgIC8vIHJldHJpZXMgc28gdGhhdCB3ZSBkb24ndCBzaG93IHRvbyBtYW55IGxvYWRpbmcgc3RhdGVzIHRvbyBxdWlja2x5LlxuICAgICAgICAgIHZhciBtc1VudGlsVGltZW91dCA9IGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgKyBGQUxMQkFDS19USFJPVFRMRV9NUyAtIG5vdyQxKCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3RcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG4gICAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICAgIG1hcmtSb290UGluZ2VkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cblxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyksIG1zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgd29yayBleHBpcmVkLiBDb21taXQgaW1tZWRpYXRlbHkuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgdHJhbnNpdGlvbiwgc28gd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCBjb21taXR0aW5nIGFcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgLy8gdW50aWwgd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB0cmFuc2l0aW9uLCBidXQgd2UgZGlkIHRyaWdnZXIgYW4gYXZvaWRlZCBzdGF0ZS5cbiAgICAgICAgICAvLyBTY2hlZHVsZSBhIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgdXNpbmcgdGhlIEp1c3RcbiAgICAgICAgICAvLyBOb3RpY2VhYmxlIERpZmZlcmVuY2UuXG4gICAgICAgICAgLy8gVE9ETzogSXMgdGhlIEpORCBvcHRpbWl6YXRpb24gd29ydGggdGhlIGFkZGVkIGNvbXBsZXhpdHk/IElmIHRoaXMgaXNcbiAgICAgICAgICAvLyB0aGUgb25seSByZWFzb24gd2UgdHJhY2sgdGhlIGV2ZW50IHRpbWUsIHRoZW4gcHJvYmFibHkgbm90LlxuICAgICAgICAgIC8vIENvbnNpZGVyIHJlbW92aW5nLlxuICAgICAgICAgIHZhciBtb3N0UmVjZW50RXZlbnRUaW1lID0gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcyk7XG4gICAgICAgICAgdmFyIGV2ZW50VGltZU1zID0gbW9zdFJlY2VudEV2ZW50VGltZTtcbiAgICAgICAgICB2YXIgdGltZUVsYXBzZWRNcyA9IG5vdyQxKCkgLSBldmVudFRpbWVNcztcblxuICAgICAgICAgIHZhciBfbXNVbnRpbFRpbWVvdXQgPSBqbmQodGltZUVsYXBzZWRNcykgLSB0aW1lRWxhcHNlZE1zOyAvLyBEb24ndCBib3RoZXIgd2l0aCBhIHZlcnkgc2hvcnQgc3VzcGVuc2UgdGltZS5cblxuXG4gICAgICAgICAgaWYgKF9tc1VudGlsVGltZW91dCA+IDEwKSB7XG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICAgIC8vIHRvIGFycml2ZS5cbiAgICAgICAgICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChjb21taXRSb290LmJpbmQobnVsbCwgcm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMpLCBfbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbW1pdCB0aGUgcGxhY2Vob2xkZXIuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcm9vdCBleGl0IHN0YXR1cy4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFNlYXJjaCB0aGUgcmVuZGVyZWQgdHJlZSBmb3IgZXh0ZXJuYWwgc3RvcmUgcmVhZHMsIGFuZCBjaGVjayB3aGV0aGVyIHRoZVxuICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkIGluIGEgY29uY3VycmVudCBldmVudC4gSW50ZW50aW9uYWxseSB1c2luZyBhbiBpdGVyYXRpdmVcbiAgLy8gbG9vcCBpbnN0ZWFkIG9mIHJlY3Vyc2lvbiBzbyB3ZSBjYW4gZXhpdCBlYXJseS5cbiAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS5mbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IG5vZGUudXBkYXRlUXVldWU7XG5cbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gdXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgICAgIGlmIChjaGVja3MgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gY2hlY2tzW2ldO1xuICAgICAgICAgICAgdmFyIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRWYWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIHJlbmRlcmVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gaW5jb25zaXN0ZW50IHN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYGdldFNuYXBzaG90YCB0aHJvd3MsIHJldHVybiBgZmFsc2VgLiBUaGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgICAgICAgICAgLy8gYSByZS1yZW5kZXIsIGFuZCB0aGUgZXJyb3Igd2lsbCBiZSByZXRocm93biBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9IC8vIEZsb3cgZG9lc24ndCBrbm93IHRoaXMgaXMgdW5yZWFjaGFibGUsIGJ1dCBlc2xpbnQgZG9lc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIC8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbiAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyk7XG4gIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgZ29cbi8vIHRocm91Z2ggU2NoZWR1bGVyXG5cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QpIHtcbiAge1xuICAgIHN5bmNOZXN0ZWRVcGRhdGVGbGFnKCk7XG4gIH1cblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgdmFyIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIE5vTGFuZXMpO1xuXG4gIGlmICghaW5jbHVkZXNTb21lTGFuZShsYW5lcywgU3luY0xhbmUpKSB7XG4gICAgLy8gVGhlcmUncyBubyByZW1haW5pbmcgc3luYyB3b3JrIGxlZnQuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG5cbiAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgIC8vIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsIGluY2x1ZGVzXG4gICAgLy8gYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuICAgIGlmIChlcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuICAvLyB3aWxsIGNvbW1pdCBpdCBldmVuIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBsYW5lcykge1xuICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBtZXJnZUxhbmVzKGxhbmVzLCBTeW5jTGFuZSkpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblxuICB0cnkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5KTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBJZiB0aGVyZSB3ZXJlIGxlZ2FjeSBzeW5jIHVwZGF0ZXMsIGZsdXNoIHRoZW0gYXQgdGhlIGVuZCBvZiB0aGUgb3V0ZXJcbiAgICAvLyBtb3N0IGJhdGNoZWRVcGRhdGVzLWxpa2UgbWV0aG9kLlxuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyhmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgfVxuICB9XG59IC8vIE92ZXJsb2FkIHRoZSBkZWZpbml0aW9uIHRvIHRoZSB0d28gdmFsaWQgc2lnbmF0dXJlcy5cbi8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgZmx1c2ggcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgLy8gbmV4dCBldmVudCwgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIG9uZS5cbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsICYmIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLnRhZyA9PT0gTGVnYWN5Um9vdCAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuXG4gICAgaWYgKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgIC8vIHRoZSBzdGFjay5cblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNBbHJlYWR5UmVuZGVyaW5nKCkge1xuICAvLyBVc2VkIGJ5IHRoZSByZW5kZXJlciB0byBwcmludCBhIHdhcm5pbmcgaWYgY2VydGFpbiBBUElzIGFyZSBjYWxsZWQgZnJvbVxuICAvLyB0aGUgd3JvbmcgY29udGV4dC5cbiAgcmV0dXJuICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQ7XG59XG5mdW5jdGlvbiBmbHVzaENvbnRyb2xsZWQoZm4pIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gIHRyeSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hSZW5kZXJMYW5lcyhmaWJlciwgbGFuZXMpIHtcbiAgcHVzaChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIHN1YnRyZWVSZW5kZXJMYW5lcywgZmliZXIpO1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBtZXJnZUxhbmVzKHN1YnRyZWVSZW5kZXJMYW5lcywgbGFuZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiBwb3BSZW5kZXJMYW5lcyhmaWJlcikge1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcbiAgcG9wKHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAvLyBUaGUgcm9vdCBwcmV2aW91cyBzdXNwZW5kZWQgYW5kIHNjaGVkdWxlZCBhIHRpbWVvdXQgdG8gY29tbWl0IGEgZmFsbGJhY2tcbiAgICAvLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cbiAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7IC8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5cbiAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgd29ya0luUHJvZ3Jlc3MgPSByb290V29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IGxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDtcbiAgZW5xdWV1ZUludGVybGVhdmVkVXBkYXRlcygpO1xuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gIH1cblxuICByZXR1cm4gcm9vdFdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSkge1xuICBkbyB7XG4gICAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICB0cnkge1xuICAgICAgLy8gUmVzZXQgbW9kdWxlLWxldmVsIHN0YXRlIHRoYXQgd2FzIHNldCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTtcbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7IC8vIFRPRE86IEkgZm91bmQgYW5kIGFkZGVkIHRoaXMgbWlzc2luZyBsaW5lIHdoaWxlIGludmVzdGlnYXRpbmcgYVxuICAgICAgLy8gc2VwYXJhdGUgaXNzdWUuIFdyaXRlIGEgcmVncmVzc2lvbiB0ZXN0IHVzaW5nIHN0cmluZyByZWZzLlxuXG4gICAgICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICBpZiAoZXJyb3JlZFdvcmsgPT09IG51bGwgfHwgZXJyb3JlZFdvcmsucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIHRvIGJlIHdvcmtpbmcgb24gYSBub24tcm9vdCBmaWJlci4gVGhpcyBpcyBhIGZhdGFsIGVycm9yXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBhbmNlc3RvciB0aGF0IGNhbiBoYW5kbGUgaXQ7IHRoZSByb290IGlzXG4gICAgICAgIC8vIHN1cHBvc2VkIHRvIGNhcHR1cmUgYWxsIGVycm9ycyB0aGF0IHdlcmVuJ3QgY2F1Z2h0IGJ5IGFuIGVycm9yXG4gICAgICAgIC8vIGJvdW5kYXJ5LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvciA9IHRocm93blZhbHVlOyAvLyBTZXQgYHdvcmtJblByb2dyZXNzYCB0byBudWxsLiBUaGlzIHJlcHJlc2VudHMgYWR2YW5jaW5nIHRvIHRoZSBuZXh0XG4gICAgICAgIC8vIHNpYmxpbmcsIG9yIHRoZSBwYXJlbnQgaWYgdGhlcmUgYXJlIG5vIHNpYmxpbmdzLiBCdXQgc2luY2UgdGhlIHJvb3RcbiAgICAgICAgLy8gaGFzIG5vIHNpYmxpbmdzIG5vciBhIHBhcmVudCwgd2Ugc2V0IGl0IHRvIG51bGwuIFVzdWFsbHkgdGhpcyBpc1xuICAgICAgICAvLyBoYW5kbGVkIGJ5IGBjb21wbGV0ZVVuaXRPZldvcmtgIG9yIGB1bndpbmRXb3JrYCwgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgbm90IGNhbGxpbmcgdGhvc2UsIHdlIG5lZWQgc2V0IGl0IGhlcmUuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGNhbGxpbmcgYHVud2luZFdvcmtgIHRvIHBvcCB0aGUgY29udGV4dHMuXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIGVycm9yZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGJlZm9yZSBhbiBlcnJvciB3YXMgdGhyb3duLiBUaGlzXG4gICAgICAgIC8vIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhXG4gICAgICAgIC8vIHN1c3BlbmRlZCByZW5kZXIuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZXJyb3JlZFdvcmssIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyKSB7XG4gICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG5cbiAgICAgICAgaWYgKHRocm93blZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0aHJvd25WYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRocm93blZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgd2FrZWFibGUgPSB0aHJvd25WYWx1ZTtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50U3VzcGVuZGVkKGVycm9yZWRXb3JrLCB3YWtlYWJsZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtDb21wb25lbnRFcnJvcmVkKGVycm9yZWRXb3JrLCB0aHJvd25WYWx1ZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIGVycm9yZWRXb3JrLnJldHVybiwgZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO1xuICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxuICAgICAgdGhyb3duVmFsdWUgPSB5ZXRBbm90aGVyVGhyb3duVmFsdWU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGVycm9yZWRXb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgIHJldHVybjtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpIHtcbiAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdyQxKCk7XG59XG5mdW5jdGlvbiBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGxhbmUpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gbWVyZ2VMYW5lcyhsYW5lLCB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZCgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gIH0gLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHVwZGF0ZXMgdGhhdCB3ZSBza2lwcGVkIHRyZWUgdGhhdCBtaWdodCBoYXZlIHVuYmxvY2tlZFxuICAvLyB0aGlzIHJlbmRlci5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwgJiYgKGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKSB8fCBpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKSkpIHtcbiAgICAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbiAgICAvLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbiAgICAvLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcihlcnJvcikge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZDtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxufSAvLyBDYWxsZWQgZHVyaW5nIHJlbmRlciB0byBkZXRlcm1pbmUgaWYgYW55dGhpbmcgaGFzIHN1c3BlbmRlZC5cbi8vIFJldHVybnMgZmFsc2UgaWYgd2UncmUgbm90IHN1cmUuXG5cbmZ1bmN0aW9uIHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGVycm9yZWQgb3IgY29tcGxldGVkLCB3ZSBjYW4ndCByZWFsbHkgYmUgc3VyZSxcbiAgLy8gc28gdGhvc2UgYXJlIGZhbHNlLlxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN5bmMgcmVuZGVyLCBzbyB3ZSBzaG91bGQgaGF2ZSBmaW5pc2hlZCB0aGUgd2hvbGUgdHJlZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSAnICsgJ2J1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbn0gLy8gVGhlIHdvcmsgbG9vcCBpcyBhbiBleHRyZW1lbHkgaG90IHBhdGguIFRlbGwgQ2xvc3VyZSBub3QgdG8gaW5saW5lIGl0LlxuXG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAvLyBBbHJlYWR5IHRpbWVkIG91dCwgc28gcGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZC5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gU3RpbGwgd29yayByZW1haW5pbmcuXG4gICAge1xuICAgICAgbWFya1JlbmRlcllpZWxkZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUm9vdEluUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcGxldGVkIHRoZSB0cmVlLlxuICAgIHtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICB9XG59XG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHNldEN1cnJlbnRGaWJlcih1bml0T2ZXb3JrKTtcbiAgdmFyIG5leHQ7XG5cbiAgaWYgKCAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrJDEoY3VycmVudCwgdW5pdE9mV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG4gIC8vIHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlIHBhcmVudCBmaWJlci5cbiAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuXG4gIGRvIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBjb21wbGV0ZWRXb3JrLnJldHVybjsgLy8gQ2hlY2sgaWYgdGhlIHdvcmsgY29tcGxldGVkIG9yIGlmIHNvbWV0aGluZyB0aHJldy5cblxuICAgIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIEluY29tcGxldGUpID09PSBOb0ZsYWdzKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIoY29tcGxldGVkV29yayk7XG4gICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7IC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrKTsgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBsYW5lcy5cblxuXG4gICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3RcbiAgICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgICAgX25leHQuZmxhZ3MgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gX25leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSByZW5kZXIgZHVyYXRpb24gZm9yIHRoZSBmaWJlciB0aGF0IGVycm9yZWQuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpOyAvLyBJbmNsdWRlIHRoZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gZmFpbGVkIGNoaWxkcmVuIGJlZm9yZSBjb250aW51aW5nLlxuXG4gICAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBzdWJ0cmVlIGZsYWdzLlxuICAgICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgICByZXR1cm5GaWJlci5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgdW53b3VuZCBhbGwgdGhlIHdheSB0byB0aGUgcm9vdC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmdGaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcblxuXG4gICAgY29tcGxldGVkV29yayA9IHJldHVybkZpYmVyOyAvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gIH0gd2hpbGUgKGNvbXBsZXRlZFdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCByZWNvdmVyYWJsZUVycm9ycykge1xuICAvLyBUT0RPOiBUaGlzIG5vIGxvbmdlciBtYWtlcyBhbnkgc2Vuc2UuIFdlIGFscmVhZHkgd3JhcCB0aGUgbXV0YXRpb24gYW5kXG4gIC8vIGxheW91dCBwaGFzZXMuIFNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZS5cbiAgdmFyIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblxuICB0cnkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgY29tbWl0Um9vdEltcGwocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3RJbXBsKHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIGRvIHtcbiAgICAvLyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBjYWxsIGBmbHVzaFN5bmNVcGRhdGVRdWV1ZWAgYXQgdGhlIGVuZCwgd2hpY2hcbiAgICAvLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzaXZlIGVmZmVjdHMuIFNvIHdlIG5lZWQgdG8ga2VlcCBmbHVzaGluZyBpbiBhIGxvb3AgdW50aWwgdGhlcmUgYXJlXG4gICAgLy8gbm8gbW9yZSBwZW5kaW5nIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBmbHVzaCBzeW5jaHJvbm91cyB3b3JrIGF0IHRoZSBlbmQsIHRvIGF2b2lkIGZhY3RvcmluZyBoYXphcmRzIGxpa2UgdGhpcy5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gd2hpbGUgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKTtcblxuICBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKTtcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgdmFyIGxhbmVzID0gcm9vdC5maW5pc2hlZExhbmVzO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBpZiAoZmluaXNoZWRXb3JrID09PSBudWxsKSB7XG5cbiAgICB7XG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgICBlcnJvcigncm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgJyArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5ICcgKyAnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9IC8vIGNvbW1pdFJvb3QgbmV2ZXIgcmV0dXJucyBhIGNvbnRpbnVhdGlvbjsgaXQgYWx3YXlzIGZpbmlzaGVzIHN5bmNocm9ub3VzbHkuXG4gIC8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxuXG5cbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7IC8vIFVwZGF0ZSB0aGUgZmlyc3QgYW5kIGxhc3QgcGVuZGluZyB0aW1lcyBvbiB0aGlzIHJvb3QuIFRoZSBuZXcgZmlyc3RcbiAgLy8gcGVuZGluZyB0aW1lIGlzIHdoYXRldmVyIGlzIGxlZnQgb24gdGhlIHJvb3QgZmliZXIuXG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzID0gbWVyZ2VMYW5lcyhmaW5pc2hlZFdvcmsubGFuZXMsIGZpbmlzaGVkV29yay5jaGlsZExhbmVzKTtcbiAgbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcyk7XG5cbiAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFdlIGNhbiByZXNldCB0aGVzZSBub3cgdGhhdCB0aGV5IGFyZSBmaW5pc2hlZC5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvIHByb2Nlc3MgdGhlbS5cbiAgLy8gRG8gdGhpcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gaXQgaXMgcXVldWVkIGJlZm9yZSBhbnl0aGluZyBlbHNlIHRoYXRcbiAgLy8gbWlnaHQgZ2V0IHNjaGVkdWxlZCBpbiB0aGUgY29tbWl0IHBoYXNlLiAoU2VlICMxNjcxNC4pXG4gIC8vIFRPRE86IERlbGV0ZSBhbGwgb3RoZXIgcGxhY2VzIHRoYXQgc2NoZWR1bGUgdGhlIHBhc3NpdmUgZWZmZWN0IGNhbGxiYWNrXG4gIC8vIFRoZXkncmUgcmVkdW5kYW50LlxuXG5cbiAgaWYgKChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzIHx8IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpOyAvLyBUaGlzIHJlbmRlciB0cmlnZ2VyZWQgcGFzc2l2ZSBlZmZlY3RzOiByZWxlYXNlIHRoZSByb290IGNhY2hlIHBvb2xcbiAgICAgICAgLy8gKmFmdGVyKiBwYXNzaXZlIGVmZmVjdHMgZmlyZSB0byBhdm9pZCBmcmVlaW5nIGEgY2FjaGUgcG9vbCB0aGF0IG1heVxuICAgICAgICAvLyBiZSByZWZlcmVuY2VkIGJ5IGEgbm9kZSBpbiB0aGUgdHJlZSAoSG9zdFJvb3QsIENhY2hlIGJvdW5kYXJ5IGV0YylcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IGVmZmVjdHMgaW4gdGhlIHdob2xlIHRyZWUuXG4gIC8vIFRPRE86IFRoaXMgaXMgbGVmdCBvdmVyIGZyb20gdGhlIGVmZmVjdCBsaXN0IGltcGxlbWVudGF0aW9uLCB3aGVyZSB3ZSBoYWRcbiAgLy8gdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYGZpcnN0RWZmZWN0YCB0byBzYXRpc2Z5IEZsb3cuIEkgdGhpbmsgdGhlXG4gIC8vIG9ubHkgb3RoZXIgcmVhc29uIHRoaXMgb3B0aW1pemF0aW9uIGV4aXN0cyBpcyBiZWNhdXNlIGl0IGFmZmVjdHMgcHJvZmlsaW5nLlxuICAvLyBSZWNvbnNpZGVyIHdoZXRoZXIgdGhpcyBpcyBuZWNlc3NhcnkuXG5cblxuICB2YXIgc3VidHJlZUhhc0VmZmVjdHMgPSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIChCZWZvcmVNdXRhdGlvbk1hc2sgfCBNdXRhdGlvbk1hc2sgfCBMYXlvdXRNYXNrIHwgUGFzc2l2ZU1hc2spKSAhPT0gTm9GbGFncztcbiAgdmFyIHJvb3RIYXNFZmZlY3QgPSAoZmluaXNoZWRXb3JrLmZsYWdzICYgKEJlZm9yZU11dGF0aW9uTWFzayB8IE11dGF0aW9uTWFzayB8IExheW91dE1hc2sgfCBQYXNzaXZlTWFzaykpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChzdWJ0cmVlSGFzRWZmZWN0cyB8fCByb290SGFzRWZmZWN0KSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDsgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3NcbiAgICAvLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuICAgIC8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4gICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbiAgICAvLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbiAgICAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG5cbiAgICB2YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cblxuXG4gICAgY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBsYXlvdXQgcGhhc2UsIHNvIHRoYXQgdGhlIGZpbmlzaGVkXG4gICAgLy8gd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuXG4gICAgY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgICAvLyBvcHBvcnR1bml0eSB0byBwYWludC5cblxuXG4gICAgcmVxdWVzdFBhaW50KCk7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBSZXNldCB0aGUgcHJpb3JpdHkgdG8gdGhlIHByZXZpb3VzIG5vbi1zeW5jIHZhbHVlLlxuXG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGVmZmVjdHMuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuICAgIC8vIG5vIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gcmVwb3J0IHRoaXMuXG5cbiAgICB7XG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPSByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cztcblxuICBpZiAocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3RcbiAgICAvLyBzY2hlZHVsZSBhIGNhbGxiYWNrIHVudGlsIGFmdGVyIGZsdXNoaW5nIGxheW91dCB3b3JrLlxuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290O1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gbGFuZXM7XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuICAvLyBUT0RPOiBUaGlzIGlzIHBhcnQgb2YgdGhlIGBjb21wb25lbnREaWRDYXRjaGAgaW1wbGVtZW50YXRpb24uIEl0cyBwdXJwb3NlXG4gIC8vIGlzIHRvIGRldGVjdCB3aGV0aGVyIHNvbWV0aGluZyBtaWdodCBoYXZlIGNhbGxlZCBzZXRTdGF0ZSBpbnNpZGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYC4gVGhlIG1lY2hhbmlzbSBpcyBrbm93biB0byBiZSBmbGF3ZWQgYmVjYXVzZSBgc2V0U3RhdGVgXG4gIC8vIGluc2lkZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGlzIGl0c2VsZiBmbGF3ZWQg4oCUIHRoYXQncyB3aHkgd2UgcmVjb21tZW5kXG4gIC8vIGBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3JgIGluc3RlYWQuIEhvd2V2ZXIsIGl0IGNvdWxkIGJlIGltcHJvdmVkIGJ5XG4gIC8vIGNoZWNraW5nIGlmIHJlbWFpbmluZ0xhbmVzIGluY2x1ZGVzIFN5bmMgd29yaywgaW5zdGVhZCBvZiB3aGV0aGVyIHRoZXJlJ3NcbiAgLy8gYW55IHdvcmsgcmVtYWluaW5nIGF0IGFsbCAod2hpY2ggd291bGQgYWxzbyBpbmNsdWRlIHN0dWZmIGxpa2UgU3VzcGVuc2VcbiAgLy8gcmV0cmllcyBvciB0cmFuc2l0aW9ucykuIEl0J3MgYmVlbiBsaWtlIHRoaXMgZm9yIGEgd2hpbGUsIHRob3VnaCwgc28gZml4aW5nXG4gIC8vIGl0IHByb2JhYmx5IGlzbid0IHRoYXQgdXJnZW50LlxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG4gICAgLy8gZXJyb3IgYm91bmRhcmllcy5cbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKCFyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QkMSgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93JDEoKSk7XG5cbiAgaWYgKHJlY292ZXJhYmxlRXJyb3JzICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUgd2VyZSBlcnJvcnMgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgcmVjb3ZlcmVkIGZyb20gdGhlbSB3aXRob3V0XG4gICAgLy8gbmVlZGluZyB0byBzdXJmYWNlIGl0IHRvIHRoZSBVSS4gV2UgbG9nIHRoZW0gaGVyZS5cbiAgICB2YXIgb25SZWNvdmVyYWJsZUVycm9yID0gcm9vdC5vblJlY292ZXJhYmxlRXJyb3I7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVjb3ZlcmFibGVFcnJvciA9IHJlY292ZXJhYmxlRXJyb3JzW2ldO1xuICAgICAgb25SZWNvdmVyYWJsZUVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciQxID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3IkMTtcbiAgfSAvLyBJZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgcmVuZGVyLCBmbHVzaCB0aGVtXG4gIC8vIHN5bmNocm9ub3VzbHkgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0YXNrIHNvIHRoYXQgdGhlIHJlc3VsdCBpc1xuICAvLyBpbW1lZGlhdGVseSBvYnNlcnZhYmxlLiBPdGhlcndpc2UsIHdlIGFzc3VtZSB0aGF0IHRoZXkgYXJlIG5vdFxuICAvLyBvcmRlci1kZXBlbmRlbnQgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIG9ic2VydmVkIGJ5IGV4dGVybmFsIHN5c3RlbXMsIHNvIHdlXG4gIC8vIGNhbiB3YWl0IHVudGlsIGFmdGVyIHBhaW50LlxuICAvLyBUT0RPOiBXZSBjYW4gb3B0aW1pemUgdGhpcyBieSBub3Qgc2NoZWR1bGluZyB0aGUgY2FsbGJhY2sgZWFybGllci4gU2luY2Ugd2VcbiAgLy8gY3VycmVudGx5IHNjaGVkdWxlIHRoZSBjYWxsYmFjayBpbiBtdWx0aXBsZSBwbGFjZXMsIHdpbGwgd2FpdCB1bnRpbCB0aG9zZVxuICAvLyBhcmUgY29uc29saWRhdGVkLlxuXG5cbiAgaWYgKGluY2x1ZGVzU29tZUxhbmUocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMsIFN5bmNMYW5lKSAmJiByb290LnRhZyAhPT0gTGVnYWN5Um9vdCkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGEgcGFzc2l2ZSBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzLCBTeW5jTGFuZSkpIHtcbiAgICB7XG4gICAgICBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCk7XG4gICAgfSAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4gICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cblxuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9IC8vIElmIGxheW91dCB3b3JrIHdhcyBzY2hlZHVsZWQsIGZsdXNoIGl0IG5vdy5cblxuXG4gIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gIC8vIFJldHVybnMgd2hldGhlciBwYXNzaXZlIGVmZmVjdHMgd2VyZSBmbHVzaGVkLlxuICAvLyBUT0RPOiBDb21iaW5lIHRoaXMgY2hlY2sgd2l0aCB0aGUgb25lIGluIGZsdXNoUGFzc2l2ZUVGZmVjdHNJbXBsLiBXZSBzaG91bGRcbiAgLy8gcHJvYmFibHkganVzdCBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zLiBJIGJlbGlldmUgdGhleSB3ZXJlIG9ubHkgc2VwYXJhdGVcbiAgLy8gaW4gdGhlIGZpcnN0IHBsYWNlIGJlY2F1c2Ugd2UgdXNlZCB0byB3cmFwIGl0IHdpdGhcbiAgLy8gYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLCB3aGljaCBhY2NlcHRzIGEgZnVuY3Rpb24uIEJ1dCBub3cgd2UgdHJhY2sgdGhlXG4gIC8vIHByaW9yaXR5IHdpdGhpbiBSZWFjdCBpdHNlbGYsIHNvIHdlIGNhbiBtdXRhdGUgdGhlIHZhcmlhYmxlIGRpcmVjdGx5LlxuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwpIHtcbiAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyk7XG4gICAgdmFyIHByaW9yaXR5ID0gbG93ZXJFdmVudFByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5LCByZW5kZXJQcmlvcml0eSk7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgICB0cnkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICByZXR1cm4gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247IC8vIE9uY2UgcGFzc2l2ZSBlZmZlY3RzIGhhdmUgcnVuIGZvciB0aGUgdHJlZSAtIGdpdmluZyBjb21wb25lbnRzIGFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaWJlcikge1xuICB7XG4gICAgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMucHVzaChmaWJlcik7XG5cbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDsgLy8gVE9ETzogVGhpcyBpcyBzb21ldGltZXMgb3V0IG9mIHN5bmMgd2l0aCByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy5cbiAgLy8gRmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gSXQncyBub3QgY2F1c2luZyBhbnkga25vd24gaXNzdWVzIChwcm9iYWJseVxuICAvLyBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBwcm9maWxpbmcpLCBidXQgaXQncyBhIHJlZmFjdG9yIGhhemFyZC5cblxuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKHJvb3QuY3VycmVudCk7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgcm9vdC5jdXJyZW50KTsgLy8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG5cbiAge1xuICAgIHZhciBwcm9maWxlckVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cztcbiAgICBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9maWxlckVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfZmliZXIgPSBwcm9maWxlckVmZmVjdHNbaV07XG4gICAgICBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKHJvb3QsIF9maWJlcik7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgfVxuXG4gIHtcbiAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCB0cnVlKTtcbiAgfVxuXG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7IC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cblxuICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCA/IDAgOiBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgKyAxOyAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuICBvblBvc3RDb21taXRSb290KHJvb3QpO1xuXG4gIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gcm9vdC5jdXJyZW50LnN0YXRlTm9kZTtcbiAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gIGlmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9PT0gbnVsbCkge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbaW5zdGFuY2VdKTtcbiAgfSBlbHNlIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQoaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcihlcnJvcikge1xuICBpZiAoIWhhc1VuY2F1Z2h0RXJyb3IpIHtcbiAgICBoYXNVbmNhdWdodEVycm9yID0gdHJ1ZTtcbiAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG52YXIgb25VbmNhdWdodEVycm9yID0gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yO1xuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciwgc291cmNlRmliZXIpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gIGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCB1cGRhdGUpO1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHJvb3RGaWJlciwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lLCBldmVudFRpbWUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKHNvdXJjZUZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciQxKSB7XG4gIGlmIChzb3VyY2VGaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuICAgIC8vIGl0c2VsZiBzaG91bGQgY2FwdHVyZSBpdC5cbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChzb3VyY2VGaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvcjtcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChmaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGN0b3IgPSBmaWJlci50eXBlO1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUoZXJyb3IkMSwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICAvLyBUT0RPOiBVbnRpbCB3ZSByZS1sYW5kIHNraXBVbm1vdW50ZWRCb3VuZGFyaWVzIChzZWUgIzIwMTQ3KSwgdGhpcyB3YXJuaW5nXG4gICAgLy8gd2lsbCBmaXJlIGZvciBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGJ5IGRlc3Ryb3kgZnVuY3Rpb25zIGluc2lkZSBkZWxldGVkXG4gICAgLy8gdHJlZXMuIFdoYXQgaXQgc2hvdWxkIGluc3RlYWQgZG8gaXMgcHJvcGFnYXRlIHRoZSBlcnJvciB0byB0aGUgcGFyZW50IG9mXG4gICAgLy8gdGhlIGRlbGV0ZWQgdHJlZS4gSW4gdGhlIG1lYW50aW1lLCBkbyBub3QgYWRkIHRoaXMgd2FybmluZyB0byB0aGVcbiAgICAvLyBhbGxvd2xpc3Q7IHRoaXMgaXMgb25seSBmb3Igb3VyIGludGVybmFsIHVzZS5cbiAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yICcgKyAnaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIExpa2VseSAnICsgJ2NhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuICcgKyAnYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuJyArICdFcnJvciBtZXNzYWdlOlxcblxcbiVzJywgZXJyb3IkMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG5cbiAgaWYgKHBpbmdDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpO1xuICB3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVihyb290KTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93JDEoKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUykge1xuICAgICAgLy8gUmVzdGFydCBmcm9tIHRoZSByb290LlxuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbiAgICAgIC8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICB9XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbn1cblxuZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG4gIC8vIHByZXZpb3VzbHkgd2FzIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0XG4gIC8vIHN1c3BlbmRlZCBpdCBoYXMgcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzXG4gIC8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGxhbmVzLlxuICBpZiAocmV0cnlMYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBUT0RPOiBBc3NpZ24gdGhpcyB0byBgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmVgPyB0byBhdm9pZFxuICAgIC8vIHVubmVjZXNzYXJ5IGVudGFuZ2xlbWVudD9cbiAgICByZXRyeUxhbmUgPSByZXF1ZXN0UmV0cnlMYW5lKGJvdW5kYXJ5RmliZXIpO1xuICB9IC8vIFRPRE86IFNwZWNpYWwgY2FzZSBpZGxlIHByaW9yaXR5P1xuXG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHJldHJ5TGFuZSwgZXZlbnRUaW1lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICByZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJldHJ5V2FrZWFibGUoYm91bmRhcnlGaWJlciwgd2FrZWFibGUpIHtcbiAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTsgLy8gRGVmYXVsdFxuXG4gIHZhciByZXRyeUNhY2hlO1xuXG4gIHtcbiAgICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gJyArICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuICByZXR1cm4gdGltZUVsYXBzZWQgPCAxMjAgPyAxMjAgOiB0aW1lRWxhcHNlZCA8IDQ4MCA/IDQ4MCA6IHRpbWVFbGFwc2VkIDwgMTA4MCA/IDEwODAgOiB0aW1lRWxhcHNlZCA8IDE5MjAgPyAxOTIwIDogdGltZUVsYXBzZWQgPCAzMDAwID8gMzAwMCA6IHRpbWVFbGFwc2VkIDwgNDMyMCA/IDQzMjAgOiBjZWlsKHRpbWVFbGFwc2VkIC8gMTk2MCkgKiAxOTYwO1xufVxuXG5mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgJ3JlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgJyArICdjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvICcgKyAncHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgICBlcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcgKyBcImNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgXCIgKyAnaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gJyArICdldmVyeSByZW5kZXIuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpIHtcbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTtcblxuICAgIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihmaWJlciwgaGFzUGFzc2l2ZUVmZmVjdHMpIHtcbiAge1xuICAgIC8vIFRPRE8gKFN0cmljdEVmZmVjdHMpIFNob3VsZCB3ZSBzZXQgYSBtYXJrZXIgb24gdGhlIHJvb3QgaWYgaXQgY29udGFpbnMgc3RyaWN0IGVmZmVjdHNcbiAgICAvLyBzbyB3ZSBkb24ndCB0cmF2ZXJzZSB1bm5lY2Vzc2FyaWx5PyBzaW1pbGFyIHRvIHN1YnRyZWVGbGFncyBidXQganVzdCBhdCB0aGUgcm9vdCBsZXZlbC5cbiAgICAvLyBNYXliZSBub3QgYSBiaWcgZGVhbCBzaW5jZSB0aGlzIGlzIERFViBvbmx5IGJlaGF2aW9yLlxuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudExheW91dERldiwgaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWKTtcblxuICAgIGlmIChoYXNQYXNzaXZlRWZmZWN0cykge1xuICAgICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudFBhc3NpdmVEZXYsIGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYpO1xuICAgIH1cblxuICAgIGludm9rZUVmZmVjdHNJbkRldihmaWJlciwgTW91bnRMYXlvdXREZXYsIGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYpO1xuXG4gICAgaWYgKGhhc1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsIE1vdW50UGFzc2l2ZURldiwgaW52b2tlUGFzc2l2ZUVmZmVjdE1vdW50SW5ERVYpO1xuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlRWZmZWN0c0luRGV2KGZpcnN0Q2hpbGQsIGZpYmVyRmxhZ3MsIGludm9rZUVmZmVjdEZuKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICB2YXIgY3VycmVudCA9IGZpcnN0Q2hpbGQ7XG4gICAgdmFyIHN1YnRyZWVSb290ID0gbnVsbDtcblxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJpbWFyeVN1YnRyZWVGbGFnID0gY3VycmVudC5zdWJ0cmVlRmxhZ3MgJiBmaWJlckZsYWdzO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gc3VidHJlZVJvb3QgJiYgY3VycmVudC5jaGlsZCAhPT0gbnVsbCAmJiBwcmltYXJ5U3VidHJlZUZsYWcgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBmaWJlckZsYWdzKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIGludm9rZUVmZmVjdEZuKGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IHN1YnRyZWVSb290ID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG4gICAgaWYgKHRhZyAhPT0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCAmJiB0YWcgIT09IEhvc3RSb290ICYmIHRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgdGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiB0YWcgIT09IEZvcndhcmRSZWYgJiYgdGFnICE9PSBNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCkge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBiZWdpbldvcmskMTtcblxue1xuICB2YXIgZHVtbXlGaWJlciA9IG51bGw7XG5cbiAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbiAgICAvLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4gICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuICAgIC8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG4gICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgIH0gLy8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTsgLy8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbiAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG4gICAgICAvLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxuXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgdW5pdE9mV29yayk7IC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuXG4gICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cbiAgICAgIGlmICggdW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICB9IC8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5cblxuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGJlZ2luV29yaywgbnVsbCwgY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICB2YXIgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYXlFcnJvciA9PT0gJ29iamVjdCcgJiYgcmVwbGF5RXJyb3IgIT09IG51bGwgJiYgcmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZyAmJiB0eXBlb2Ygb3JpZ2luYWxFcnJvciA9PT0gJ29iamVjdCcgJiYgb3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiAhb3JpZ2luYWxFcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgLy8gSWYgc3VwcHJlc3NlZCwgbGV0IHRoZSBmbGFnIGNhcnJ5IG92ZXIgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHdoaWNoIGlzIHRoZSBvbmUgd2UnbGwgcmV0aHJvdy5cbiAgICAgICAgICBvcmlnaW5hbEVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlIGFsd2F5cyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gY2FzZSB0aGUgc2Vjb25kIHJlbmRlciBwYXNzIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGEgbWVtb2l6ZWQgZnVuY3Rpb24gb3IgQ29tbW9uSlMgbW9kdWxlIGRvZXNuJ3QgdGhyb3cgYWZ0ZXIgZmlyc3QgaW52b2NhdGlvbi5cblxuXG4gICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiAhZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDb21wb25lbnROYW1lID0gd29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgJyArICdkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCAnICsgJ2ZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXInLCBzZXRTdGF0ZUNvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSAnICsgJ2Z1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4nKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcykge1xuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgIG1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBzY2hlZHVsaW5nRmliZXIsIGxhbmVzKTtcbiAgICAgIH0pOyAvLyBUaGlzIGZ1bmN0aW9uIGludGVudGlvbmFsbHkgZG9lcyBub3QgY2xlYXIgbWVtb2l6ZWQgdXBkYXRlcnMuXG4gICAgICAvLyBUaG9zZSBtYXkgc3RpbGwgYmUgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgY29tbWl0XG4gICAgICAvLyBhbmQgYSBmdXR1cmUgb25lIChlLmcuIFN1c3BlbnNlKS5cbiAgICB9XG4gIH1cbn1cbnZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlID0ge307XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2skMShwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICB7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhbiBgYWN0YCBzY29wZSwgYnlwYXNzIFNjaGVkdWxlciBhbmQgcHVzaCB0b1xuICAgIC8vIHRoZSBgYWN0YCBxdWV1ZSBpbnN0ZWFkLlxuICAgIHZhciBhY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudDtcblxuICAgIGlmIChhY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgYWN0UXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSkge1xuICBpZiAoIGNhbGxiYWNrTm9kZSA9PT0gZmFrZUFjdENhbGxiYWNrTm9kZSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBJbiBwcm9kdWN0aW9uLCBhbHdheXMgY2FsbCBTY2hlZHVsZXIuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdHJpcHBlZCBvdXQuXG5cblxuICByZXR1cm4gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkge1xuICAvLyBOZXZlciBmb3JjZSBmbHVzaCBpbiBwcm9kdWN0aW9uLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBnZXQgc3RyaXBwZWQgb3V0LlxuICByZXR1cm4gIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICBpZiAoIWlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkpIHtcbiAgICAgICAgLy8gTm90IGluIGFuIGFjdCBlbnZpcm9ubWVudC4gTm8gbmVlZCB0byB3YXJuLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlZ2FjeSBtb2RlIGhhcyBhZGRpdGlvbmFsIGNhc2VzIHdoZXJlIHdlIHN1cHByZXNzIGEgd2FybmluZy5cbiAgICAgIGlmICghaXNMZWdhY3lBY3RFbnZpcm9ubWVudCgpKSB7XG4gICAgICAgIC8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIExlZ2FjeSBtb2RlIGRvZXNuJ3Qgd2FybiBpZiB0aGUgdXBkYXRlIGlzIGJhdGNoZWQsIGkuZS5cbiAgICAgICAgLy8gYmF0Y2hlZFVwZGF0ZXMgb3IgZmx1c2hTeW5jLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWJlci50YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gRm9yd2FyZFJlZiAmJiBmaWJlci50YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggcHJlLWhvb2tzIGNvZGUsIGxlZ2FjeSBtb2RlIG9ubHlcbiAgICAgICAgLy8gd2FybnMgZm9yIHVwZGF0ZXMgdGhhdCBvcmlnaW5hdGUgZnJvbSBhIGhvb2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSAnICsgJ3dyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0JywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYocm9vdCkge1xuICB7XG4gICAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50ICcgKyAnd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgJyArICdpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2RlcyAqL1xudmFyIHJlc29sdmVGYW1pbHkgPSBudWxsOyAvLyAkRmxvd0ZpeE1lIEZsb3cgZ2V0cyBjb25mdXNlZCBieSBhIFdlYWtTZXQgZmVhdHVyZSBjaGVjayBiZWxvdy5cblxudmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xudmFyIHNldFJlZnJlc2hIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAge1xuICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgLy8gTm8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMuXG4gIHJldHVybiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZWFsIGZvcndhcmRSZWYuIERvbid0IHdhbnQgdG8gY3Jhc2ggZWFybHkuXG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHR5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEZvcndhcmRSZWYgaXMgc3BlY2lhbCBiZWNhdXNlIGl0cyByZXNvbHZlZCAudHlwZSBpcyBhbiBvYmplY3QsXG4gICAgICAgIC8vIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgd2Ugb25seSBoYXZlIGl0cyBpbm5lciByZW5kZXIgZnVuY3Rpb24gaW4gdGhlIG1hcC5cbiAgICAgICAgLy8gSWYgdGhhdCBpbm5lciByZW5kZXIgZnVuY3Rpb24gaXMgZGlmZmVyZW50LCB3ZSdsbCBidWlsZCBhIG5ldyBmb3J3YXJkUmVmIHR5cGUuXG4gICAgICAgIHZhciBjdXJyZW50UmVuZGVyID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKTtcblxuICAgICAgICBpZiAodHlwZS5yZW5kZXIgIT09IGN1cnJlbnRSZW5kZXIpIHtcbiAgICAgICAgICB2YXIgc3ludGhldGljVHlwZSA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgICAgICAgICAgcmVuZGVyOiBjdXJyZW50UmVuZGVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5bnRoZXRpY1R5cGUuZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzeW50aGV0aWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGZpYmVyLCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICB2YXIgbmV4dFR5cGUgPSBlbGVtZW50LnR5cGU7IC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBrbm93IHR5cGVzIGFyZW4ndCA9PT0gZXF1YWwuXG5cbiAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSBmYWxzZTtcbiAgICB2YXIgJCR0eXBlb2ZOZXh0VHlwZSA9IHR5cGVvZiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgbmV4dFR5cGUgIT09IG51bGwgPyBuZXh0VHlwZS4kJHR5cGVvZiA6IG51bGw7XG5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBpbm5lciB0eXBlIHlldC5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHRoZSBsYXp5IGlubmVyIHR5cGUgaXMgc3RhYmxlLFxuICAgICAgICAgICAgLy8gYW5kIHNvIGl0IGlzIHN1ZmZpY2llbnQgdG8gYXZvaWQgcmVjb25jaWxpbmcgaXQgYXdheS5cbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byB1bndyYXAgb3IgYWN0dWFsbHkgdXNlIHRoZSBuZXcgbGF6eSB0eXBlLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiBpdCB3YXMgYnV0IGNhbiBubyBsb25nZXIgYmUgc2ltcGxlLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IHNldCB0aGlzLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgaWYgYm90aCB0eXBlcyBoYXZlIGEgZmFtaWx5IGFuZCBpdCdzIHRoZSBzYW1lIG9uZS5cblxuXG4gICAgaWYgKG5lZWRzQ29tcGFyZUZhbWlsaWVzKSB7XG4gICAgICAvLyBOb3RlOiBtZW1vKCkgYW5kIGZvcndhcmRSZWYoKSB3ZSdsbCBjb21wYXJlIG91dGVyIHJhdGhlciB0aGFuIGlubmVyIHR5cGUuXG4gICAgICAvLyBUaGlzIG1lYW5zIGJvdGggb2YgdGhlbSBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdG8gcHJlc2VydmUgc3RhdGUuXG4gICAgICAvLyBJZiB3ZSB1bndyYXBwZWQgYW5kIGNvbXBhcmVkIHRoZSBpbm5lciB0eXBlcyBmb3Igd3JhcHBlcnMgaW5zdGVhZCxcbiAgICAgIC8vIHRoZW4gd2Ugd291bGQgcmlzayBmYWxzZWx5IHNheWluZyB0d28gc2VwYXJhdGUgbWVtbyhGb28pXG4gICAgICAvLyBjYWxscyBhcmUgZXF1aXZhbGVudCBiZWNhdXNlIHRoZXkgd3JhcCB0aGUgc2FtZSBGb28gZnVuY3Rpb24uXG4gICAgICB2YXIgcHJldkZhbWlseSA9IHJlc29sdmVGYW1pbHkocHJldlR5cGUpO1xuXG4gICAgICBpZiAocHJldkZhbWlseSAhPT0gdW5kZWZpbmVkICYmIHByZXZGYW1pbHkgPT09IHJlc29sdmVGYW1pbHkobmV4dFR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgV2Vha1NldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcik7XG4gIH1cbn1cbnZhciBzY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgdXBkYXRlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IHVwZGF0ZS5zdGFsZUZhbWlsaWVzLFxuICAgICAgICB1cGRhdGVkRmFtaWxpZXMgPSB1cGRhdGUudXBkYXRlZEZhbWlsaWVzO1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVSb290ID0gZnVuY3Rpb24gKHJvb3QsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290LmNvbnRleHQgIT09IGVtcHR5Q29udGV4dE9iamVjdCkge1xuICAgICAgLy8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG4gICAgICAvLyBidXQgd2UgZG9uJ3Qga25vdyB0aGUgcGFyZW50Q29tcG9uZW50IHNvIHdlIGNhbid0IHBhc3MgaXQuXG4gICAgICAvLyBKdXN0IGlnbm9yZS4gV2UnbGwgZGVsZXRlIHRoaXMgd2l0aCBfcmVuZGVyU3VidHJlZSBjb2RlIHBhdGggbGF0ZXIuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoZmliZXIsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZHNSZW5kZXIgPSBmYWxzZTtcbiAgICB2YXIgbmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSk7XG5cbiAgICAgIGlmIChmYW1pbHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RhbGVGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRzUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQpIHtcbiAgICAgIGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCB8fCBuZWVkc1JlbmRlcikge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiAhbmVlZHNSZW1vdW50KSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGNoaWxkLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgZmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBob3N0SW5zdGFuY2VzID0gbmV3IFNldCgpO1xuICAgIHZhciB0eXBlcyA9IG5ldyBTZXQoZmFtaWxpZXMubWFwKGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgICB9KSk7XG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIHJldHVybiBob3N0SW5zdGFuY2VzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoZmliZXIsIHR5cGVzLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZGlkTWF0Y2ggPSBmYWxzZTtcblxuICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZXMuaGFzKGNhbmRpZGF0ZVR5cGUpKSB7XG4gICAgICAgIGRpZE1hdGNoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlkTWF0Y2gpIHtcbiAgICAgIC8vIFdlIGhhdmUgYSBtYXRjaC4gVGhpcyBvbmx5IGRyaWxscyBkb3duIHRvIHRoZSBjbG9zZXN0IGhvc3QgY29tcG9uZW50cy5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2ggZGVlcGVyIGJlY2F1c2UgZm9yIHRoZSBwdXJwb3NlIG9mIGdpdmluZ1xuICAgICAgLy8gdmlzdWFsIGZlZWRiYWNrLCBcImZsYXNoaW5nXCIgb3V0ZXJtb3N0IHBhcmVudCByZWN0YW5nbGVzIGlzIHN1ZmZpY2llbnQuXG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBtYXRjaCwgbWF5YmUgdGhlcmUgd2lsbCBiZSBvbmUgZnVydGhlciBkb3duIGluIHRoZSBjaGlsZCB0cmVlLlxuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShjaGlsZCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoc2libGluZywgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcblxuICAgIGlmIChmb3VuZEhvc3RJbnN0YW5jZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueSBob3N0IGNoaWxkcmVuLCBmYWxsYmFjayB0byBjbG9zZXN0IGhvc3QgcGFyZW50LlxuXG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gcmVhY2ggcm9vdCBmaXJzdC4nKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICAvLyBXZSBnb3QgYSBtYXRjaC5cbiAgICAgICAgZm91bmRIb3N0SW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpOyAvLyBUaGVyZSBtYXkgc3RpbGwgYmUgbW9yZSwgc28ga2VlcCBzZWFyY2hpbmcuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuZWxlbWVudFR5cGUgPSBudWxsO1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7IC8vIEZpYmVyXG5cbiAgdGhpcy5yZXR1cm4gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG4gIHRoaXMucmVmID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB0aGlzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gIHRoaXMubW9kZSA9IG1vZGU7IC8vIEVmZmVjdHNcblxuICB0aGlzLmZsYWdzID0gTm9GbGFncztcbiAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gIHRoaXMubGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIC8vIE5vdGU6IFRoZSBmb2xsb3dpbmcgaXMgZG9uZSB0byBhdm9pZCBhIHY4IHBlcmZvcm1hbmNlIGNsaWZmLlxuICAgIC8vXG4gICAgLy8gSW5pdGlhbGl6aW5nIHRoZSBmaWVsZHMgYmVsb3cgdG8gc21pcyBhbmQgbGF0ZXIgdXBkYXRpbmcgdGhlbSB3aXRoXG4gICAgLy8gZG91YmxlIHZhbHVlcyB3aWxsIGNhdXNlIEZpYmVycyB0byBlbmQgdXAgaGF2aW5nIHNlcGFyYXRlIHNoYXBlcy5cbiAgICAvLyBUaGlzIGJlaGF2aW9yL2J1ZyBoYXMgc29tZXRoaW5nIHRvIGRvIHdpdGggT2JqZWN0LnByZXZlbnRFeHRlbnNpb24oKS5cbiAgICAvLyBGb3J0dW5hdGVseSB0aGlzIG9ubHkgaW1wYWN0cyBERVYgYnVpbGRzLlxuICAgIC8vIFVuZm9ydHVuYXRlbHkgaXQgbWFrZXMgUmVhY3QgdW51c2FibHkgc2xvdyBmb3Igc29tZSBhcHBsaWNhdGlvbnMuXG4gICAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgaW5pdGlhbGl6ZSB0aGUgZmllbGRzIGJlbG93IHdpdGggZG91Ymxlcy5cbiAgICAvL1xuICAgIC8vIExlYXJuIG1vcmUgYWJvdXQgdGhpcyBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQzNjVcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD04NTM4XG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IE51bWJlci5OYU47XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjsgLy8gSXQncyBva2F5IHRvIHJlcGxhY2UgdGhlIGluaXRpYWwgZG91YmxlcyB3aXRoIHNtaXMgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgLy8gVGhpcyB3b24ndCB0cmlnZ2VyIHRoZSBwZXJmb3JtYW5jZSBjbGlmZiBtZW50aW9uZWQgYWJvdmUsXG4gICAgLy8gYW5kIGl0IHNpbXBsaWZpZXMgb3RoZXIgcHJvZmlsZXIgY29kZSAoaW5jbHVkaW5nIERldlRvb2xzKS5cblxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIC8vIFRoaXMgaXNuJ3QgZGlyZWN0bHkgdXNlZCBidXQgaXMgaGFuZHkgZm9yIGRlYnVnZ2luZyBpbnRlcm5hbHM6XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuXG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuXG5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgIXNob3VsZENvbnN0cnVjdCQxKHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSA/IENsYXNzQ29tcG9uZW50IDogRnVuY3Rpb25Db21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICB9XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzOyAvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH0gLy8gUmVzZXQgYWxsIGVmZmVjdHMgZXhjZXB0IHN0YXRpYyBvbmVzLlxuICAvLyBTdGF0aWMgZWZmZWN0cyBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgU3RhdGljTWFzaztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbiAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gIHZhciBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgIGZpcnN0Q29udGV4dDogY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHRcbiAgfTsgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gIH1cblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufSAvLyBVc2VkIHRvIHJldXNlIGEgRmliZXIgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgcmVzZXRzIHRoZSBGaWJlciB0byB3aGF0IGNyZWF0ZUZpYmVyIG9yIGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkXG4gIC8vIGhhdmUgc2V0IHRoZSB2YWx1ZXMgdG8gYmVmb3JlIGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSWRlYWxseSB0aGlzIHdvdWxkbid0XG4gIC8vIGJlIG5lY2Vzc2FyeSBidXQgdW5mb3J0dW5hdGVseSBtYW55IGNvZGUgcGF0aHMgcmVhZHMgZnJvbSB0aGUgd29ya0luUHJvZ3Jlc3NcbiAgLy8gd2hlbiB0aGV5IHNob3VsZCBiZSByZWFkaW5nIGZyb20gY3VycmVudCBhbmQgd3JpdGluZyB0byB3b3JrSW5Qcm9ncmVzcy5cbiAgLy8gV2UgYXNzdW1lIHBlbmRpbmdQcm9wcywgaW5kZXgsIGtleSwgcmVmLCByZXR1cm4gYXJlIHN0aWxsIHVudG91Y2hlZCB0b1xuICAvLyBhdm9pZCBkb2luZyBhbm90aGVyIHJlY29uY2lsaWF0aW9uLlxuICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFN0YXRpY01hc2sgfCBQbGFjZW1lbnQ7IC8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZXNldCB0byB0aGUgY2xvbmVkIHZhbHVlcyB0aGF0IGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkJ3ZlLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gICAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICAgIH07XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSkge1xuICB2YXIgbW9kZTtcblxuICBpZiAodGFnID09PSBDb25jdXJyZW50Um9vdCkge1xuICAgIG1vZGUgPSBDb25jdXJyZW50TW9kZTtcblxuICAgIGlmIChpc1N0cmljdE1vZGUgPT09IHRydWUpIHtcbiAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZTtcblxuICAgICAge1xuICAgICAgICBtb2RlIHw9IFN0cmljdEVmZmVjdHNNb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtb2RlID0gTm9Nb2RlO1xuICB9XG5cbiAgaWYgKCBpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIC8vIEFsd2F5cyBjb2xsZWN0IHByb2ZpbGUgdGltaW5ncyB3aGVuIERldlRvb2xzIGFyZSBwcmVzZW50LlxuICAgIC8vIFRoaXMgZW5hYmxlcyBEZXZUb29scyB0byBzdGFydCBjYXB0dXJpbmcgdGltaW5nIGF0IGFueSBwb2ludOKAk1xuICAgIC8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cbiAgICBtb2RlIHw9IFByb2ZpbGVNb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBudWxsLCBtb2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCAvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXJUYWcgPSBJbmRldGVybWluYXRlQ29tcG9uZW50OyAvLyBUaGUgcmVzb2x2ZWQgdHlwZSBpcyBzZXQgaWYgd2Uga25vdyB3aGF0IHRoZSBmaW5hbCB0eXBlIHdpbGwgYmUuIEkuZS4gaXQncyBub3QgbGF6eS5cblxuICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpIHtcbiAgICAgIGZpYmVyVGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBnZXRUYWc6IHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZTtcblxuICAgICAgICBpZiAoIChtb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAvLyBTdHJpY3QgZWZmZWN0cyBzaG91bGQgbmV2ZXIgcnVuIG9uIGxlZ2FjeSByb290c1xuICAgICAgICAgIG1vZGUgfD0gU3RyaWN0RWZmZWN0c01vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29uc3VtZXJcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRDb25zdW1lcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBMYXp5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIiArICduYW1lZCBpbXBvcnRzLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiAnICsgJ2NvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgJyArIChcImJ1dCBnb3Q6IFwiICsgKHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgZmliZXIudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBvd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcblxuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwga2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcyk7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsIHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgICBlZmZlY3REdXJhdGlvbjogMCxcbiAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VMaXN0Q29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKE9mZnNjcmVlbkNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICB2YXIgcHJpbWFyeUNoaWxkSW5zdGFuY2UgPSB7fTtcbiAgZmliZXIuc3RhdGVOb2RlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2U7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChkZWh5ZHJhdGVkTm9kZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihEZWh5ZHJhdGVkRnJhZ21lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IGRlaHlkcmF0ZWROb2RlO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn0gLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cblxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZmxhZ3MgPSBzb3VyY2UuZmxhZ3M7XG4gIHRhcmdldC5zdWJ0cmVlRmxhZ3MgPSBzb3VyY2Uuc3VidHJlZUZsYWdzO1xuICB0YXJnZXQuZGVsZXRpb25zID0gc291cmNlLmRlbGV0aW9ucztcbiAgdGFyZ2V0LmxhbmVzID0gc291cmNlLmxhbmVzO1xuICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcblxuICB7XG4gICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuICAgIHRhcmdldC5hY3R1YWxTdGFydFRpbWUgPSBzb3VyY2UuYWN0dWFsU3RhcnRUaW1lO1xuICAgIHRhcmdldC5zZWxmQmFzZUR1cmF0aW9uID0gc291cmNlLnNlbGZCYXNlRHVyYXRpb247XG4gICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHRhcmdldC5fZGVidWdTb3VyY2UgPSBzb3VyY2UuX2RlYnVnU291cmNlO1xuICB0YXJnZXQuX2RlYnVnT3duZXIgPSBzb3VyY2UuX2RlYnVnT3duZXI7XG4gIHRhcmdldC5fZGVidWdOZWVkc1JlbW91bnQgPSBzb3VyY2UuX2RlYnVnTmVlZHNSZW1vdW50O1xuICB0YXJnZXQuX2RlYnVnSG9va1R5cGVzID0gc291cmNlLl9kZWJ1Z0hvb2tUeXBlcztcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7XG4gIHRoaXMuZXZlbnRUaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG4gIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcChOb1RpbWVzdGFtcCk7XG4gIHRoaXMucGVuZGluZ0xhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmV4cGlyZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMubXV0YWJsZVJlYWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcblxuICBpZiAoc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aGlzLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSBudWxsO1xuICB9XG5cbiAge1xuICAgIHRoaXMuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHRoaXMucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHtcbiAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSB0aGlzLnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBUb3RhbExhbmVzOyBfaSsrKSB7XG4gICAgICBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwLnB1c2gobmV3IFNldCgpKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ29uY3VycmVudFJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gJ2h5ZHJhdGVSb290KCknIDogJ2NyZWF0ZVJvb3QoKSc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExlZ2FjeVJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gJ2h5ZHJhdGUoKScgOiAncmVuZGVyKCknO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgLy8gVE9ETzogV2UgaGF2ZSBzZXZlcmFsIG9mIHRoZXNlIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25jZXB0dWFsbHkgcGFydCBvZiB0aGVcbi8vIGhvc3QgY29uZmlnLCBidXQgYmVjYXVzZSB0aGV5IGFyZSBwYXNzZWQgaW4gYXQgcnVudGltZSwgd2UgaGF2ZSB0byB0aHJlYWRcbi8vIHRoZW0gdGhyb3VnaCB0aGUgcm9vdCBjb25zdHJ1Y3Rvci4gUGVyaGFwcyB3ZSBzaG91bGQgcHV0IHRoZW0gYWxsIGludG8gYVxuLy8gc2luZ2xlIHR5cGUsIGxpa2UgYSBEeW5hbWljSG9zdENvbmZpZyB0aGF0IGlzIGRlZmluZWQgYnkgdGhlIHJlbmRlcmVyLlxuaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciByb290ID0gbmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IpO1xuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuXG5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIodGFnLCBpc1N0cmljdE1vZGUpO1xuICByb290LmN1cnJlbnQgPSB1bmluaXRpYWxpemVkRmliZXI7XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG4gIHtcbiAgICB2YXIgX2luaXRpYWxTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgIGNhY2hlOiBudWxsLFxuICAgICAgLy8gbm90IGVuYWJsZWQgeWV0XG4gICAgICB0cmFuc2l0aW9uczogbnVsbFxuICAgIH07XG4gICAgdW5pbml0aWFsaXplZEZpYmVyLm1lbW9pemVkU3RhdGUgPSBfaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHVuaW5pdGlhbGl6ZWRGaWJlcik7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE4LjAuMC1mYzQ2ZGJhNjctMjAyMjAzMjknO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHtcbiAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGtleSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50KSB7XG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiICsga2V5cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBrZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhvc3RGaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciBoeWRyYXRlID0gZmFsc2U7XG4gIHZhciBpbml0aWFsQ2hpbGRyZW4gPSBudWxsO1xuICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sIC8vIFRPRE86IFJlbW92ZSBgY2FsbGJhY2tgIHdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLlxuY2FsbGJhY2ssIGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcykge1xuICB2YXIgaHlkcmF0ZSA9IHRydWU7XG4gIHZhciByb290ID0gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTsgLy8gVE9ETzogTW92ZSB0aGlzIHRvIEZpYmVyUm9vdCBjb25zdHJ1Y3RvclxuXG4gIHJvb3QuY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpOyAvLyBTY2hlZHVsZSB0aGUgaW5pdGlhbCByZW5kZXIuIEluIGEgaHlkcmF0aW9uIHJvb3QsIHRoaXMgaXMgZGlmZmVyZW50IGZyb21cbiAgLy8gYSByZWd1bGFyIHVwZGF0ZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0IG1hdGNoIHdhcyB3YXMgcmVuZGVyZWRcbiAgLy8gb24gdGhlIHNlcnZlci5cbiAgLy8gTk9URTogVGhpcyB1cGRhdGUgaW50ZW50aW9uYWxseSBkb2Vzbid0IGhhdmUgYSBwYXlsb2FkLiBXZSdyZSBvbmx5IHVzaW5nXG4gIC8vIHRoZSB1cGRhdGUgdG8gc2NoZWR1bGUgd29yayBvbiB0aGUgcm9vdCBmaWJlciAoYW5kLCBmb3IgbGVnYWN5IHJvb3RzLCB0b1xuICAvLyBlbnF1ZXVlIHRoZSBjYWxsYmFjayBpZiBvbmUgaXMgcHJvdmlkZWQpLlxuXG4gIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwgPyBjYWxsYmFjayA6IG51bGw7XG4gIGVucXVldWVVcGRhdGUoY3VycmVudCwgdXBkYXRlKTtcbiAgc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50JDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50JDEpO1xuXG4gIHtcbiAgICBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50XG4gIH07XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcblxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIGVucXVldWVVcGRhdGUoY3VycmVudCQxLCB1cGRhdGUpO1xuICB2YXIgcm9vdCA9IHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGN1cnJlbnQkMSwgbGFuZSk7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICB9XG59XG5mdW5jdGlvbiBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgdmFyIHJvb3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBmaXJzdCBzY2hlZHVsZWQgXCJ1cGRhdGVcIi5cbiAgICAgICAgdmFyIGxhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpO1xuICAgICAgICBmbHVzaFJvb3Qocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG4gICAgICB9KTsgLy8gSWYgd2UncmUgc3RpbGwgYmxvY2tlZCBhZnRlciB0aGlzLCB3ZSBuZWVkIHRvIGluY3JlYXNlXG4gICAgICAvLyB0aGUgcHJpb3JpdHkgb2YgYW55IHByb21pc2VzIHJlc29sdmluZyB3aXRoaW4gdGhpc1xuICAgICAgLy8gYm91bmRhcnkgc28gdGhhdCB0aGV5IG5leHQgYXR0ZW1wdCBhbHNvIGhhcyBoaWdoZXIgcHJpLlxuXG4gICAgICB2YXIgcmV0cnlMYW5lID0gU3luY0xhbmU7XG4gICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgIHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lID0gaGlnaGVyUHJpb3JpdHlMYW5lKHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lLCByZXRyeUxhbmUpO1xuICB9XG59IC8vIEluY3JlYXNlcyB0aGUgcHJpb3JpdHkgb2YgdGhlbmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxudmFyIHNob3VsZEVycm9ySW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZEVycm9yKGZpYmVyKSB7XG4gIHJldHVybiBzaG91bGRFcnJvckltcGwoZmliZXIpO1xufVxuXG52YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xufVxudmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG52YXIgc2V0RXJyb3JIYW5kbGVyID0gbnVsbDtcbnZhciBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuXG57XG4gIHZhciBjb3B5V2l0aERlbGV0ZUltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCkge1xuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICAgIHVwZGF0ZWQuc3BsaWNlKGtleSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFtrZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9IC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aERlbGV0ZSA9IGZ1bmN0aW9uIChvYmosIHBhdGgpIHtcbiAgICByZXR1cm4gY29weVdpdGhEZWxldGVJbXBsKG9iaiwgcGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lSW1wbCA9IGZ1bmN0aW9uIChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG4gICAgdmFyIG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbCggLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgb2JqW29sZEtleV0sIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICB2YXIgZmluZEhvb2sgPSBmdW5jdGlvbiAoZmliZXIsIGlkKSB7XG4gICAgLy8gRm9yIG5vdywgdGhlIFwiaWRcIiBvZiBzdGF0ZWZ1bCBob29rcyBpcyBqdXN0IHRoZSBzdGF0ZWZ1bCBob29rIGluZGV4LlxuICAgIC8vIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlIHdpdGggZS5nLiBuZXN0ZWQgaG9va3MuXG4gICAgdmFyIGN1cnJlbnRIb29rID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBpZCA+IDApIHtcbiAgICAgIGN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgICAgIGlkLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRIb29rO1xuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIGVkaXRhYmxlIHZhbHVlcyBmb3IgdXNlU3RhdGUgYW5kIHVzZVJlZHVjZXIuXG5cblxuICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoU2V0KGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aERlbGV0ZShob29rLm1lbW9pemVkU3RhdGUsIHBhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07IC8vIFN1cHBvcnQgRGV2VG9vbHMgcHJvcHMgZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMsIGZvcndhcmRSZWYsIG1lbW8sIGhvc3QgY29tcG9uZW50cywgZXRjLlxuXG5cbiAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCB2YWx1ZSk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRFcnJvckltcGwpIHtcbiAgICBzaG91bGRFcnJvckltcGwgPSBuZXdTaG91bGRFcnJvckltcGw7XG4gIH07XG5cbiAgc2V0U3VzcGVuc2VIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZFN1c3BlbmRJbXBsKSB7XG4gICAgc2hvdWxkU3VzcGVuZEltcGwgPSBuZXdTaG91bGRTdXNwZW5kSW1wbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMoKSB7XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRvRGV2VG9vbHMoZGV2VG9vbHNDb25maWcpIHtcbiAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG4gIHZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbiAgcmV0dXJuIGluamVjdEludGVybmFscyh7XG4gICAgYnVuZGxlVHlwZTogZGV2VG9vbHNDb25maWcuYnVuZGxlVHlwZSxcbiAgICB2ZXJzaW9uOiBkZXZUb29sc0NvbmZpZy52ZXJzaW9uLFxuICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgcmVuZGVyZXJDb25maWc6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyQ29uZmlnLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlOiBvdmVycmlkZUhvb2tTdGF0ZSxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCxcbiAgICBvdmVycmlkZVByb3BzOiBvdmVycmlkZVByb3BzLFxuICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOiBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCxcbiAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDogb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsXG4gICAgc2V0RXJyb3JIYW5kbGVyOiBzZXRFcnJvckhhbmRsZXIsXG4gICAgc2V0U3VzcGVuc2VIYW5kbGVyOiBzZXRTdXNwZW5zZUhhbmRsZXIsXG4gICAgc2NoZWR1bGVVcGRhdGU6IHNjaGVkdWxlVXBkYXRlLFxuICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcixcbiAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgfHwgZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSxcbiAgICAvLyBSZWFjdCBSZWZyZXNoXG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOiAgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJlZnJlc2g6ICBzY2hlZHVsZVJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUm9vdDogIHNjaGVkdWxlUm9vdCAsXG4gICAgc2V0UmVmcmVzaEhhbmRsZXI6ICBzZXRSZWZyZXNoSGFuZGxlciAsXG4gICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBhcHBlbmQgb3duZXIgc3RhY2tzIHRvIGVycm9yIG1lc3NhZ2VzIGluIERFViBtb2RlLlxuICAgIGdldEN1cnJlbnRGaWJlcjogIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGRldGVjdCByZWNvbmNpbGVyIHZlcnNpb24gcmF0aGVyIHRoYW4gcmVuZGVyZXIgdmVyc2lvblxuICAgIC8vIHdoaWNoIG1heSBub3QgbWF0Y2ggZm9yIHRoaXJkIHBhcnR5IHJlbmRlcmVycy5cbiAgICByZWNvbmNpbGVyVmVyc2lvbjogUmVhY3RWZXJzaW9uXG4gIH0pO1xufVxuXG5leHBvcnRzLmF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb247XG5leHBvcnRzLmF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eTtcbmV4cG9ydHMuYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uID0gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uO1xuZXhwb3J0cy5iYXRjaGVkVXBkYXRlcyA9IGJhdGNoZWRVcGRhdGVzO1xuZXhwb3J0cy5jcmVhdGVDb21wb25lbnRTZWxlY3RvciA9IGNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVDb250YWluZXIgPSBjcmVhdGVDb250YWluZXI7XG5leHBvcnRzLmNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IgPSBjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25Db250YWluZXIgPSBjcmVhdGVIeWRyYXRpb25Db250YWluZXI7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGNyZWF0ZVBvcnRhbDtcbmV4cG9ydHMuY3JlYXRlUm9sZVNlbGVjdG9yID0gY3JlYXRlUm9sZVNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVUZXN0TmFtZVNlbGVjdG9yID0gY3JlYXRlVGVzdE5hbWVTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlVGV4dFNlbGVjdG9yID0gY3JlYXRlVGV4dFNlbGVjdG9yO1xuZXhwb3J0cy5kZWZlcnJlZFVwZGF0ZXMgPSBkZWZlcnJlZFVwZGF0ZXM7XG5leHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGRpc2NyZXRlVXBkYXRlcztcbmV4cG9ydHMuZmluZEFsbE5vZGVzID0gZmluZEFsbE5vZGVzO1xuZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZpbmRCb3VuZGluZ1JlY3RzO1xuZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZTtcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscztcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nO1xuZXhwb3J0cy5mbHVzaENvbnRyb2xsZWQgPSBmbHVzaENvbnRyb2xsZWQ7XG5leHBvcnRzLmZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzO1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmM7XG5leHBvcnRzLmZvY3VzV2l0aGluID0gZm9jdXNXaXRoaW47XG5leHBvcnRzLmdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbmV4cG9ydHMuZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uID0gZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uO1xuZXhwb3J0cy5nZXRQdWJsaWNSb290SW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2U7XG5leHBvcnRzLmluamVjdEludG9EZXZUb29scyA9IGluamVjdEludG9EZXZUb29scztcbmV4cG9ydHMuaXNBbHJlYWR5UmVuZGVyaW5nID0gaXNBbHJlYWR5UmVuZGVyaW5nO1xuZXhwb3J0cy5vYnNlcnZlVmlzaWJsZVJlY3RzID0gb2JzZXJ2ZVZpc2libGVSZWN0cztcbmV4cG9ydHMucmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uID0gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uO1xuZXhwb3J0cy5ydW5XaXRoUHJpb3JpdHkgPSBydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnNob3VsZEVycm9yID0gc2hvdWxkRXJyb3I7XG5leHBvcnRzLnNob3VsZFN1c3BlbmQgPSBzaG91bGRTdXNwZW5kO1xuZXhwb3J0cy51cGRhdGVDb250YWluZXIgPSB1cGRhdGVDb250YWluZXI7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH07XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCIkJCRyZWNvbmNpbGVyIiwiJCQkaG9zdENvbmZpZyIsIlJlYWN0IiwicmVxdWlyZSIsIlNjaGVkdWxlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJzdXBwcmVzc1dhcm5pbmciLCJzZXRTdXBwcmVzc1dhcm5pbmciLCJuZXdTdXBwcmVzc1dhcm5pbmciLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiYXNzaWduIiwiT2JqZWN0IiwiZ2V0Iiwia2V5IiwiX3JlYWN0SW50ZXJuYWxzIiwic2V0IiwidmFsdWUiLCJlbmFibGVQZXJzaXN0ZW50T2Zmc2NyZWVuSG9zdENvbnRhaW5lciIsImVuYWJsZU5ld1JlY29uY2lsZXIiLCJlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uIiwiZW5hYmxlTGVnYWN5SGlkZGVuIiwiZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjayIsIndhcm5BYm91dFN0cmluZ1JlZnMiLCJlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIiLCJlbmFibGVQcm9maWxlclRpbWVyIiwiZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyIsIkZ1bmN0aW9uQ29tcG9uZW50IiwiQ2xhc3NDb21wb25lbnQiLCJJbmRldGVybWluYXRlQ29tcG9uZW50IiwiSG9zdFJvb3QiLCJIb3N0UG9ydGFsIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiRnJhZ21lbnQiLCJNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRm9yd2FyZFJlZiIsIlByb2ZpbGVyIiwiU3VzcGVuc2VDb21wb25lbnQiLCJNZW1vQ29tcG9uZW50IiwiU2ltcGxlTWVtb0NvbXBvbmVudCIsIkxhenlDb21wb25lbnQiLCJJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJEZWh5ZHJhdGVkRnJhZ21lbnQiLCJTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJTY29wZUNvbXBvbmVudCIsIk9mZnNjcmVlbkNvbXBvbmVudCIsIkxlZ2FjeUhpZGRlbkNvbXBvbmVudCIsIkNhY2hlQ29tcG9uZW50IiwiVHJhY2luZ01hcmtlckNvbXBvbmVudCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJSRUFDVF9DQUNIRV9UWVBFIiwiUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJ0eXBlIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwidGFnIiwiJCR0eXBlb2YiLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiZ2V0V3JhcHBlZE5hbWUkMSIsImdldENvbnRleHROYW1lJDEiLCJnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyIiwiZmliZXIiLCJOb0ZsYWdzIiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIlVwZGF0ZSIsIlBsYWNlbWVudEFuZFVwZGF0ZSIsIkNoaWxkRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkRpZENhcHR1cmUiLCJGb3JjZUNsaWVudFJlbmRlciIsIlJlZiIsIlNuYXBzaG90IiwiUGFzc2l2ZSIsIkh5ZHJhdGluZyIsIkh5ZHJhdGluZ0FuZFVwZGF0ZSIsIlZpc2liaWxpdHkiLCJTdG9yZUNvbnNpc3RlbmN5IiwiTGlmZWN5Y2xlRWZmZWN0TWFzayIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlIiwiRm9ya2VkIiwiUmVmU3RhdGljIiwiTGF5b3V0U3RhdGljIiwiUGFzc2l2ZVN0YXRpYyIsIk1vdW50TGF5b3V0RGV2IiwiTW91bnRQYXNzaXZlRGV2IiwiQmVmb3JlTXV0YXRpb25NYXNrIiwiTXV0YXRpb25NYXNrIiwiTGF5b3V0TWFzayIsIlBhc3NpdmVNYXNrIiwiU3RhdGljTWFzayIsIlJlYWN0Q3VycmVudE93bmVyIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5vZGUiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsIm5leHROb2RlIiwiZmxhZ3MiLCJyZXR1cm4iLCJpc0ZpYmVyTW91bnRlZCIsImlzTW91bnRlZCIsImNvbXBvbmVudCIsIm93bmVyIiwiY3VycmVudCIsIm93bmVyRmliZXIiLCJpbnN0YW5jZSIsInN0YXRlTm9kZSIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsIkVycm9yIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwibmV4dFBhcmVudCIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiY3VycmVudFBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVySW1wbCIsIm1hdGNoIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbCIsImlzQXJyYXlJbXBsIiwiaXNBcnJheSIsImdldFB1YmxpY0luc3RhbmNlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInByZXBhcmVGb3JDb21taXQiLCJyZXNldEFmdGVyQ29tbWl0IiwiY3JlYXRlSW5zdGFuY2UiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInByZXBhcmVVcGRhdGUiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsImNyZWF0ZVRleHRJbnN0YW5jZSIsInNjaGVkdWxlVGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJub1RpbWVvdXQiLCJub3ciLCJpc1ByaW1hcnlSZW5kZXJlciIsIndhcm5zSWZOb3RBY3RpbmciLCJzdXBwb3J0c011dGF0aW9uIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwicHJlcGFyZVBvcnRhbE1vdW50IiwicHJlcGFyZVNjb3BlVXBkYXRlIiwiZ2V0SW5zdGFuY2VGcm9tU2NvcGUiLCJnZXRDdXJyZW50RXZlbnRQcmlvcml0eSIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsInN1cHBvcnRzTWljcm90YXNrcyIsInNjaGVkdWxlTWljcm90YXNrIiwic3VwcG9ydHNUZXN0U2VsZWN0b3JzIiwiZmluZEZpYmVyUm9vdCIsImdldEJvdW5kaW5nUmVjdCIsImdldFRleHRDb250ZW50IiwiaXNIaWRkZW5TdWJ0cmVlIiwibWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSIsInNldEZvY3VzSWZGb2N1c2FibGUiLCJzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiY29tbWl0VGV4dFVwZGF0ZSIsImNvbW1pdE1vdW50IiwiY29tbWl0VXBkYXRlIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsInJlc2V0VGV4dENvbnRlbnQiLCJoaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJjbGVhckNvbnRhaW5lciIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJnZXRPZmZzY3JlZW5Db250YWluZXJUeXBlIiwiZ2V0T2Zmc2NyZWVuQ29udGFpbmVyUHJvcHMiLCJjbG9uZUhpZGRlbkluc3RhbmNlIiwiY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UiLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJyZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlIiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJjbGVhclN1c3BlbnNlQm91bmRhcnkiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwic2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMiLCJkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXIiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXIiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2UiLCJlcnJvckh5ZHJhdGluZ0NvbnRhaW5lciIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsInVuZGVmaW5lZCIsInRyaW0iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImNvbnRyb2wiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJSZWZsZWN0Iiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiX2ZyYW1lIiwicmVwbGFjZSIsImluY2x1ZGVzIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUiLCJjdG9yIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImhhc093blByb3BlcnR5IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50IiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJ2YWx1ZVN0YWNrIiwiZmliZXJTdGFjayIsImluZGV4IiwiY3JlYXRlQ3Vyc29yIiwiZGVmYXVsdFZhbHVlIiwicG9wIiwiY3Vyc29yIiwicHVzaCIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsImZyZWV6ZSIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJ3b3JrSW5Qcm9ncmVzcyIsImRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlciIsImlzQ29udGV4dFByb3ZpZGVyIiwiY2FjaGVDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwibWFza2VkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsImdldE1hc2tlZENvbnRleHQiLCJjb250ZXh0VHlwZXMiLCJoYXNDb250ZXh0Q2hhbmdlZCIsImNoaWxkQ29udGV4dFR5cGVzIiwicG9wQ29udGV4dCIsInBvcFRvcExldmVsQ29udGV4dE9iamVjdCIsInB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QiLCJkaWRDaGFuZ2UiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwicGFyZW50Q29udGV4dCIsImdldENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dCIsImNvbnRleHRLZXkiLCJwdXNoQ29udGV4dFByb3ZpZGVyIiwibWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsImludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIiLCJtZXJnZWRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJMZWdhY3lSb290IiwiQ29uY3VycmVudFJvb3QiLCJOb01vZGUiLCJDb25jdXJyZW50TW9kZSIsIlByb2ZpbGVNb2RlIiwiU3RyaWN0TGVnYWN5TW9kZSIsIlN0cmljdEVmZmVjdHNNb2RlIiwiY2x6MzIiLCJNYXRoIiwiY2x6MzJGYWxsYmFjayIsIkxOMiIsImFzVWludCIsIlRvdGFsTGFuZXMiLCJOb0xhbmVzIiwiTm9MYW5lIiwiU3luY0xhbmUiLCJJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIiwiSW5wdXRDb250aW51b3VzTGFuZSIsIkRlZmF1bHRIeWRyYXRpb25MYW5lIiwiRGVmYXVsdExhbmUiLCJUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSIsIlRyYW5zaXRpb25MYW5lcyIsIlRyYW5zaXRpb25MYW5lMSIsIlRyYW5zaXRpb25MYW5lMiIsIlRyYW5zaXRpb25MYW5lMyIsIlRyYW5zaXRpb25MYW5lNCIsIlRyYW5zaXRpb25MYW5lNSIsIlRyYW5zaXRpb25MYW5lNiIsIlRyYW5zaXRpb25MYW5lNyIsIlRyYW5zaXRpb25MYW5lOCIsIlRyYW5zaXRpb25MYW5lOSIsIlRyYW5zaXRpb25MYW5lMTAiLCJUcmFuc2l0aW9uTGFuZTExIiwiVHJhbnNpdGlvbkxhbmUxMiIsIlRyYW5zaXRpb25MYW5lMTMiLCJUcmFuc2l0aW9uTGFuZTE0IiwiVHJhbnNpdGlvbkxhbmUxNSIsIlRyYW5zaXRpb25MYW5lMTYiLCJSZXRyeUxhbmVzIiwiUmV0cnlMYW5lMSIsIlJldHJ5TGFuZTIiLCJSZXRyeUxhbmUzIiwiUmV0cnlMYW5lNCIsIlJldHJ5TGFuZTUiLCJTb21lUmV0cnlMYW5lIiwiU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSIsIk5vbklkbGVMYW5lcyIsIklkbGVIeWRyYXRpb25MYW5lIiwiSWRsZUxhbmUiLCJPZmZzY3JlZW5MYW5lIiwiZ2V0TGFiZWxGb3JMYW5lIiwibGFuZSIsIk5vVGltZXN0YW1wIiwibmV4dFRyYW5zaXRpb25MYW5lIiwibmV4dFJldHJ5TGFuZSIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIiwibGFuZXMiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIiwiZ2V0TmV4dExhbmVzIiwicm9vdCIsIndpcExhbmVzIiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJub25JZGxlVW5ibG9ja2VkTGFuZXMiLCJub25JZGxlUGluZ2VkTGFuZXMiLCJ1bmJsb2NrZWRMYW5lcyIsIm5leHRMYW5lIiwid2lwTGFuZSIsImVudGFuZ2xlZExhbmVzIiwiZW50YW5nbGVtZW50cyIsInBpY2tBcmJpdHJhcnlMYW5lSW5kZXgiLCJnZXRNb3N0UmVjZW50RXZlbnRUaW1lIiwiZXZlbnRUaW1lcyIsIm1vc3RSZWNlbnRFdmVudFRpbWUiLCJldmVudFRpbWUiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50VGltZSIsIm1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQiLCJleHBpcmF0aW9uVGltZXMiLCJleHBpcmF0aW9uVGltZSIsImV4cGlyZWRMYW5lcyIsImdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyIsImdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yIiwiZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiIsImluY2x1ZGVzU3luY0xhbmUiLCJpbmNsdWRlc05vbklkbGVXb3JrIiwiaW5jbHVkZXNPbmx5UmV0cmllcyIsImluY2x1ZGVzT25seVRyYW5zaXRpb25zIiwiaW5jbHVkZXNCbG9ja2luZ0xhbmUiLCJTeW5jRGVmYXVsdExhbmVzIiwiaW5jbHVkZXNFeHBpcmVkTGFuZSIsImlzVHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFJldHJ5TGFuZSIsInBpY2tBcmJpdHJhcnlMYW5lIiwibGFuZVRvSW5kZXgiLCJpbmNsdWRlc1NvbWVMYW5lIiwiaXNTdWJzZXRPZkxhbmVzIiwic3Vic2V0IiwibWVyZ2VMYW5lcyIsInJlbW92ZUxhbmVzIiwiaW50ZXJzZWN0TGFuZXMiLCJsYW5lVG9MYW5lcyIsImhpZ2hlclByaW9yaXR5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsImkiLCJtYXJrUm9vdFVwZGF0ZWQiLCJ1cGRhdGVMYW5lIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJtYXJrUm9vdFBpbmdlZCIsIm1hcmtSb290RmluaXNoZWQiLCJyZW1haW5pbmdMYW5lcyIsIm5vTG9uZ2VyUGVuZGluZ0xhbmVzIiwibXV0YWJsZVJlYWRMYW5lcyIsIm1hcmtSb290RW50YW5nbGVkIiwicm9vdEVudGFuZ2xlZExhbmVzIiwiZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbiIsInJlbmRlckxhbmVzIiwicmVuZGVyTGFuZSIsImFkZEZpYmVyVG9MYW5lc01hcCIsImlzRGV2VG9vbHNQcmVzZW50IiwicGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCIsInVwZGF0ZXJzIiwiYWRkIiwibW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkIiwibWVtb2l6ZWRVcGRhdGVycyIsInNpemUiLCJmb3JFYWNoIiwiY2xlYXIiLCJEaXNjcmV0ZUV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRlZmF1bHRFdmVudFByaW9yaXR5IiwiSWRsZUV2ZW50UHJpb3JpdHkiLCJjdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJuZXdQcmlvcml0eSIsInJ1bldpdGhQcmlvcml0eSIsInByaW9yaXR5IiwicHJldmlvdXNQcmlvcml0eSIsImhpZ2hlckV2ZW50UHJpb3JpdHkiLCJsb3dlckV2ZW50UHJpb3JpdHkiLCJpc0hpZ2hlckV2ZW50UHJpb3JpdHkiLCJsYW5lc1RvRXZlbnRQcmlvcml0eSIsInNjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwiY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInNob3VsZFlpZWxkIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJyZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJub3ckMSIsInVuc3RhYmxlX25vdyIsIkltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJVc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwiTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInVuc3RhYmxlX3lpZWxkVmFsdWUiLCJ1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSIsInJlbmRlcmVySUQiLCJpbmplY3RlZEhvb2siLCJpbmplY3RlZFByb2ZpbGluZ0hvb2tzIiwiaGFzTG9nZ2VkRXJyb3IiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJnZXRMYW5lTGFiZWxNYXAiLCJpbmplY3RQcm9maWxpbmdIb29rcyIsImluamVjdCIsImNoZWNrRENFIiwib25TY2hlZHVsZVJvb3QiLCJjaGlsZHJlbiIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJvbkNvbW1pdFJvb3QiLCJldmVudFByaW9yaXR5Iiwib25Db21taXRGaWJlclJvb3QiLCJkaWRFcnJvciIsInNjaGVkdWxlclByaW9yaXR5Iiwib25Qb3N0Q29tbWl0Um9vdCIsIm9uUG9zdENvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0VW5tb3VudCIsIm9uQ29tbWl0RmliZXJVbm1vdW50Iiwic2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMiLCJuZXdJc1N0cmljdE1vZGUiLCJzZXRTdHJpY3RNb2RlIiwicHJvZmlsaW5nSG9va3MiLCJsYWJlbCIsIm1hcmtDb21taXRTdGFydGVkIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsInRocm93blZhbHVlIiwibWFya0NvbXBvbmVudFN1c3BlbmRlZCIsIndha2VhYmxlIiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJtYXJrUmVuZGVyU3RhcnRlZCIsIm1hcmtSZW5kZXJZaWVsZGVkIiwibWFya1JlbmRlclN0b3BwZWQiLCJtYXJrUmVuZGVyU2NoZWR1bGVkIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwiaXMiLCJ5Iiwib2JqZWN0SXMiLCJzeW5jUXVldWUiLCJpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MiLCJpc0ZsdXNoaW5nU3luY1F1ZXVlIiwic2NoZWR1bGVTeW5jQ2FsbGJhY2siLCJjYWxsYmFjayIsInNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrIiwiZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSIsImZsdXNoU3luY0NhbGxiYWNrcyIsInByZXZpb3VzVXBkYXRlUHJpb3JpdHkiLCJpc1N5bmMiLCJxdWV1ZSIsInNsaWNlIiwiaXNSb290RGVoeWRyYXRlZCIsImN1cnJlbnRTdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJpc0RlaHlkcmF0ZWQiLCJSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyIsIk5vVHJhbnNpdGlvbiIsInJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5cyIsImtleXNCIiwiY3VycmVudEtleSIsImRlc2NyaWJlRmliZXIiLCJfZGVidWdPd25lciIsIl9kZWJ1Z1NvdXJjZSIsImdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsImlzUmVuZGVyaW5nIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwiLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicmVzZXRDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50U3RhY2siLCJzZXRDdXJyZW50RmliZXIiLCJzZXRJc1JlbmRlcmluZyIsInJlbmRlcmluZyIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJmaW5kU3RyaWN0Um9vdCIsIm1heWJlU3RyaWN0Um9vdCIsIm1vZGUiLCJzZXRUb1NvcnRlZFN0cmluZyIsImFycmF5Iiwic29ydCIsImpvaW4iLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsIlNldCIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsInNvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzMiIsIl9zb3J0ZWROYW1lczMiLCJfc29ydGVkTmFtZXM0IiwiX3NvcnRlZE5hbWVzNSIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzdHJpY3RSb290Iiwid2FybmluZ3NGb3JSb290IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsInR5cGVOYW1lIiwiaGFzVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImNvbnN0cnVjdG9yIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tLZXlTdHJpbmdDb2VyY2lvbiIsImNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uIiwicHJvcE5hbWUiLCJyZXNvbHZlRGVmYXVsdFByb3BzIiwiYmFzZVByb3BzIiwiZGVmYXVsdFByb3BzIiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlclNpZ2lsIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwiZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsImV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInB1c2hQcm92aWRlciIsInByb3ZpZGVyRmliZXIiLCJuZXh0VmFsdWUiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRSZW5kZXJlciIsIl9jdXJyZW50VmFsdWUyIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwb3BQcm92aWRlciIsImN1cnJlbnRWYWx1ZSIsInNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgiLCJwcm9wYWdhdGlvblJvb3QiLCJjaGlsZExhbmVzIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIiLCJuZXh0RmliZXIiLCJsaXN0IiwiZGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jeSIsImZpcnN0Q29udGV4dCIsInVwZGF0ZSIsImNyZWF0ZVVwZGF0ZSIsIkZvcmNlVXBkYXRlIiwidXBkYXRlUXVldWUiLCJzaGFyZWRRdWV1ZSIsInNoYXJlZCIsInBlbmRpbmciLCJuZXh0IiwicGFyZW50U3VzcGVuc2UiLCJfYWx0ZXJuYXRlIiwicHJlcGFyZVRvUmVhZENvbnRleHQiLCJtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSIsInJlYWRDb250ZXh0IiwiY29udGV4dEl0ZW0iLCJtZW1vaXplZFZhbHVlIiwiaW50ZXJsZWF2ZWRRdWV1ZXMiLCJwdXNoSW50ZXJsZWF2ZWRRdWV1ZSIsImVucXVldWVJbnRlcmxlYXZlZFVwZGF0ZXMiLCJsYXN0SW50ZXJsZWF2ZWRVcGRhdGUiLCJpbnRlcmxlYXZlZCIsImZpcnN0SW50ZXJsZWF2ZWRVcGRhdGUiLCJsYXN0UGVuZGluZ1VwZGF0ZSIsImZpcnN0UGVuZGluZ1VwZGF0ZSIsIlVwZGF0ZVN0YXRlIiwiUmVwbGFjZVN0YXRlIiwiQ2FwdHVyZVVwZGF0ZSIsImhhc0ZvcmNlVXBkYXRlIiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImluaXRpYWxpemVVcGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwiZWZmZWN0cyIsImNsb25lVXBkYXRlUXVldWUiLCJjdXJyZW50UXVldWUiLCJjbG9uZSIsImVucXVldWVVcGRhdGUiLCJpc0ludGVybGVhdmVkVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9ucyIsInF1ZXVlTGFuZXMiLCJuZXdRdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJwZW5kaW5nUXVldWUiLCJjdXJyZW50TGFzdEJhc2VVcGRhdGUiLCJuZXdTdGF0ZSIsIm5ld0xhbmVzIiwibmV3QmFzZVN0YXRlIiwibmV3Rmlyc3RCYXNlVXBkYXRlIiwibmV3TGFzdEJhc2VVcGRhdGUiLCJ1cGRhdGVFdmVudFRpbWUiLCJfY2xvbmUiLCJfbGFzdFBlbmRpbmdVcGRhdGUiLCJfZmlyc3RQZW5kaW5nVXBkYXRlIiwibGFzdEludGVybGVhdmVkIiwibWFya1NraXBwZWRVcGRhdGVMYW5lcyIsImNhbGxDYWxsYmFjayIsInJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nIiwiY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZyIsImNvbW1pdFVwZGF0ZVF1ZXVlIiwiZmluaXNoZWRXb3JrIiwiZmluaXNoZWRRdWV1ZSIsImVmZmVjdCIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZW1wdHlSZWZzT2JqZWN0IiwicmVmcyIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiY2FsbGVyTmFtZSIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVNldFN0YXRlIiwiaW5zdCIsInJlcXVlc3RFdmVudFRpbWUiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJvbGRTdGF0ZSIsIm5leHRDb250ZXh0Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwic2hvdWxkVXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50IiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJzdGF0ZSIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiX3N0YXRlIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwidXBkYXRlciIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwiaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIiLCJpc1ZhbGlkIiwiYWRkZW5kdW0iLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIl9jb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImNvbXBvbmVudERpZE1vdW50IiwiZmliZXJGbGFncyIsInJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSIsIm1lbW9pemVkUHJvcHMiLCJvbGRDb250ZXh0IiwibmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCIsImhhc05ld0xpZmVjeWNsZXMiLCJfZmliZXJGbGFncyIsIl9maWJlckZsYWdzMiIsInVwZGF0ZUNsYXNzSW5zdGFuY2UiLCJ1bnJlc29sdmVkT2xkUHJvcHMiLCJlbGVtZW50VHlwZSIsInVucmVzb2x2ZWROZXdQcm9wcyIsInBlbmRpbmdQcm9wcyIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrUHJvdmlkZXIiLCJ0cmVlRm9ya0NvdW50IiwiaWRTdGFjayIsImlkU3RhY2tJbmRleCIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsImlzRm9ya2VkQ2hpbGQiLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJnZXRGb3Jrc0F0TGV2ZWwiLCJnZXRUcmVlSWQiLCJvdmVyZmxvdyIsImlkV2l0aExlYWRpbmdCaXQiLCJpZCIsImdldExlYWRpbmdCaXQiLCJ0b1N0cmluZyIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJwdXNoVHJlZUlkIiwiYmFzZUlkV2l0aExlYWRpbmdCaXQiLCJiYXNlT3ZlcmZsb3ciLCJiYXNlTGVuZ3RoIiwiZ2V0Qml0TGVuZ3RoIiwiYmFzZUlkIiwic2xvdCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3ciLCJyZXN0T2ZCYXNlSWQiLCJyZXN0T2ZCYXNlTGVuZ3RoIiwicmVzdE9mTGVuZ3RoIiwicmVzdE9mTmV3Qml0cyIsIm5ld0JpdHMiLCJfaWQiLCJfb3ZlcmZsb3ciLCJwdXNoTWF0ZXJpYWxpemVkVHJlZUlkIiwicmV0dXJuRmliZXIiLCJudW1iZXJPZkZvcmtzIiwic2xvdEluZGV4IiwibnVtYmVyIiwicG9wVHJlZUNvbnRleHQiLCJnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCIsInJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCIsInN1c3BlbmRlZENvbnRleHQiLCJnZXRJc0h5ZHJhdGluZyIsImh5ZHJhdGlvblBhcmVudEZpYmVyIiwibmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImlzSHlkcmF0aW5nIiwiZGlkU3VzcGVuZCIsImh5ZHJhdGlvbkVycm9ycyIsIndhcm5JZkh5ZHJhdGluZyIsIm1hcmtEaWRTdXNwZW5kV2hpbGVIeWRyYXRpbmdERVYiLCJlbnRlckh5ZHJhdGlvblN0YXRlIiwicGFyZW50SW5zdGFuY2UiLCJjb250YWluZXJJbmZvIiwicmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwic3VzcGVuc2VJbnN0YW5jZSIsInRyZWVDb250ZXh0Iiwid2FyblVuaHlkcmF0ZWRJbnN0YW5jZSIsInN1c3BlbnNlU3RhdGUiLCJkZWh5ZHJhdGVkIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiY2hpbGRUb0RlbGV0ZSIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiZGVsZXRpb25zIiwid2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UiLCJwYXJlbnRDb250YWluZXIiLCJ0ZXh0IiwicGFyZW50VHlwZSIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfcHJvcHMiLCJfdGV4dCIsIl9wYXJlbnRJbnN0YW5jZSIsIl90eXBlMiIsIl9wcm9wczIiLCJfdGV4dDIiLCJpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlIiwidHJ5SHlkcmF0ZSIsIm5leHRJbnN0YW5jZSIsInRleHRJbnN0YW5jZSIsInJldHJ5TGFuZSIsImRlaHlkcmF0ZWRGcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudCIsInNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2giLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UiLCJwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwicm9vdENvbnRhaW5lckluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJzaG91bGRXYXJuSWZNaXNtYXRjaERldiIsInVwZGF0ZVBheWxvYWQiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInRleHRDb250ZW50IiwiaXNDb25jdXJyZW50TW9kZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSIsInNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJ3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzIiwiaGFzVW5oeWRyYXRlZFRhaWxOb2RlcyIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJ1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSIsInF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMiLCJxdWV1ZUh5ZHJhdGlvbkVycm9yIiwiZGlkV2FybkFib3V0TWFwcyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjb2VyY2VSZWYiLCJtaXhlZFJlZiIsInJlZiIsIl9zZWxmIiwicmVzb2x2ZWRJbnN0Iiwic3RyaW5nUmVmIiwiX3N0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiY2hpbGRTdHJpbmciLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJyZXNvbHZlTGF6eSIsImxhenlUeXBlIiwiQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlRnJhZ21lbnQiLCJpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmciLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwidXBkYXRlUG9ydGFsIiwicG9ydGFsIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJmcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9udW1iZXJPZkZvcmtzIiwiX25ld0ZpYmVyMiIsImRlbGV0ZSIsIl9udW1iZXJPZkZvcmtzMiIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJuZXdDaGlsZHJlbkl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJfbmV3Q2hpbGRyZW4iLCJfc3RlcCIsImRvbmUiLCJzdGVwIiwiX25ld0ZpYmVyMyIsIl9udW1iZXJPZkZvcmtzMyIsIl9uZXdGaWJlcjQiLCJfbnVtYmVyT2ZGb3JrczQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfZXhpc3RpbmciLCJfY3JlYXRlZDQiLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsImlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQiLCJtb3VudENoaWxkRmliZXJzIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsInJlc2V0Q2hpbGRGaWJlcnMiLCJyZXNldFdvcmtJblByb2dyZXNzIiwiTk9fQ09OVEVYVCIsImNvbnRleHRTdGFja0N1cnNvciQxIiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsInJlcXVpcmVkQ29udGV4dCIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicm9vdEluc3RhbmNlIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJEZWZhdWx0U3VzcGVuc2VDb250ZXh0IiwiU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2siLCJJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQiLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJzdXNwZW5zZVN0YWNrQ3Vyc29yIiwiaGFzU3VzcGVuc2VDb250ZXh0IiwiZmxhZyIsInNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0Iiwic2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dCIsInNoYWxsb3dDb250ZXh0IiwiYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dCIsInN1YnRyZWVDb250ZXh0IiwicHVzaFN1c3BlbnNlQ29udGV4dCIsIm5ld0NvbnRleHQiLCJwb3BTdXNwZW5zZUNvbnRleHQiLCJzaG91bGRDYXB0dXJlU3VzcGVuc2UiLCJoYXNJbnZpc2libGVQYXJlbnQiLCJmaW5kRmlyc3RTdXNwZW5kZWQiLCJyb3ciLCJyZXZlYWxPcmRlciIsIk5vRmxhZ3MkMSIsIkhhc0VmZmVjdCIsIkluc2VydGlvbiIsIkxheW91dCIsIlBhc3NpdmUkMSIsIndvcmtJblByb2dyZXNzU291cmNlcyIsInJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucyIsIm11dGFibGVTb3VyY2UiLCJfd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSIsIl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25TZWNvbmRhcnkiLCJyZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24iLCJnZXRWZXJzaW9uIiwiX2dldFZlcnNpb24iLCJ2ZXJzaW9uIiwibXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MiLCJsb2NhbElkQ291bnRlciIsImdsb2JhbENsaWVudElkQ291bnRlciIsIlJFX1JFTkRFUl9MSU1JVCIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwiaG9va1R5cGVzRGV2IiwiaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsIm1vdW50SG9va1R5cGVzRGV2IiwiaG9va05hbWUiLCJ1cGRhdGVIb29rVHlwZXNEZXYiLCJ3YXJuT25Ib29rTWlzbWF0Y2hJbkRldiIsImNoZWNrRGVwc0FyZUFycmF5RGV2IiwiZGVwcyIsImN1cnJlbnRIb29rTmFtZSIsInRhYmxlIiwic2Vjb25kQ29sdW1uU3RhcnQiLCJvbGRIb29rTmFtZSIsIm5ld0hvb2tOYW1lIiwidGhyb3dJbnZhbGlkSG9va0Vycm9yIiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsInJlbmRlcldpdGhIb29rcyIsInNlY29uZEFyZyIsIm5leHRSZW5kZXJMYW5lcyIsIl9kZWJ1Z0hvb2tUeXBlcyIsIkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJDb250ZXh0T25seURpc3BhdGNoZXIiLCJkaWRSZW5kZXJUb29GZXdIb29rcyIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwiYmFpbG91dEhvb2tzIiwicmVzZXRIb29rc0FmdGVyVGhyb3ciLCJpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlIiwibW91bnRXb3JrSW5Qcm9ncmVzc0hvb2siLCJiYXNlUXVldWUiLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXh0Q3VycmVudEhvb2siLCJuZXh0V29ya0luUHJvZ3Jlc3NIb29rIiwibmV3SG9vayIsImNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUiLCJsYXN0RWZmZWN0Iiwic3RvcmVzIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJhY3Rpb24iLCJtb3VudFJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwibGFzdFJlbmRlcmVkUmVkdWNlciIsImxhc3RSZW5kZXJlZFN0YXRlIiwiZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsImJhc2VGaXJzdCIsInBlbmRpbmdGaXJzdCIsImZpcnN0IiwibmV3QmFzZVF1ZXVlRmlyc3QiLCJuZXdCYXNlUXVldWVMYXN0IiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJpbnRlcmxlYXZlZExhbmUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwibW91bnRNdXRhYmxlU291cmNlIiwiZ2V0U25hcHNob3QiLCJzdWJzY3JpYmUiLCJ1cGRhdGVNdXRhYmxlU291cmNlIiwibW91bnRTeW5jRXh0ZXJuYWxTdG9yZSIsImdldFNlcnZlclNuYXBzaG90IiwibmV4dFNuYXBzaG90IiwiY2FjaGVkU25hcHNob3QiLCJnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QiLCJwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrIiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaEVmZmVjdCIsInVwZGF0ZVN0b3JlSW5zdGFuY2UiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsInByZXZTbmFwc2hvdCIsInNuYXBzaG90Q2hhbmdlZCIsInVwZGF0ZUVmZmVjdCIsInJlbmRlcmVkU25hcHNob3QiLCJjaGVjayIsImNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwiY2hlY2tJZlNuYXBzaG90Q2hhbmdlZCIsImZvcmNlU3RvcmVSZXJlbmRlciIsImhhbmRsZVN0b3JlQ2hhbmdlIiwibGF0ZXN0R2V0U25hcHNob3QiLCJwcmV2VmFsdWUiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsInVwZGF0ZVN0YXRlIiwicmVyZW5kZXJTdGF0ZSIsImNyZWF0ZSIsImRlc3Ryb3kiLCJmaXJzdEVmZmVjdCIsIm1vdW50UmVmIiwiaW5pdGlhbFZhbHVlIiwiX3JlZjIiLCJ1cGRhdGVSZWYiLCJtb3VudEVmZmVjdEltcGwiLCJob29rRmxhZ3MiLCJ1cGRhdGVFZmZlY3RJbXBsIiwicHJldkVmZmVjdCIsIm1vdW50SW5zZXJ0aW9uRWZmZWN0IiwidXBkYXRlSW5zZXJ0aW9uRWZmZWN0IiwibW91bnRMYXlvdXRFZmZlY3QiLCJ1cGRhdGVMYXlvdXRFZmZlY3QiLCJpbXBlcmF0aXZlSGFuZGxlRWZmZWN0IiwicmVmQ2FsbGJhY2siLCJfaW5zdCIsInJlZk9iamVjdCIsIl9pbnN0MiIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsImVmZmVjdERlcHMiLCJ1cGRhdGVJbXBlcmF0aXZlSGFuZGxlIiwibW91bnREZWJ1Z1ZhbHVlIiwiZm9ybWF0dGVyRm4iLCJ1cGRhdGVEZWJ1Z1ZhbHVlIiwibW91bnRDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwibW91bnRNZW1vIiwibmV4dENyZWF0ZSIsInVwZGF0ZU1lbW8iLCJtb3VudERlZmVycmVkVmFsdWUiLCJfbW91bnRTdGF0ZSIsInNldFZhbHVlIiwicHJldlRyYW5zaXRpb24iLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwiX3VwZGF0ZVN0YXRlIiwicmVyZW5kZXJEZWZlcnJlZFZhbHVlIiwiX3JlcmVuZGVyU3RhdGUiLCJzdGFydFRyYW5zaXRpb24iLCJzZXRQZW5kaW5nIiwib3B0aW9ucyIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJ1cGRhdGVkRmliZXJzQ291bnQiLCJtb3VudFRyYW5zaXRpb24iLCJfbW91bnRTdGF0ZTIiLCJpc1BlbmRpbmciLCJzdGFydCIsInVwZGF0ZVRyYW5zaXRpb24iLCJfdXBkYXRlU3RhdGUyIiwicmVyZW5kZXJUcmFuc2l0aW9uIiwiX3JlcmVuZGVyU3RhdGUyIiwiZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZ2xvYmFsQ2xpZW50SWQiLCJ1cGRhdGVJZCIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUiLCJtYXJrVXBkYXRlSW5EZXZUb29scyIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUlkIiwidW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJ3YXJuSW52YWxpZEhvb2tBY2Nlc3MiLCJub3ckMiIsImNvbW1pdFRpbWUiLCJsYXlvdXRFZmZlY3RTdGFydFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsInBhc3NpdmVFZmZlY3RTdGFydFRpbWUiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJpc0N1cnJlbnRVcGRhdGVOZXN0ZWQiLCJtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwicmVzZXROZXN0ZWRVcGRhdGVGbGFnIiwic3luY05lc3RlZFVwZGF0ZUZsYWciLCJnZXRDb21taXRUaW1lIiwicmVjb3JkQ29tbWl0VGltZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsImFjdHVhbFN0YXJ0VGltZSIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSIsIm92ZXJyaWRlQmFzZVRpbWUiLCJlbGFwc2VkVGltZSIsImFjdHVhbER1cmF0aW9uIiwic2VsZkJhc2VEdXJhdGlvbiIsInJlY29yZExheW91dEVmZmVjdER1cmF0aW9uIiwicGFyZW50RmliZXIiLCJlZmZlY3REdXJhdGlvbiIsInBhcmVudFN0YXRlTm9kZSIsInJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInN0YXJ0TGF5b3V0RWZmZWN0VGltZXIiLCJzdGFydFBhc3NpdmVFZmZlY3RUaW1lciIsInRyYW5zZmVyQWN0dWFsRHVyYXRpb24iLCJjcmVhdGVDYXB0dXJlZFZhbHVlIiwic2hvd0Vycm9yRGlhbG9nIiwiYm91bmRhcnkiLCJlcnJvckluZm8iLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJjb21wb25lbnRTdGFjayIsIl9zdXBwcmVzc0xvZ2dpbmciLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJjb21iaW5lZE1lc3NhZ2UiLCJzZXRUaW1lb3V0IiwiUG9zc2libHlXZWFrTWFwJDEiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJvblVuY2F1Z2h0RXJyb3IiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJjb21wb25lbnREaWRDYXRjaCIsIm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQiLCJhdHRhY2hQaW5nTGlzdGVuZXIiLCJwaW5nQ2FjaGUiLCJ0aHJlYWRJRHMiLCJwaW5nIiwicGluZ1N1c3BlbmRlZFJvb3QiLCJyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzIiwidGhlbiIsImF0dGFjaFJldHJ5TGlzdGVuZXIiLCJzdXNwZW5zZUJvdW5kYXJ5Iiwid2FrZWFibGVzIiwicmVzZXRTdXNwZW5kZWRDb21wb25lbnQiLCJzb3VyY2VGaWJlciIsInJvb3RSZW5kZXJMYW5lcyIsImN1cnJlbnRTb3VyY2UiLCJnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZSIsIm1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZSIsImN1cnJlbnRTdXNwZW5zZUJvdW5kYXJ5Iiwib2Zmc2NyZWVuRmliZXIiLCJvZmZzY3JlZW5Db250YWluZXIiLCJjb250YWluZXJQcm9wcyIsImN1cnJlbnRTb3VyY2VGaWJlciIsInRocm93RXhjZXB0aW9uIiwicmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSIsInVuY2F1Z2h0U3VzcGVuc2VFcnJvciIsIl9zdXNwZW5zZUJvdW5kYXJ5IiwicmVuZGVyRGlkRXJyb3IiLCJfZXJyb3JJbmZvIiwiaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeSIsIl9sYW5lIiwiX3VwZGF0ZSIsImdldFN1c3BlbmRlZENhY2hlIiwibWFya1VwZGF0ZSIsIm1hcmtSZWYiLCJoYWROb011dGF0aW9uc0VmZmVjdHMiLCJjb21wbGV0ZWRXb3JrIiwiZGlkQmFpbG91dCIsInN1YnRyZWVGbGFncyIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJ1cGRhdGVIb3N0VGV4dCIsIm5lZWRzVmlzaWJpbGl0eVRvZ2dsZSIsImlzSGlkZGVuIiwiY3VycmVudEhvc3RDb250ZXh0Iiwib2xkVGV4dCIsIm5ld1RleHQiLCJfaW5zdGFuY2UiLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJfaW5zdGFuY2UyIiwicG9ydGFsT3JSb290IiwiY2hpbGRyZW5VbmNoYW5nZWQiLCJjb250YWluZXIiLCJuZXdDaGlsZFNldCIsInBlbmRpbmdDaGlsZHJlbiIsImN1cnJlbnRJbnN0YW5jZSIsInJlY3ljbGFibGVJbnN0YW5jZSIsIm5ld0luc3RhbmNlIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwicmVuZGVyU3RhdGUiLCJoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2siLCJ0YWlsTW9kZSIsInRhaWxOb2RlIiwidGFpbCIsImxhc3RUYWlsTm9kZSIsIl90YWlsTm9kZSIsIl9sYXN0VGFpbE5vZGUiLCJidWJibGVQcm9wZXJ0aWVzIiwibmV3Q2hpbGRMYW5lcyIsInRyZWVCYXNlRHVyYXRpb24iLCJfdHJlZUJhc2VEdXJhdGlvbiIsIl9jaGlsZDIiLCJfY2hpbGQzIiwiY29tcGxldGVXb3JrIiwiZmliZXJSb290IiwicGVuZGluZ0NvbnRleHQiLCJ3YXNIeWRyYXRlZCIsIl93YXNIeWRyYXRlZCIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfY3VycmVudEhvc3RDb250ZXh0IiwiX3dhc0h5ZHJhdGVkMiIsIl93YXNIeWRyYXRlZDMiLCJpc1RpbWVkT3V0U3VzcGVuc2UiLCJwcmltYXJ5Q2hpbGRGcmFnbWVudCIsIl9pc1RpbWVkT3V0U3VzcGVuc2UiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJuZXh0RGlkVGltZW91dCIsInByZXZEaWRUaW1lb3V0IiwiX3ByZXZTdGF0ZSIsIl9vZmZzY3JlZW5GaWJlciIsImhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCIsInVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIiwicmVuZGVyRGlkU3VzcGVuZCIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDIiLCJfQ29tcG9uZW50IiwiZGlkU3VzcGVuZEFscmVhZHkiLCJyZW5kZXJlZFRhaWwiLCJjYW5ub3RCZVN1c3BlbmRlZCIsInJlbmRlckhhc05vdFN1c3BlbmRlZFlldCIsInN1c3BlbmRlZCIsIm5ld1RoZW5hYmxlcyIsImdldFJlbmRlclRhcmdldFRpbWUiLCJfc3VzcGVuZGVkIiwiX25ld1RoZW5hYmxlcyIsInJlbmRlcmluZ1N0YXJ0VGltZSIsImlzQmFja3dhcmRzIiwicHJldmlvdXNTaWJsaW5nIiwibGFzdCIsInN1c3BlbnNlQ29udGV4dCIsInBvcFJlbmRlckxhbmVzIiwiX25leHRTdGF0ZSIsIm5leHRJc0hpZGRlbiIsIl9wcmV2U3RhdGUyIiwicHJldklzSGlkZGVuIiwic3VidHJlZVJlbmRlckxhbmVzIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsImRpZFJlY2VpdmVVcGRhdGUiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsImRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzIiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUiLCJ1cGRhdGVGb3J3YXJkUmVmIiwiaW5uZXJQcm9wVHlwZXMiLCJoYXNJZCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50IiwiaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCIsImNvbXBhcmUiLCJyZXNvbHZlZFR5cGUiLCJyZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmciLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJ1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50IiwiY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzIiwiX2lubmVyUHJvcFR5cGVzIiwiaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwiY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQiLCJwcmV2UHJvcHMiLCJvdXRlck1lbW9UeXBlIiwib3V0ZXJQcm9wVHlwZXMiLCJ1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudCIsImJhc2VMYW5lcyIsImNhY2hlUG9vbCIsInB1c2hSZW5kZXJMYW5lcyIsInNwYXduZWRDYWNoZVBvb2wiLCJuZXh0QmFzZUxhbmVzIiwicHJldkJhc2VMYW5lcyIsIl9uZXh0U3RhdGUyIiwiX3N1YnRyZWVSZW5kZXJMYW5lcyIsInVwZGF0ZU1vZGUiLCJ1cGRhdGVQcm9maWxlciIsIm1hcmtSZWYkMSIsInVwZGF0ZUNsYXNzQ29tcG9uZW50Iiwic2hvdWxkRXJyb3IiLCJ0ZW1wSW5zdGFuY2UiLCJoYXNDb250ZXh0IiwibmV4dFVuaXRPZldvcmsiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsImRpZENhcHR1cmVFcnJvciIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJ1cGRhdGVIb3N0Um9vdCIsInByZXZDaGlsZHJlbiIsIm92ZXJyaWRlU3RhdGUiLCJjYWNoZSIsInRyYW5zaXRpb25zIiwicmVjb3ZlcmFibGVFcnJvciIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwiX3JlY292ZXJhYmxlRXJyb3IiLCJ1cGRhdGVIb3N0Q29tcG9uZW50JDEiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0JDEiLCJtb3VudExhenlDb21wb25lbnQiLCJfY3VycmVudCIsInJlc29sdmVkVGFnIiwicmVzb2x2ZUxhenlDb21wb25lbnRUYWciLCJyZXNvbHZlZFByb3BzIiwicmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nIiwicmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmciLCJoaW50IiwibW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJfY29tcG9uZW50TmFtZTIiLCJvd25lck5hbWUiLCJ3YXJuaW5nS2V5IiwiZGVidWdTb3VyY2UiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJfY29tcG9uZW50TmFtZTMiLCJfY29tcG9uZW50TmFtZTQiLCJTVVNQRU5ERURfTUFSS0VSIiwibW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwidXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZSIsInByZXZPZmZzY3JlZW5TdGF0ZSIsInNob3VsZFJlbWFpbk9uRmFsbGJhY2siLCJnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZSIsInVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50Iiwic2hvdWxkU3VzcGVuZCIsInNob3dGYWxsYmFjayIsIm1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50IiwibmV4dFByaW1hcnlDaGlsZHJlbiIsIm5leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2siLCJmYWxsYmFja0ZyYWdtZW50IiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4iLCJtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwiX2RlaHlkcmF0ZWQiLCJ1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQiLCJyZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuIiwiX25leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2tDaGlsZEZyYWdtZW50IiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmciLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4yIiwiX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsInVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbiIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDMiLCJfbmV4dFByaW1hcnlDaGlsZHJlbjMiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0IiwidXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zIiwiX25leHRQcmltYXJ5Q2hpbGRyZW40IiwiX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDIiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ1IiwiX3ByZXZPZmZzY3JlZW5TdGF0ZSIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuNSIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDYiLCJwcmltYXJ5Q2hpbGRyZW4iLCJwcmltYXJ5Q2hpbGRQcm9wcyIsIm1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlciIsImZhbGxiYWNrQ2hpbGRyZW4iLCJwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50Iiwib2Zmc2NyZWVuUHJvcHMiLCJjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4iLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50IiwiY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsImZpYmVyTW9kZSIsImF0dGVtcHRIeWRyYXRpb25BdExhbmUiLCJyZXRyeSIsInJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIiLCJwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2UiLCJmaXJzdENoaWxkIiwiZmluZExhc3RDb250ZW50Um93IiwibGFzdENvbnRlbnRSb3ciLCJjdXJyZW50Um93IiwidmFsaWRhdGVSZXZlYWxPcmRlciIsInRvTG93ZXJDYXNlIiwidmFsaWRhdGVUYWlsT3B0aW9ucyIsInZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQiLCJjaGlsZFNsb3QiLCJpc0FuQXJyYXkiLCJpc0l0ZXJhYmxlIiwidmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbiIsImNoaWxkcmVuSXRlcmF0b3IiLCJfaSIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsInNob3VsZEZvcmNlRmFsbGJhY2siLCJkaWRTdXNwZW5kQmVmb3JlIiwiX3RhaWwiLCJuZXh0Um93IiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJwcm92aWRlclR5cGUiLCJuZXdWYWx1ZSIsInByb3ZpZGVyUHJvcFR5cGVzIiwib2xkVmFsdWUiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIiLCJ1cGRhdGVDb250ZXh0Q29uc3VtZXIiLCJDb25zdW1lciIsInJlbW91bnRGaWJlciIsIm9sZFdvcmtJblByb2dyZXNzIiwibmV3V29ya0luUHJvZ3Jlc3MiLCJwcmV2U2libGluZyIsInVwZGF0ZUxhbmVzIiwiYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUiLCJoYXNDaGlsZFdvcmsiLCJwcmltYXJ5Q2hpbGRMYW5lcyIsIl9oYXNDaGlsZFdvcmsiLCJiZWdpbldvcmsiLCJfZGVidWdOZWVkc1JlbW91bnQiLCJ1bnJlc29sdmVkUHJvcHMiLCJfdW5yZXNvbHZlZFByb3BzIiwiX3Jlc29sdmVkUHJvcHMiLCJfdW5yZXNvbHZlZFByb3BzMiIsIl9yZXNvbHZlZFByb3BzMiIsIl91bnJlc29sdmVkUHJvcHMzIiwiX3Jlc29sdmVkUHJvcHMzIiwiX0NvbXBvbmVudDIiLCJfdW5yZXNvbHZlZFByb3BzNCIsIl9yZXNvbHZlZFByb3BzNCIsInVud2luZFdvcmsiLCJfZmxhZ3MiLCJfZmxhZ3MyIiwidW53aW5kSW50ZXJydXB0ZWRXb3JrIiwiaW50ZXJydXB0ZWRXb3JrIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZCIsImZ1bmMiLCJkIiwiZiIsImZ1bmNBcmdzIiwib25FcnJvciIsImludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiY3JlYXRlRWxlbWVudCIsImludm9rZUd1YXJkZWRDYWxsYmFja0RldiIsImV2dCIsImRpZENhbGwiLCJ3aW5kb3dFdmVudCIsImV2ZW50Iiwid2luZG93RXZlbnREZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicmVzdG9yZUFmdGVyRGlzcGF0Y2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZ0VHlwZSIsImRpZFNldEVycm9yIiwiaXNDcm9zc09yaWdpbkVycm9yIiwiaGFuZGxlV2luZG93RXJyb3IiLCJjb2xubyIsImxpbmVubyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpbm5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbml0RXZlbnQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEiLCJoYXNFcnJvciIsImNhdWdodEVycm9yIiwicmVwb3J0ZXIiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJoYXNDYXVnaHRFcnJvciIsImNsZWFyQ2F1Z2h0RXJyb3IiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJQb3NzaWJseVdlYWtTZXQiLCJXZWFrU2V0IiwibmV4dEVmZmVjdCIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290IiwicmVwb3J0VW5jYXVnaHRFcnJvckluREVWIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudCIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IiLCJjb21taXRIb29rRWZmZWN0TGlzdE1vdW50IiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQiLCJzYWZlbHlBdHRhY2hSZWYiLCJjb21taXRBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJyZXRWYWwiLCJzYWZlbHlDYWxsRGVzdHJveSIsImZvY3VzZWRJbnN0YW5jZUhhbmRsZSIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbiIsInNob3VsZEZpcmUiLCJlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJzbmFwc2hvdCIsImRpZFdhcm5TZXQiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCIsImNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMiLCJmaW5pc2hlZFJvb3QiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUiLCJvblBvc3RDb21taXQiLCJwaGFzZSIsIm91dGVyIiwiY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlciIsImNvbW1pdHRlZExhbmVzIiwiX3VwZGF0ZVF1ZXVlIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplMiIsIm9uQ29tbWl0Iiwib25SZW5kZXIiLCJlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdCIsImNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzIiwicmVhcHBlYXJMYXlvdXRFZmZlY3RzT25GaWJlciIsImhpZGVPclVuaGlkZUFsbENoaWxkcmVuIiwiaG9zdFN1YnRyZWVSb290IiwiX2luc3RhbmNlMyIsImluc3RhbmNlVG9Vc2UiLCJjb21taXREZXRhY2hSZWYiLCJjdXJyZW50UmVmIiwiY29tbWl0VW5tb3VudCIsIl9lZmZlY3QiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImNvbW1pdE5lc3RlZFVubW91bnRzIiwiZGV0YWNoRmliZXJNdXRhdGlvbiIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwiaG9zdEluc3RhbmNlIiwiZW1wdHlDaGlsZFNldCIsImNvbW1pdENvbnRhaW5lciIsImdldEhvc3RQYXJlbnRGaWJlciIsImlzSG9zdFBhcmVudCIsImdldEhvc3RTaWJsaW5nIiwic2libGluZ3MiLCJjb21taXRQbGFjZW1lbnQiLCJiZWZvcmUiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUiLCJfcGFyZW50IiwiX2JlZm9yZSIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJpc0hvc3QiLCJjdXJyZW50UGFyZW50SXNWYWxpZCIsImN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciIsImZpbmRQYXJlbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRTdXNwZW5zZUNhbGxiYWNrIiwiYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyIsInByZXZSb290U3RhdGUiLCJfcHJldlJvb3RTdGF0ZSIsIl9yb290IiwicmV0cnlDYWNoZSIsInJlc29sdmVSZXRyeVdha2VhYmxlIiwiY29tbWl0UmVzZXRUZXh0Q29udGVudCIsImNvbW1pdE11dGF0aW9uRWZmZWN0cyIsImNvbW1pdE11dGF0aW9uRWZmZWN0c19iZWdpbiIsImNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJ3YXNIaWRkZW4iLCJtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2siLCJfbmV3U3RhdGUiLCJfaXNIaWRkZW4iLCJfY3VycmVudDIiLCJfd2FzSGlkZGVuIiwib2Zmc2NyZWVuQm91bmRhcnkiLCJvZmZzY3JlZW5DaGlsZCIsImRpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4iLCJwcmltYXJ5RmxhZ3MiLCJfY3VycmVudDMiLCJfY3VycmVudDQiLCJfY3VycmVudDUiLCJjb21taXRMYXlvdXRFZmZlY3RzIiwiY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbiIsInN1YnRyZWVSb290IiwiaXNNb2Rlcm5Sb290IiwibmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwiY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlIiwibmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInJlYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbiIsImRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUiLCJyZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUiLCJjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbiIsImNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUiLCJjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2JlZ2luIiwiZmliZXJUb0RlbGV0ZSIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4iLCJwcmV2aW91c0ZpYmVyIiwiZGV0YWNoZWRDaGlsZCIsImRldGFjaGVkU2libGluZyIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsImNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZSIsImRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIiLCJleHBlY3RlZFJldHVybkZpYmVyIiwiaW52b2tlTGF5b3V0RWZmZWN0TW91bnRJbkRFViIsImludm9rZVBhc3NpdmVFZmZlY3RNb3VudEluREVWIiwiaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWIiwiaW52b2tlUGFzc2l2ZUVmZmVjdFVubW91bnRJbkRFViIsIkNPTVBPTkVOVF9UWVBFIiwiSEFTX1BTRVVET19DTEFTU19UWVBFIiwiUk9MRV9UWVBFIiwiVEVTVF9OQU1FX1RZUEUiLCJURVhUX1RZUEUiLCJzeW1ib2xGb3IiLCJjcmVhdGVDb21wb25lbnRTZWxlY3RvciIsImNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IiLCJzZWxlY3RvcnMiLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGV4dFNlbGVjdG9yIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdCIsImhvc3RSb290IiwibWF5YmVGaWJlciIsIm1hdGNoU2VsZWN0b3IiLCJzZWxlY3RvciIsImhhc01hdGNoaW5nUGF0aHMiLCJpbmRleE9mIiwiZGF0YVRlc3RJRCIsInNlbGVjdG9yVG9TdHJpbmciLCJmaW5kUGF0aHMiLCJtYXRjaGluZ0ZpYmVycyIsInNlbGVjdG9ySW5kZXgiLCJmaW5kQWxsTm9kZXMiLCJpbnN0YW5jZVJvb3RzIiwiZnJvbSIsImdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiIsIm1heFNlbGVjdG9ySW5kZXgiLCJtYXRjaGVkTmFtZXMiLCJ1bm1hdGNoZWROYW1lcyIsImZpbmRCb3VuZGluZ1JlY3RzIiwiYm91bmRpbmdSZWN0cyIsInRhcmdldFJlY3QiLCJ0YXJnZXRMZWZ0IiwidGFyZ2V0UmlnaHQiLCJ3aWR0aCIsInRhcmdldFRvcCIsInRhcmdldEJvdHRvbSIsImhlaWdodCIsImoiLCJvdGhlclJlY3QiLCJvdGhlckxlZnQiLCJvdGhlclJpZ2h0Iiwib3RoZXJUb3AiLCJvdGhlckJvdHRvbSIsInNwbGljZSIsImZvY3VzV2l0aGluIiwiY29tbWl0SG9va3MiLCJvbkNvbW1pdFJvb3QkMSIsImNvbW1pdEhvb2siLCJvYnNlcnZlVmlzaWJsZVJlY3RzIiwiX3NldHVwSW50ZXJzZWN0aW9uT2JzIiwiZGlzY29ubmVjdCIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJuZXh0SW5zdGFuY2VSb290cyIsInRhcmdldCIsIlJlYWN0Q3VycmVudEFjdFF1ZXVlIiwiaXNMZWdhY3lBY3RFbnZpcm9ubWVudCIsImlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCIsIklTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCIsImplc3RJc0RlZmluZWQiLCJqZXN0IiwiaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQiLCJjZWlsIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyIiwiUmVhY3RDdXJyZW50T3duZXIkMiIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIiLCJSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxIiwiTm9Db250ZXh0IiwiQmF0Y2hlZENvbnRleHQiLCJSZW5kZXJDb250ZXh0IiwiQ29tbWl0Q29udGV4dCIsIlJvb3RJblByb2dyZXNzIiwiUm9vdEZhdGFsRXJyb3JlZCIsIlJvb3RFcnJvcmVkIiwiUm9vdFN1c3BlbmRlZCIsIlJvb3RTdXNwZW5kZWRXaXRoRGVsYXkiLCJSb290Q29tcGxldGVkIiwiUm9vdERpZE5vdENvbXBsZXRlIiwiZXhlY3V0aW9uQ29udGV4dCIsIndvcmtJblByb2dyZXNzUm9vdCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwic3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yIiwid29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyIsIndvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyIsImdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUiLCJGQUxMQkFDS19USFJPVFRMRV9NUyIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUiLCJJbmZpbml0eSIsIlJFTkRFUl9USU1FT1VUX01TIiwicmVzZXRSZW5kZXJUaW1lciIsImhhc1VuY2F1Z2h0RXJyb3IiLCJmaXJzdFVuY2F1Z2h0RXJyb3IiLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsInJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIiwicm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyIsInBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50Iiwicm9vdFdpdGhOZXN0ZWRVcGRhdGVzIiwiTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUIiwibmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50IiwiY3VycmVudEV2ZW50VGltZSIsImN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lIiwiaXNUcmFuc2l0aW9uIiwiZXZlbnRMYW5lIiwicmVxdWVzdFJldHJ5TGFuZSIsImNoZWNrRm9yTmVzdGVkVXBkYXRlcyIsIm1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290Iiwid2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYiLCJ3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYiLCJtYXJrUm9vdFN1c3BlbmRlZCQxIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwiaXNCYXRjaGluZ0xlZ2FjeSIsInNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdCIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJleGlzdGluZ0NhbGxiYWNrTm9kZSIsImNhbGxiYWNrTm9kZSIsImNhbmNlbENhbGxiYWNrJDEiLCJjYWxsYmFja1ByaW9yaXR5IiwibmV3Q2FsbGJhY2tQcmlvcml0eSIsImV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSIsImZha2VBY3RDYWxsYmFja05vZGUiLCJuZXdDYWxsYmFja05vZGUiLCJkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsInNjaGVkdWxlQ2FsbGJhY2skMSIsInNjaGVkdWxlclByaW9yaXR5TGV2ZWwiLCJwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QiLCJkaWRUaW1lb3V0Iiwib3JpZ2luYWxDYWxsYmFja05vZGUiLCJkaWRGbHVzaFBhc3NpdmVFZmZlY3RzIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsInNob3VsZFRpbWVTbGljZSIsImV4aXRTdGF0dXMiLCJyZW5kZXJSb290Q29uY3VycmVudCIsInJlbmRlclJvb3RTeW5jIiwiZXJyb3JSZXRyeUxhbmVzIiwicmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3IiLCJmYXRhbEVycm9yIiwicHJlcGFyZUZyZXNoU3RhY2siLCJyZW5kZXJXYXNDb25jdXJyZW50IiwiaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzIiwiX2Vycm9yUmV0cnlMYW5lcyIsIl9mYXRhbEVycm9yIiwiZmluaXNoZWRMYW5lcyIsImZpbmlzaENvbmN1cnJlbnRSZW5kZXIiLCJlcnJvcnNGcm9tRmlyc3RBdHRlbXB0Iiwicm9vdFdvcmtJblByb2dyZXNzIiwiZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQiLCJlcnJvcnMiLCJjb21taXRSb290Iiwic2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWIiwibXNVbnRpbFRpbWVvdXQiLCJ0aW1lb3V0SGFuZGxlIiwiZXZlbnRUaW1lTXMiLCJ0aW1lRWxhcHNlZE1zIiwiX21zVW50aWxUaW1lb3V0Iiwiam5kIiwiY2hlY2tzIiwicmVuZGVyZWRWYWx1ZSIsImZsdXNoUm9vdCIsImRlZmVycmVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwicHJldkV4ZWN1dGlvbkNvbnRleHQiLCJkaXNjcmV0ZVVwZGF0ZXMiLCJmbHVzaFN5bmMiLCJpc0FscmVhZHlSZW5kZXJpbmciLCJmbHVzaENvbnRyb2xsZWQiLCJoYW5kbGVFcnJvciIsImVycm9yZWRXb3JrIiwiY29tcGxldGVVbml0T2ZXb3JrIiwieWV0QW5vdGhlclRocm93blZhbHVlIiwicHVzaERpc3BhdGNoZXIiLCJwb3BEaXNwYXRjaGVyIiwid29ya0xvb3BTeW5jIiwicGVyZm9ybVVuaXRPZldvcmsiLCJ3b3JrTG9vcENvbmN1cnJlbnQiLCJ1bml0T2ZXb3JrIiwiYmVnaW5Xb3JrJDEiLCJfbmV4dCIsInNpYmxpbmdGaWJlciIsInJlY292ZXJhYmxlRXJyb3JzIiwicHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkiLCJjb21taXRSb290SW1wbCIsInJlbmRlclByaW9yaXR5TGV2ZWwiLCJmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYiLCJzdWJ0cmVlSGFzRWZmZWN0cyIsInJvb3RIYXNFZmZlY3QiLCJyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzIiwiY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwib25SZWNvdmVyYWJsZUVycm9yIiwicmVuZGVyUHJpb3JpdHkiLCJmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCIsInByb2ZpbGVyRWZmZWN0cyIsIl9maWJlciIsInByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvciIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290Iiwicm9vdEZpYmVyIiwid2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwidGltZUVsYXBzZWQiLCJoYXNQYXNzaXZlRWZmZWN0cyIsImludm9rZUVmZmVjdHNJbkRldiIsImludm9rZUVmZmVjdEZuIiwicHJpbWFyeVN1YnRyZWVGbGFnIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCIsImR1bW15RmliZXIiLCJvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSIsImFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWIiwib3JpZ2luYWxFcnJvciIsInJlcGxheUVycm9yIiwiZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJyZW5kZXJpbmdDb21wb25lbnROYW1lIiwiZGVkdXBlS2V5Iiwic2V0U3RhdGVDb21wb25lbnROYW1lIiwic2NoZWR1bGluZ0ZpYmVyIiwicHJpb3JpdHlMZXZlbCIsImFjdFF1ZXVlIiwicmVzb2x2ZUZhbWlseSIsImZhaWxlZEJvdW5kYXJpZXMiLCJzZXRSZWZyZXNoSGFuZGxlciIsImhhbmRsZXIiLCJmYW1pbHkiLCJjdXJyZW50UmVuZGVyIiwic3ludGhldGljVHlwZSIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJuZWVkc0NvbXBhcmVGYW1pbGllcyIsIiQkdHlwZW9mTmV4dFR5cGUiLCJwcmV2RmFtaWx5Iiwic2NoZWR1bGVSZWZyZXNoIiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsInNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkiLCJzY2hlZHVsZVJvb3QiLCJ1cGRhdGVDb250YWluZXIiLCJjYW5kaWRhdGVUeXBlIiwibmVlZHNSZW5kZXIiLCJuZWVkc1JlbW91bnQiLCJmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2giLCJmYW1pbGllcyIsImhvc3RJbnN0YW5jZXMiLCJ0eXBlcyIsImZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseSIsImRpZE1hdGNoIiwiZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImZvdW5kSG9zdEluc3RhbmNlcyIsImZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwiRmliZXJOb2RlIiwiTnVtYmVyIiwiTmFOIiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QkMSIsImN1cnJlbnREZXBlbmRlbmNpZXMiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiaXNTdHJpY3RNb2RlIiwiY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSIsImZpYmVyVGFnIiwiZ2V0VGFnIiwiY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIiLCJjcmVhdGVGaWJlckZyb21TdXNwZW5zZSIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdCIsImVsZW1lbnRzIiwicHJpbWFyeUNoaWxkSW5zdGFuY2UiLCJjb250ZW50IiwiZGVoeWRyYXRlZE5vZGUiLCJGaWJlclJvb3ROb2RlIiwiaHlkcmF0ZSIsIl9kZWJ1Z1Jvb3RUeXBlIiwiY3JlYXRlRmliZXJSb290IiwiaW5pdGlhbENoaWxkcmVuIiwiaHlkcmF0aW9uQ2FsbGJhY2tzIiwidHJhbnNpdGlvbkNhbGxiYWNrcyIsInVuaW5pdGlhbGl6ZWRGaWJlciIsIl9pbml0aWFsU3RhdGUiLCJSZWFjdFZlcnNpb24iLCJjcmVhdGVQb3J0YWwiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsImZpbmRIb3N0SW5zdGFuY2UiLCJob3N0RmliZXIiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiY3JlYXRlQ29udGFpbmVyIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwiY3VycmVudCQxIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiY29udGFpbmVyRmliZXIiLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZCIsIm1hcmtSZXRyeUxhbmVJbXBsIiwiYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24iLCJhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsInNob3VsZEVycm9ySW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwiY29weVdpdGhEZWxldGVJbXBsIiwib2JqIiwicGF0aCIsInVwZGF0ZWQiLCJjb3B5V2l0aERlbGV0ZSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZFBhdGgiLCJuZXdQYXRoIiwib2xkS2V5IiwibmV3S2V5IiwiY29weVdpdGhSZW5hbWUiLCJjb3B5V2l0aFNldEltcGwiLCJjb3B5V2l0aFNldCIsImZpbmRIb29rIiwibmV3U2hvdWxkRXJyb3JJbXBsIiwibmV3U2hvdWxkU3VzcGVuZEltcGwiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyIsImluamVjdEludG9EZXZUb29scyIsImRldlRvb2xzQ29uZmlnIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsInJlbmRlcmVyQ29uZmlnIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJnZXRDdXJyZW50RmliZXIiLCJyZWNvbmNpbGVyVmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsa0xBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvbm92by8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cy5qcz8wYjdhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyw4SkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW9ub3ZvLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvaW5kZXguanM/MDIxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ })

};
;